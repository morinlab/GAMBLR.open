[
  {
    "objectID": "tutorials/getting_started.html",
    "href": "tutorials/getting_started.html",
    "title": "Tutorial: getting started",
    "section": "",
    "text": "This is a quick tour of some basic commands and usage patterns, just to get you started.\n\n# Load packages\nlibrary(GAMBLR.open)\nlibrary(tidyverse)\n\n# Set a custom GAMBLR theme\ntheme_set(theme_Morons())\n\n# Custom ggplot function that always adds consistent colors and sets scales\nggplot_consistent &lt;- function(...) {\n    ggplot(...) +\n        scale_fill_manual(values = get_gambl_colours()) +\n        scale_y_continuous(expand = expansion(mult = c(0, 0.1)))\n}\n\n# Example gene\nmy_genes &lt;- c(\"MYC\")\n\nThis tutorial explores how to retrieve different data types bundled within GAMBLR.data. Commonly, GAMBLR functions are prefixed with get_. These functions are readily available for returning data of different types: Simple Somatic Mutations (SSM), Copy Number (CN) segments and Structural Variants (SV). This resource explores commonly occurring arguments across different functions, best-practices and recommendations in the scope of retrieving data.\n\n\nFirst, let’s start with retrieving metadata for all GAMBL samples. We can control which samples to be included in the output with seq_type_filter argument, which returns genome samples by default. To return metadata for capture samples, set seq_type_filter = \"capture\". It is also possible to return metadata for more than one seq type, e.g seq_type_filter = c(\"genome\", \"capture\").\n\nmetadata &lt;- list()\n# Get gambl metadata for genome samples\nmetadata$genomes &lt;- get_gambl_metadata(\n    seq_type_filter = \"genome\"\n)\nmetadata$capture &lt;- get_gambl_metadata(\n    seq_type_filter = \"capture\"\n)\nmetadata$all &lt;- get_gambl_metadata(\n    seq_type_filter = c(\"genome\", \"capture\")\n)\n\nmetadata$cell_lines &lt;- get_gambl_metadata() %&gt;%\n    filter(\n        cohort == \"DLBCL_cell_lines\"\n    )\n\nNow that we have the metadata, we can look at the expected column names and their format:\n\nstr(metadata$all)\n\n'data.frame':   2863 obs. of  29 variables:\n $ age_group           : chr  \"Other\" \"Other\" \"Other\" \"Other\" ...\n $ bam_available       : logi  TRUE TRUE TRUE TRUE TRUE TRUE ...\n $ cohort              : chr  \"BL_Thomas\" \"BL_Thomas\" \"BL_Thomas\" \"BL_Thomas\" ...\n $ compression         : chr  \"cram\" \"cram\" \"cram\" \"cram\" ...\n $ COO_consensus       : chr  NA NA NA NA ...\n $ DHITsig_consensus   : chr  \"NA\" \"NA\" \"NA\" \"NA\" ...\n $ EBV_status_inf      : chr  \"EBV-positive\" \"EBV-negative\" \"EBV-negative\" \"EBV-negative\" ...\n $ ffpe_or_frozen      : chr  \"frozen\" \"frozen\" \"frozen\" \"frozen\" ...\n $ fl_grade            : chr  NA NA NA NA ...\n $ genetic_subgroup    : chr  \"DGG-BL\" \"DGG-BL\" \"IC-BL\" \"IC-BL\" ...\n $ genome_build        : chr  \"hg38\" \"hg38\" \"hg38\" \"hg38\" ...\n $ hiv_status          : chr  NA NA NA NA ...\n $ lymphgen            : chr  \"ST2\" \"Other\" \"Other\" \"Other\" ...\n $ lymphgen_cnv_noA53  : chr  \"ST2\" \"Other\" \"Other\" \"Other\" ...\n $ lymphgen_no_cnv     : chr  \"ST2\" \"Other\" \"Other\" \"Other\" ...\n $ lymphgen_with_cnv   : chr  \"ST2\" \"Other\" \"Other\" \"Other\" ...\n $ lymphgen_wright     : chr  NA NA NA NA ...\n $ molecular_BL        : chr  NA NA NA NA ...\n $ normal_sample_id    : chr  NA NA NA NA ...\n $ pairing_status      : chr  \"unmatched\" \"unmatched\" \"unmatched\" \"unmatched\" ...\n $ pathology           : chr  \"BL\" \"BL\" \"BL\" \"BL\" ...\n $ pathology_rank      : num  7 7 7 7 7 7 7 7 7 7 ...\n $ patient_id          : chr  \"BLGSP-71-29-00539\" \"BLGSP-71-29-00525\" \"BLGSP-71-29-00528\" \"BLGSP-71-29-00526\" ...\n $ reference_PMID      : num  36201743 36201743 36201743 36201743 36201743 ...\n $ sample_id           : chr  \"Akata\" \"BL2\" \"BL30\" \"BL41\" ...\n $ seq_type            : chr  \"genome\" \"genome\" \"genome\" \"genome\" ...\n $ sex                 : chr  \"NA\" \"NA\" \"NA\" \"NA\" ...\n $ time_point          : chr  \"A\" \"A\" \"A\" \"A\" ...\n $ Tumor_Sample_Barcode: chr  \"Akata\" \"BL2\" \"BL30\" \"BL41\" ...\n\n\nWe can now use the metadata as we wish. For example, we can visualize the counts of samples per pathology and sequencing type:\n\n# We can see what is included in the metadata\nmetadata$all %&gt;%\n    count(pathology, seq_type) %&gt;%\n    ggplot_consistent(\n        aes(\n            x = pathology,\n            y = n,\n            fill = pathology\n        )\n    ) +\n    geom_bar(stat = \"identity\") +\n    facet_wrap(~seq_type, scales = \"free\") +\n    geom_text(aes(label=n), size=3.5) +\n    theme(\n        axis.text.x = element_text(\n            angle = 90,\n            vjust = 0.5,\n            hjust = 1\n        )\n    )\n\n\n\n\n\n\n\n# We can also visualize these counts when subset to only DLBCL:\n# Subset metadata on a set of samples (samples classified as DLBCL for pathology)\nmetadata$dlbcl &lt;- metadata$all %&gt;%\n    filter(pathology == \"DLBCL\")\n\nmetadata$dlbcl %&gt;%\n    count(pathology, seq_type) %&gt;%\n    ggplot_consistent(\n        aes(\n            x = pathology,\n            y = n,\n            fill = pathology\n        )\n    ) +\n    geom_bar(stat = \"identity\") +\n    facet_wrap(~seq_type) +\n    geom_text(aes(label=n), size=3.5)\n\n\n\n\n\n\n\n\n\n\n\nBased on the information available to you, your application, or your downstream analysis, there are multiple ways to retrieve SSM data. For example, if you know the sample ID and are only interested in looking at SSM results for that particular sample, you can use get_ssm_by_sample. If multiple samples are to be analyzed, get_ssm_by_samples (plural version) is recommended. You can also use patient IDs for retrieving this data, in this case get_ssm_by_patients is available. In addition, you can also restrict SSM calls to specific genomic regions with get_ssm_by_regions or get_ssm_by_region.\nAnother possibility is to focus on coding mutations only and call get_coding_ssm, this function returns all coding SSMs from the bundled data in maf-like format. If you have an already pre-filtered metadata, the these_samples_metadata argument can be used with all SSM functions to restrict the variants returned to the sample IDs in this data frame, handy!\n\n\nReturn SSMs for one or more samples with get_ssm_by_samples. In the example below, we are requesting SSM for the DOHH-2 cell line in two different ways:\n\n\n\nmy_sample_id &lt;- \"DOHH-2\"\n\n# Using the these_samples_id argument\nssm_sample &lt;- get_ssm_by_samples(these_sample_ids = my_sample_id)\n\n# How many mutations do we get back?\ndim(ssm_sample)\n\n[1] 22089    49\n\n# What columns are available?\ncolnames(ssm_sample)\n\n [1] \"Hugo_Symbol\"                   \"Entrez_Gene_Id\"               \n [3] \"Center\"                        \"NCBI_Build\"                   \n [5] \"Chromosome\"                    \"Start_Position\"               \n [7] \"End_Position\"                  \"Strand\"                       \n [9] \"Variant_Classification\"        \"Variant_Type\"                 \n[11] \"Reference_Allele\"              \"Tumor_Seq_Allele1\"            \n[13] \"Tumor_Seq_Allele2\"             \"dbSNP_RS\"                     \n[15] \"dbSNP_Val_Status\"              \"Tumor_Sample_Barcode\"         \n[17] \"Matched_Norm_Sample_Barcode\"   \"Match_Norm_Seq_Allele1\"       \n[19] \"Match_Norm_Seq_Allele2\"        \"Tumor_Validation_Allele1\"     \n[21] \"Tumor_Validation_Allele2\"      \"Match_Norm_Validation_Allele1\"\n[23] \"Match_Norm_Validation_Allele2\" \"Verification_Status\"          \n[25] \"Validation_Status\"             \"Mutation_Status\"              \n[27] \"Sequencing_Phase\"              \"Sequence_Source\"              \n[29] \"Validation_Method\"             \"Score\"                        \n[31] \"BAM_File\"                      \"Sequencer\"                    \n[33] \"Tumor_Sample_UUID\"             \"Matched_Norm_Sample_UUID\"     \n[35] \"HGVSc\"                         \"HGVSp\"                        \n[37] \"HGVSp_Short\"                   \"Transcript_ID\"                \n[39] \"Exon_Number\"                   \"t_depth\"                      \n[41] \"t_ref_count\"                   \"t_alt_count\"                  \n[43] \"n_depth\"                       \"n_ref_count\"                  \n[45] \"n_alt_count\"                   \"RefSeq\"                       \n[47] \"Pipeline\"                      \"Study\"                        \n[49] \"maf_seq_type\"                 \n\n# What variants are available?\nssm_sample %&gt;%\n    count(Variant_Classification) %&gt;%\n    ggplot_consistent(\n        aes(\n            x = Variant_Classification,\n            y = n,\n            fill = Variant_Classification\n        )\n    ) +\n    geom_bar(stat = \"identity\") +\n    geom_text(aes(label=n), size=3.5, vjust = -0.5) +\n    theme(\n        axis.text.x = element_text(\n            angle = 90,\n            vjust = 0.5,\n            hjust = 1\n        )\n    )\n\n\n\n\n\n\n\n\n\n\n\nWe can supply instead a metadata table that has already been subset to the sample ID(s) of interest.\n\nmetadata$dohh2 &lt;- metadata$genome %&gt;%\n    filter(sample_id == \"DOHH-2\")\n\n# Using the these_samples_metadata argument\nssm_meta &lt;- get_ssm_by_samples(\n    these_samples_metadata = metadata$dohh2\n)\n\n# How many mutations do we get back?\ndim(ssm_meta)\n\n[1] 22089    49\n\n# What columns are available?\ncolnames(ssm_meta)\n\n [1] \"Hugo_Symbol\"                   \"Entrez_Gene_Id\"               \n [3] \"Center\"                        \"NCBI_Build\"                   \n [5] \"Chromosome\"                    \"Start_Position\"               \n [7] \"End_Position\"                  \"Strand\"                       \n [9] \"Variant_Classification\"        \"Variant_Type\"                 \n[11] \"Reference_Allele\"              \"Tumor_Seq_Allele1\"            \n[13] \"Tumor_Seq_Allele2\"             \"dbSNP_RS\"                     \n[15] \"dbSNP_Val_Status\"              \"Tumor_Sample_Barcode\"         \n[17] \"Matched_Norm_Sample_Barcode\"   \"Match_Norm_Seq_Allele1\"       \n[19] \"Match_Norm_Seq_Allele2\"        \"Tumor_Validation_Allele1\"     \n[21] \"Tumor_Validation_Allele2\"      \"Match_Norm_Validation_Allele1\"\n[23] \"Match_Norm_Validation_Allele2\" \"Verification_Status\"          \n[25] \"Validation_Status\"             \"Mutation_Status\"              \n[27] \"Sequencing_Phase\"              \"Sequence_Source\"              \n[29] \"Validation_Method\"             \"Score\"                        \n[31] \"BAM_File\"                      \"Sequencer\"                    \n[33] \"Tumor_Sample_UUID\"             \"Matched_Norm_Sample_UUID\"     \n[35] \"HGVSc\"                         \"HGVSp\"                        \n[37] \"HGVSp_Short\"                   \"Transcript_ID\"                \n[39] \"Exon_Number\"                   \"t_depth\"                      \n[41] \"t_ref_count\"                   \"t_alt_count\"                  \n[43] \"n_depth\"                       \"n_ref_count\"                  \n[45] \"n_alt_count\"                   \"RefSeq\"                       \n[47] \"Pipeline\"                      \"Study\"                        \n[49] \"maf_seq_type\"                 \n\n# What variants are available?\nssm_meta %&gt;%\n    count(Variant_Classification) %&gt;%\n    ggplot_consistent(\n        aes(\n            x = Variant_Classification,\n            y = n,\n            fill = Variant_Classification\n        )\n    ) +\n    geom_bar(stat = \"identity\") +\n    geom_text(aes(label=n), size=3.5, vjust = -0.5) +\n    theme(\n        axis.text.x = element_text(\n            angle = 90,\n            vjust = 0.5,\n            hjust = 1\n        )\n    )\n\n\n\n\n\n\n\n\nWe can make sure that both approaches generate identical outputs:\n\nidentical(\n    ssm_sample,\n    ssm_meta\n)\n\n[1] TRUE\n\n\nThus, there is no “right” or “wrong” way, it is simply your personal preference!\n\n\n\nOften many downstream tools can only work on one specific genome build, and GAMBLR.data provides a simple and straightforward way to obtain variants in different projections. The default output is always with respect to grch37, and it can be easily modified with argument projection:\n\nssm_hg38 &lt;- get_ssm_by_samples(\n    projection = \"hg38\"\n)\n\n# Sanity check the projection\nssm_hg38 %&gt;%\n    count(NCBI_Build) %&gt;%\n    ggplot_consistent(\n        aes(\n            x = NCBI_Build,\n            y = n,\n            fill = NCBI_Build\n        )\n    ) +\n    geom_bar(stat = \"identity\") +\n    geom_text(aes(label=n), size=3.5, vjust = -0.5)\n\n\n\n\n\n\n\n\nAs we did not specify any sample ID, metadata, or gene to the above call, it returned the data for all samples available in GAMBLR.data, and we can see from the plot that all of the variants are with respect to hg38. Sweet! 😎\n\n\n\n\nIn this section, we are exploring the different ways you can obtain the maf data for a specific region (or regions) of interest.\nIn this example, we will obtain SSM calls for all aSHM regions associated with PAX5 across all available samples. With this function we also will get the region name added to the returned data frame. If you are providing regions as a bed file (regions_bed), you have the option of setting use_name_column = TRUE. If you do so, your bed file should have a column simply named “name”. In this case, the function will keep this column for naming the returned regions in the maf. With streamlined = TRUE the function returns the minimal number of columns.\n\n\n\n\n\n\nNote\n\n\n\nDon’t know coordinates of aSHM at PAX5? GAMBLR.data has you covered!\n\n\n\n# Get aSHM genes, select the columns of interest and rename for\n# get_ssm_by_regions compatibility\nashm_gene &lt;- \"PAX5\"\nregions &lt;- create_bed_data(\n    GAMBLR.data::grch37_ashm_regions %&gt;%\n        filter(gene == ashm_gene),\n    fix_names = \"concat\",\n    concat_cols = c(\"gene\",\"region\"),\n    sep=\"-\"\n)\n\n# Get ssm for all ashm regions\nashm_ssm &lt;- get_ssm_by_regions(\n    these_samples_metadata = metadata$genomes,\n    regions_bed = regions,\n    streamlined = FALSE\n)\n\ndim(ashm_ssm)\n\n[1] 3238   50\n\nashm_ssm[1:5,1:10]\n\nMAF Data Object\nGenome Build: \nShowing first 10 rows:\n  Hugo_Symbol Entrez_Gene_Id Center NCBI_Build Chromosome Start_Position\n1        PAX5              0      .     GRCh37          9       37033520\n2        PAX5              0      .     GRCh37          9       37034762\n3        PAX5              0      .     GRCh37          9       37033894\n4        PAX5              0      .     GRCh37          9       37035326\n5        PAX5              0      .     GRCh37          9       37030604\n  End_Position Strand Variant_Classification Variant_Type\n1     37033520      +                 Intron          SNP\n2     37034762      +                5'Flank          SNP\n3     37033894      +                 Intron          SNP\n4     37035326      +                5'Flank          SNP\n5     37030604      +                 Intron          SNP\n\n\n\n\n\nLastly, another way to retrieve SSM is to call get_coding_ssm. This function returns coding SSM for any given sample. This function is a convenient option for anyone interested in focusing only on coding mutations. Convenient filtering arguments are included in this function for easy and straightforward subsetting. If these arguments are not used, coding SSM will be returned for all samples. Of course, similar to the examples above, you can provide a metadata subset that has already been filtered to the sample IDs of interest (using these_samples_metadata).\n\n# All default arguments\nall_ssm &lt;- get_coding_ssm()\ndim(all_ssm)\n\n[1] 13913    49\n\n# Provide metadata\ndlbcl_cell_lines &lt;- get_coding_ssm(\n    these_samples_metadata = metadata$cell_lines\n)\ndim(dlbcl_cell_lines)\n\n[1] 1616   49\n\n\n\n\n\n\nFor the purpose of retrieving CN data, we have the function get_sn_segments. If you want to query CN calls for a specific region or genomic loci, get_cn_segments is best used. In this section we will demonstrate how this function can be used.\n\n\nWe can use metadata restricted to the sample ID of interest to demonstrate what type of data will be returned:\n\nseg &lt;- get_cn_segments(\n    these_samples_metadata = metadata$cell_lines\n)\n\n# What are the columns we have available?\nhead(seg)\n\nSEG Data Object\nGenome Build: grch37 \nShowing first 10 rows:\n      ID chrom     start       end LOH_flag log.ratio CN\n1 DOHH-2     1     10001  86026719        0         0  2\n2 DOHH-2     1  86026720  86688464        1         0  2\n3 DOHH-2     1  86688465 121499999        0         0  2\n4 DOHH-2     1 142600001 249250620        0         0  2\n5 DOHH-2     2     10001  89087285        0         0  2\n6 DOHH-2     2  89087286  89997184        1       -10  0\n\n\n\n\n\nWe can retrieve CN segments while also requesting a different projection. Similar to the SSM functionality shown earlier, this can be done by toggling the projection argument and switching it to the hg38 value.\n\n# Call in hg38 projection\nseg &lt;- get_cn_segments(\n    these_samples_metadata = metadata$cell_lines,\n    projection = \"hg38\"\n)\n\nhead(seg)\n\nSEG Data Object\nGenome Build: hg38 \nShowing first 10 rows:\n      ID chrom     start       end LOH_flag log.ratio CN\n1 DOHH-2  chr1     10001  85561036        0         0  2\n2 DOHH-2  chr1  85561037  86222781        1         0  2\n3 DOHH-2  chr1  86222782 121699999        0         0  2\n4 DOHH-2  chr1 143200001 248956421        0         0  2\n5 DOHH-2  chr2         1  91799999        0         0  2\n6 DOHH-2  chr2  96000001 242193528        0         0  2\n\n\n\n\n\n\nIn this last section, we will explore how to get SV data using GAMBLR.data. For this purpose get_manta_sv was developed. This function can restrict the returned calls to any genomic regions specified with chromosome, qstart, qend, or the complete region specified with the region argument (in chr:start-end format). In addition, useful filtering arguments are also available, use min_vaf to set the minimum tumour VAF in order for a SV to be returned and min_score to set the lowest Manta somatic score in order for a SV to be returned. pair_status can be used to obtain variants from either matched or unmatched samples.\n\n\nWe will call get_manta_sv with default arguments to examine the output.\n\n# Default arguments\nall_manta &lt;- get_manta_sv()\n\n# How many SVs do we get back?\nnrow(all_manta)\n\n[1] 1154\n\n# How many samples do we have SV calls for?\nlength(unique(all_manta$tumour_sample_id))\n\n[1] 580\n\n# What does the returned data frame look like?\nhead(all_manta)\n\n  CHROM_A   START_A     END_A CHROM_B   START_B     END_B\n1       1 161658631 161658631       3  16509907  16509907\n2       1 161663959 161663959       9  37363320  37363320\n3       1 161663959 161663959       9  37363320  37363320\n4      11  65267283  65267283      14 106110907 106110907\n5      11  65267422  65267422      14 106110905 106110905\n6      13  91976545  91976545      14 106211857 106211857\n                     manta_name SCORE STRAND_A STRAND_B tumour_sample_id\n1      MantaBND:21171:0:1:0:0:0   133        +        +         FL2002T1\n2     MantaBND:206628:0:1:0:0:0   122        +        +  09-15842_tumorA\n3     MantaBND:195941:0:1:0:0:0   151        +        +  09-15842_tumorB\n4   MantaBND:152220:0:1:0:0:0:0    88        +        -        15-38154T\n5   MantaBND:152220:0:1:0:0:0:0   135        -        +        15-38154T\n6 MantaBND:18:59794:59817:0:1:0    90        -        +        15-31924T\n  normal_sample_id VAF_tumour  DP pair_status FILTER\n1          FL2002N      0.331 127     matched   PASS\n2  09-15842_normal      0.281 196     matched   PASS\n3  09-15842_normal      0.364 187     matched   PASS\n4        15-38154N      0.150 167     matched   PASS\n5        15-38154N      0.290 169     matched   PASS\n6        15-31924N      0.365  85     matched   PASS\n\n\n\n\n\nAlternatively, you can also provide these_samples_metadata argument to make use of a pre-filtered metadata table. In this case, the returned SVs will be restricted to the sample_ids within the data frame.\n\ncell_line_manta &lt;- get_manta_sv(\n    these_samples_metadata = metadata$cell_lines\n)\n\n# How many SVs do we get back?\nnrow(cell_line_manta)\n\n[1] 13\n\n# How many samples do we have SV calls for?\nlength(unique(cell_line_manta$tumour_sample_id))\n\n[1] 3\n\n# What does the returned data frame look like?\nhead(cell_line_manta)\n\n  CHROM_A   START_A     END_A CHROM_B  START_B    END_B\n1      14 106329462 106329462      18 60774579 60774579\n2      14 106329465 106329465      18 60793497 60793497\n3      14 106330466 106330466      18 60793914 60793914\n4      14 106349765 106349765      18 60793914 60793914\n5      14 106379091 106379091      18 60793492 60793492\n6      14 106380227 106380227      18 60774578 60774578\n                 manta_name SCORE STRAND_A STRAND_B tumour_sample_id\n1 MantaBND:220769:1:2:0:0:0   134        +        -        SU-DHL-10\n2 MantaBND:194451:1:2:0:0:0   103        +        -           DOHH-2\n3 MantaBND:217561:1:2:0:0:0   182        +        -         SU-DHL-4\n4 MantaBND:217561:0:1:0:0:0   198        -        +         SU-DHL-4\n5 MantaBND:194451:0:1:0:0:0    91        -        +           DOHH-2\n6 MantaBND:220769:0:1:0:0:0   169        -        +        SU-DHL-10\n  normal_sample_id VAF_tumour DP pair_status FILTER\n1        14-11247N      0.318 66   unmatched   PASS\n2        14-11247N      0.290 69   unmatched   PASS\n3        14-11247N      0.474 57   unmatched   PASS\n4        14-11247N      0.500 62   unmatched   PASS\n5        14-11247N      0.300 60   unmatched   PASS\n6        14-11247N      0.578 45   unmatched   PASS\n\n\n\n\n\nWe can call get_manta_sv specifying the region of interest first in the region format and then with specifying the chromosome, start and end individually.\n\n\n\n\n\n\nNote\n\n\n\nDon’t know coordinates of MYC gene region? GAMBLR got you covered!\n\n\n\n# Convert the gene name to the region\nmyc_region &lt;- gene_to_region(\n    gene_symbol = \"MYC\"\n)\n\nmyc_region\n\n                    MYC \n\"8:128747680-128753674\" \n\n# Specifying MYC in region format\nmyc_manta_region &lt;- get_manta_sv(\n    these_samples_metadata = metadata$genomes,\n    region = myc_region,\n    min_vaf = 0,\n    min_score = 0\n)\n\n# Specifying MYC with chromosome, qstart and qend arguments\nmyc_manta_chunks &lt;- get_manta_sv(\n    these_samples_metadata = metadata$genomes,\n    chromosome = 8,\n    qstart = 128747680,\n    qend = 128753674,\n    min_vaf = 0,\n    min_score = 0\n)\n\n# Are the returned data frames the same?\nidentical(\n    myc_manta_region,\n    myc_manta_chunks\n)\n\n[1] TRUE\n\n\n\n\n\nHere we are demonstrating the filtering options to obtain SVs. In this example, we are calling get_manta_sv on the DLBCL metadata subset. For demonstration purposes, we are also requesting a non-default projection and adding some more filtering.\n\n# Get manta SVs for the samples with DLBCL pathology\ndlbcl_manta &lt;- get_manta_sv(\n    these_samples_metadata = metadata$dlbcl,\n    projection = \"hg38\",\n    min_vaf = 0.4,\n    min_score = 100\n)\n\n# How many variants do we get back with these filters?\nnrow(dlbcl_manta)\n\n[1] 68\n\n# Does the advertised VAF filters work?\nall(dlbcl_manta$VAF_tumour &gt;= 0.4)\n\n[1] TRUE\n\n# Do the advertised SCORE filter work?\nall(dlbcl_manta$SCORE &gt;= 100)\n\n[1] TRUE\n\n# What does the returned data frame look like?\nhead(cell_line_manta)\n\n  CHROM_A   START_A     END_A CHROM_B  START_B    END_B\n1      14 106329462 106329462      18 60774579 60774579\n2      14 106329465 106329465      18 60793497 60793497\n3      14 106330466 106330466      18 60793914 60793914\n4      14 106349765 106349765      18 60793914 60793914\n5      14 106379091 106379091      18 60793492 60793492\n6      14 106380227 106380227      18 60774578 60774578\n                 manta_name SCORE STRAND_A STRAND_B tumour_sample_id\n1 MantaBND:220769:1:2:0:0:0   134        +        -        SU-DHL-10\n2 MantaBND:194451:1:2:0:0:0   103        +        -           DOHH-2\n3 MantaBND:217561:1:2:0:0:0   182        +        -         SU-DHL-4\n4 MantaBND:217561:0:1:0:0:0   198        -        +         SU-DHL-4\n5 MantaBND:194451:0:1:0:0:0    91        -        +           DOHH-2\n6 MantaBND:220769:0:1:0:0:0   169        -        +        SU-DHL-10\n  normal_sample_id VAF_tumour DP pair_status FILTER\n1        14-11247N      0.318 66   unmatched   PASS\n2        14-11247N      0.290 69   unmatched   PASS\n3        14-11247N      0.474 57   unmatched   PASS\n4        14-11247N      0.500 62   unmatched   PASS\n5        14-11247N      0.300 60   unmatched   PASS\n6        14-11247N      0.578 45   unmatched   PASS",
    "crumbs": [
      "Tutorial: getting started"
    ]
  },
  {
    "objectID": "tutorials/getting_started.html#how-do-i-obtain-metadata",
    "href": "tutorials/getting_started.html#how-do-i-obtain-metadata",
    "title": "Tutorial: getting started",
    "section": "",
    "text": "First, let’s start with retrieving metadata for all GAMBL samples. We can control which samples to be included in the output with seq_type_filter argument, which returns genome samples by default. To return metadata for capture samples, set seq_type_filter = \"capture\". It is also possible to return metadata for more than one seq type, e.g seq_type_filter = c(\"genome\", \"capture\").\n\nmetadata &lt;- list()\n# Get gambl metadata for genome samples\nmetadata$genomes &lt;- get_gambl_metadata(\n    seq_type_filter = \"genome\"\n)\nmetadata$capture &lt;- get_gambl_metadata(\n    seq_type_filter = \"capture\"\n)\nmetadata$all &lt;- get_gambl_metadata(\n    seq_type_filter = c(\"genome\", \"capture\")\n)\n\nmetadata$cell_lines &lt;- get_gambl_metadata() %&gt;%\n    filter(\n        cohort == \"DLBCL_cell_lines\"\n    )\n\nNow that we have the metadata, we can look at the expected column names and their format:\n\nstr(metadata$all)\n\n'data.frame':   2863 obs. of  29 variables:\n $ age_group           : chr  \"Other\" \"Other\" \"Other\" \"Other\" ...\n $ bam_available       : logi  TRUE TRUE TRUE TRUE TRUE TRUE ...\n $ cohort              : chr  \"BL_Thomas\" \"BL_Thomas\" \"BL_Thomas\" \"BL_Thomas\" ...\n $ compression         : chr  \"cram\" \"cram\" \"cram\" \"cram\" ...\n $ COO_consensus       : chr  NA NA NA NA ...\n $ DHITsig_consensus   : chr  \"NA\" \"NA\" \"NA\" \"NA\" ...\n $ EBV_status_inf      : chr  \"EBV-positive\" \"EBV-negative\" \"EBV-negative\" \"EBV-negative\" ...\n $ ffpe_or_frozen      : chr  \"frozen\" \"frozen\" \"frozen\" \"frozen\" ...\n $ fl_grade            : chr  NA NA NA NA ...\n $ genetic_subgroup    : chr  \"DGG-BL\" \"DGG-BL\" \"IC-BL\" \"IC-BL\" ...\n $ genome_build        : chr  \"hg38\" \"hg38\" \"hg38\" \"hg38\" ...\n $ hiv_status          : chr  NA NA NA NA ...\n $ lymphgen            : chr  \"ST2\" \"Other\" \"Other\" \"Other\" ...\n $ lymphgen_cnv_noA53  : chr  \"ST2\" \"Other\" \"Other\" \"Other\" ...\n $ lymphgen_no_cnv     : chr  \"ST2\" \"Other\" \"Other\" \"Other\" ...\n $ lymphgen_with_cnv   : chr  \"ST2\" \"Other\" \"Other\" \"Other\" ...\n $ lymphgen_wright     : chr  NA NA NA NA ...\n $ molecular_BL        : chr  NA NA NA NA ...\n $ normal_sample_id    : chr  NA NA NA NA ...\n $ pairing_status      : chr  \"unmatched\" \"unmatched\" \"unmatched\" \"unmatched\" ...\n $ pathology           : chr  \"BL\" \"BL\" \"BL\" \"BL\" ...\n $ pathology_rank      : num  7 7 7 7 7 7 7 7 7 7 ...\n $ patient_id          : chr  \"BLGSP-71-29-00539\" \"BLGSP-71-29-00525\" \"BLGSP-71-29-00528\" \"BLGSP-71-29-00526\" ...\n $ reference_PMID      : num  36201743 36201743 36201743 36201743 36201743 ...\n $ sample_id           : chr  \"Akata\" \"BL2\" \"BL30\" \"BL41\" ...\n $ seq_type            : chr  \"genome\" \"genome\" \"genome\" \"genome\" ...\n $ sex                 : chr  \"NA\" \"NA\" \"NA\" \"NA\" ...\n $ time_point          : chr  \"A\" \"A\" \"A\" \"A\" ...\n $ Tumor_Sample_Barcode: chr  \"Akata\" \"BL2\" \"BL30\" \"BL41\" ...\n\n\nWe can now use the metadata as we wish. For example, we can visualize the counts of samples per pathology and sequencing type:\n\n# We can see what is included in the metadata\nmetadata$all %&gt;%\n    count(pathology, seq_type) %&gt;%\n    ggplot_consistent(\n        aes(\n            x = pathology,\n            y = n,\n            fill = pathology\n        )\n    ) +\n    geom_bar(stat = \"identity\") +\n    facet_wrap(~seq_type, scales = \"free\") +\n    geom_text(aes(label=n), size=3.5) +\n    theme(\n        axis.text.x = element_text(\n            angle = 90,\n            vjust = 0.5,\n            hjust = 1\n        )\n    )\n\n\n\n\n\n\n\n# We can also visualize these counts when subset to only DLBCL:\n# Subset metadata on a set of samples (samples classified as DLBCL for pathology)\nmetadata$dlbcl &lt;- metadata$all %&gt;%\n    filter(pathology == \"DLBCL\")\n\nmetadata$dlbcl %&gt;%\n    count(pathology, seq_type) %&gt;%\n    ggplot_consistent(\n        aes(\n            x = pathology,\n            y = n,\n            fill = pathology\n        )\n    ) +\n    geom_bar(stat = \"identity\") +\n    facet_wrap(~seq_type) +\n    geom_text(aes(label=n), size=3.5)",
    "crumbs": [
      "Tutorial: getting started"
    ]
  },
  {
    "objectID": "tutorials/getting_started.html#how-do-i-obtain-ssm",
    "href": "tutorials/getting_started.html#how-do-i-obtain-ssm",
    "title": "Tutorial: getting started",
    "section": "",
    "text": "Based on the information available to you, your application, or your downstream analysis, there are multiple ways to retrieve SSM data. For example, if you know the sample ID and are only interested in looking at SSM results for that particular sample, you can use get_ssm_by_sample. If multiple samples are to be analyzed, get_ssm_by_samples (plural version) is recommended. You can also use patient IDs for retrieving this data, in this case get_ssm_by_patients is available. In addition, you can also restrict SSM calls to specific genomic regions with get_ssm_by_regions or get_ssm_by_region.\nAnother possibility is to focus on coding mutations only and call get_coding_ssm, this function returns all coding SSMs from the bundled data in maf-like format. If you have an already pre-filtered metadata, the these_samples_metadata argument can be used with all SSM functions to restrict the variants returned to the sample IDs in this data frame, handy!\n\n\nReturn SSMs for one or more samples with get_ssm_by_samples. In the example below, we are requesting SSM for the DOHH-2 cell line in two different ways:\n\n\n\nmy_sample_id &lt;- \"DOHH-2\"\n\n# Using the these_samples_id argument\nssm_sample &lt;- get_ssm_by_samples(these_sample_ids = my_sample_id)\n\n# How many mutations do we get back?\ndim(ssm_sample)\n\n[1] 22089    49\n\n# What columns are available?\ncolnames(ssm_sample)\n\n [1] \"Hugo_Symbol\"                   \"Entrez_Gene_Id\"               \n [3] \"Center\"                        \"NCBI_Build\"                   \n [5] \"Chromosome\"                    \"Start_Position\"               \n [7] \"End_Position\"                  \"Strand\"                       \n [9] \"Variant_Classification\"        \"Variant_Type\"                 \n[11] \"Reference_Allele\"              \"Tumor_Seq_Allele1\"            \n[13] \"Tumor_Seq_Allele2\"             \"dbSNP_RS\"                     \n[15] \"dbSNP_Val_Status\"              \"Tumor_Sample_Barcode\"         \n[17] \"Matched_Norm_Sample_Barcode\"   \"Match_Norm_Seq_Allele1\"       \n[19] \"Match_Norm_Seq_Allele2\"        \"Tumor_Validation_Allele1\"     \n[21] \"Tumor_Validation_Allele2\"      \"Match_Norm_Validation_Allele1\"\n[23] \"Match_Norm_Validation_Allele2\" \"Verification_Status\"          \n[25] \"Validation_Status\"             \"Mutation_Status\"              \n[27] \"Sequencing_Phase\"              \"Sequence_Source\"              \n[29] \"Validation_Method\"             \"Score\"                        \n[31] \"BAM_File\"                      \"Sequencer\"                    \n[33] \"Tumor_Sample_UUID\"             \"Matched_Norm_Sample_UUID\"     \n[35] \"HGVSc\"                         \"HGVSp\"                        \n[37] \"HGVSp_Short\"                   \"Transcript_ID\"                \n[39] \"Exon_Number\"                   \"t_depth\"                      \n[41] \"t_ref_count\"                   \"t_alt_count\"                  \n[43] \"n_depth\"                       \"n_ref_count\"                  \n[45] \"n_alt_count\"                   \"RefSeq\"                       \n[47] \"Pipeline\"                      \"Study\"                        \n[49] \"maf_seq_type\"                 \n\n# What variants are available?\nssm_sample %&gt;%\n    count(Variant_Classification) %&gt;%\n    ggplot_consistent(\n        aes(\n            x = Variant_Classification,\n            y = n,\n            fill = Variant_Classification\n        )\n    ) +\n    geom_bar(stat = \"identity\") +\n    geom_text(aes(label=n), size=3.5, vjust = -0.5) +\n    theme(\n        axis.text.x = element_text(\n            angle = 90,\n            vjust = 0.5,\n            hjust = 1\n        )\n    )\n\n\n\n\n\n\n\n\n\n\n\nWe can supply instead a metadata table that has already been subset to the sample ID(s) of interest.\n\nmetadata$dohh2 &lt;- metadata$genome %&gt;%\n    filter(sample_id == \"DOHH-2\")\n\n# Using the these_samples_metadata argument\nssm_meta &lt;- get_ssm_by_samples(\n    these_samples_metadata = metadata$dohh2\n)\n\n# How many mutations do we get back?\ndim(ssm_meta)\n\n[1] 22089    49\n\n# What columns are available?\ncolnames(ssm_meta)\n\n [1] \"Hugo_Symbol\"                   \"Entrez_Gene_Id\"               \n [3] \"Center\"                        \"NCBI_Build\"                   \n [5] \"Chromosome\"                    \"Start_Position\"               \n [7] \"End_Position\"                  \"Strand\"                       \n [9] \"Variant_Classification\"        \"Variant_Type\"                 \n[11] \"Reference_Allele\"              \"Tumor_Seq_Allele1\"            \n[13] \"Tumor_Seq_Allele2\"             \"dbSNP_RS\"                     \n[15] \"dbSNP_Val_Status\"              \"Tumor_Sample_Barcode\"         \n[17] \"Matched_Norm_Sample_Barcode\"   \"Match_Norm_Seq_Allele1\"       \n[19] \"Match_Norm_Seq_Allele2\"        \"Tumor_Validation_Allele1\"     \n[21] \"Tumor_Validation_Allele2\"      \"Match_Norm_Validation_Allele1\"\n[23] \"Match_Norm_Validation_Allele2\" \"Verification_Status\"          \n[25] \"Validation_Status\"             \"Mutation_Status\"              \n[27] \"Sequencing_Phase\"              \"Sequence_Source\"              \n[29] \"Validation_Method\"             \"Score\"                        \n[31] \"BAM_File\"                      \"Sequencer\"                    \n[33] \"Tumor_Sample_UUID\"             \"Matched_Norm_Sample_UUID\"     \n[35] \"HGVSc\"                         \"HGVSp\"                        \n[37] \"HGVSp_Short\"                   \"Transcript_ID\"                \n[39] \"Exon_Number\"                   \"t_depth\"                      \n[41] \"t_ref_count\"                   \"t_alt_count\"                  \n[43] \"n_depth\"                       \"n_ref_count\"                  \n[45] \"n_alt_count\"                   \"RefSeq\"                       \n[47] \"Pipeline\"                      \"Study\"                        \n[49] \"maf_seq_type\"                 \n\n# What variants are available?\nssm_meta %&gt;%\n    count(Variant_Classification) %&gt;%\n    ggplot_consistent(\n        aes(\n            x = Variant_Classification,\n            y = n,\n            fill = Variant_Classification\n        )\n    ) +\n    geom_bar(stat = \"identity\") +\n    geom_text(aes(label=n), size=3.5, vjust = -0.5) +\n    theme(\n        axis.text.x = element_text(\n            angle = 90,\n            vjust = 0.5,\n            hjust = 1\n        )\n    )\n\n\n\n\n\n\n\n\nWe can make sure that both approaches generate identical outputs:\n\nidentical(\n    ssm_sample,\n    ssm_meta\n)\n\n[1] TRUE\n\n\nThus, there is no “right” or “wrong” way, it is simply your personal preference!\n\n\n\nOften many downstream tools can only work on one specific genome build, and GAMBLR.data provides a simple and straightforward way to obtain variants in different projections. The default output is always with respect to grch37, and it can be easily modified with argument projection:\n\nssm_hg38 &lt;- get_ssm_by_samples(\n    projection = \"hg38\"\n)\n\n# Sanity check the projection\nssm_hg38 %&gt;%\n    count(NCBI_Build) %&gt;%\n    ggplot_consistent(\n        aes(\n            x = NCBI_Build,\n            y = n,\n            fill = NCBI_Build\n        )\n    ) +\n    geom_bar(stat = \"identity\") +\n    geom_text(aes(label=n), size=3.5, vjust = -0.5)\n\n\n\n\n\n\n\n\nAs we did not specify any sample ID, metadata, or gene to the above call, it returned the data for all samples available in GAMBLR.data, and we can see from the plot that all of the variants are with respect to hg38. Sweet! 😎\n\n\n\n\nIn this section, we are exploring the different ways you can obtain the maf data for a specific region (or regions) of interest.\nIn this example, we will obtain SSM calls for all aSHM regions associated with PAX5 across all available samples. With this function we also will get the region name added to the returned data frame. If you are providing regions as a bed file (regions_bed), you have the option of setting use_name_column = TRUE. If you do so, your bed file should have a column simply named “name”. In this case, the function will keep this column for naming the returned regions in the maf. With streamlined = TRUE the function returns the minimal number of columns.\n\n\n\n\n\n\nNote\n\n\n\nDon’t know coordinates of aSHM at PAX5? GAMBLR.data has you covered!\n\n\n\n# Get aSHM genes, select the columns of interest and rename for\n# get_ssm_by_regions compatibility\nashm_gene &lt;- \"PAX5\"\nregions &lt;- create_bed_data(\n    GAMBLR.data::grch37_ashm_regions %&gt;%\n        filter(gene == ashm_gene),\n    fix_names = \"concat\",\n    concat_cols = c(\"gene\",\"region\"),\n    sep=\"-\"\n)\n\n# Get ssm for all ashm regions\nashm_ssm &lt;- get_ssm_by_regions(\n    these_samples_metadata = metadata$genomes,\n    regions_bed = regions,\n    streamlined = FALSE\n)\n\ndim(ashm_ssm)\n\n[1] 3238   50\n\nashm_ssm[1:5,1:10]\n\nMAF Data Object\nGenome Build: \nShowing first 10 rows:\n  Hugo_Symbol Entrez_Gene_Id Center NCBI_Build Chromosome Start_Position\n1        PAX5              0      .     GRCh37          9       37033520\n2        PAX5              0      .     GRCh37          9       37034762\n3        PAX5              0      .     GRCh37          9       37033894\n4        PAX5              0      .     GRCh37          9       37035326\n5        PAX5              0      .     GRCh37          9       37030604\n  End_Position Strand Variant_Classification Variant_Type\n1     37033520      +                 Intron          SNP\n2     37034762      +                5'Flank          SNP\n3     37033894      +                 Intron          SNP\n4     37035326      +                5'Flank          SNP\n5     37030604      +                 Intron          SNP\n\n\n\n\n\nLastly, another way to retrieve SSM is to call get_coding_ssm. This function returns coding SSM for any given sample. This function is a convenient option for anyone interested in focusing only on coding mutations. Convenient filtering arguments are included in this function for easy and straightforward subsetting. If these arguments are not used, coding SSM will be returned for all samples. Of course, similar to the examples above, you can provide a metadata subset that has already been filtered to the sample IDs of interest (using these_samples_metadata).\n\n# All default arguments\nall_ssm &lt;- get_coding_ssm()\ndim(all_ssm)\n\n[1] 13913    49\n\n# Provide metadata\ndlbcl_cell_lines &lt;- get_coding_ssm(\n    these_samples_metadata = metadata$cell_lines\n)\ndim(dlbcl_cell_lines)\n\n[1] 1616   49",
    "crumbs": [
      "Tutorial: getting started"
    ]
  },
  {
    "objectID": "tutorials/getting_started.html#how-do-i-obtain-cnv",
    "href": "tutorials/getting_started.html#how-do-i-obtain-cnv",
    "title": "Tutorial: getting started",
    "section": "",
    "text": "For the purpose of retrieving CN data, we have the function get_sn_segments. If you want to query CN calls for a specific region or genomic loci, get_cn_segments is best used. In this section we will demonstrate how this function can be used.\n\n\nWe can use metadata restricted to the sample ID of interest to demonstrate what type of data will be returned:\n\nseg &lt;- get_cn_segments(\n    these_samples_metadata = metadata$cell_lines\n)\n\n# What are the columns we have available?\nhead(seg)\n\nSEG Data Object\nGenome Build: grch37 \nShowing first 10 rows:\n      ID chrom     start       end LOH_flag log.ratio CN\n1 DOHH-2     1     10001  86026719        0         0  2\n2 DOHH-2     1  86026720  86688464        1         0  2\n3 DOHH-2     1  86688465 121499999        0         0  2\n4 DOHH-2     1 142600001 249250620        0         0  2\n5 DOHH-2     2     10001  89087285        0         0  2\n6 DOHH-2     2  89087286  89997184        1       -10  0\n\n\n\n\n\nWe can retrieve CN segments while also requesting a different projection. Similar to the SSM functionality shown earlier, this can be done by toggling the projection argument and switching it to the hg38 value.\n\n# Call in hg38 projection\nseg &lt;- get_cn_segments(\n    these_samples_metadata = metadata$cell_lines,\n    projection = \"hg38\"\n)\n\nhead(seg)\n\nSEG Data Object\nGenome Build: hg38 \nShowing first 10 rows:\n      ID chrom     start       end LOH_flag log.ratio CN\n1 DOHH-2  chr1     10001  85561036        0         0  2\n2 DOHH-2  chr1  85561037  86222781        1         0  2\n3 DOHH-2  chr1  86222782 121699999        0         0  2\n4 DOHH-2  chr1 143200001 248956421        0         0  2\n5 DOHH-2  chr2         1  91799999        0         0  2\n6 DOHH-2  chr2  96000001 242193528        0         0  2",
    "crumbs": [
      "Tutorial: getting started"
    ]
  },
  {
    "objectID": "tutorials/getting_started.html#how-do-i-obtain-sv",
    "href": "tutorials/getting_started.html#how-do-i-obtain-sv",
    "title": "Tutorial: getting started",
    "section": "",
    "text": "In this last section, we will explore how to get SV data using GAMBLR.data. For this purpose get_manta_sv was developed. This function can restrict the returned calls to any genomic regions specified with chromosome, qstart, qend, or the complete region specified with the region argument (in chr:start-end format). In addition, useful filtering arguments are also available, use min_vaf to set the minimum tumour VAF in order for a SV to be returned and min_score to set the lowest Manta somatic score in order for a SV to be returned. pair_status can be used to obtain variants from either matched or unmatched samples.\n\n\nWe will call get_manta_sv with default arguments to examine the output.\n\n# Default arguments\nall_manta &lt;- get_manta_sv()\n\n# How many SVs do we get back?\nnrow(all_manta)\n\n[1] 1154\n\n# How many samples do we have SV calls for?\nlength(unique(all_manta$tumour_sample_id))\n\n[1] 580\n\n# What does the returned data frame look like?\nhead(all_manta)\n\n  CHROM_A   START_A     END_A CHROM_B   START_B     END_B\n1       1 161658631 161658631       3  16509907  16509907\n2       1 161663959 161663959       9  37363320  37363320\n3       1 161663959 161663959       9  37363320  37363320\n4      11  65267283  65267283      14 106110907 106110907\n5      11  65267422  65267422      14 106110905 106110905\n6      13  91976545  91976545      14 106211857 106211857\n                     manta_name SCORE STRAND_A STRAND_B tumour_sample_id\n1      MantaBND:21171:0:1:0:0:0   133        +        +         FL2002T1\n2     MantaBND:206628:0:1:0:0:0   122        +        +  09-15842_tumorA\n3     MantaBND:195941:0:1:0:0:0   151        +        +  09-15842_tumorB\n4   MantaBND:152220:0:1:0:0:0:0    88        +        -        15-38154T\n5   MantaBND:152220:0:1:0:0:0:0   135        -        +        15-38154T\n6 MantaBND:18:59794:59817:0:1:0    90        -        +        15-31924T\n  normal_sample_id VAF_tumour  DP pair_status FILTER\n1          FL2002N      0.331 127     matched   PASS\n2  09-15842_normal      0.281 196     matched   PASS\n3  09-15842_normal      0.364 187     matched   PASS\n4        15-38154N      0.150 167     matched   PASS\n5        15-38154N      0.290 169     matched   PASS\n6        15-31924N      0.365  85     matched   PASS\n\n\n\n\n\nAlternatively, you can also provide these_samples_metadata argument to make use of a pre-filtered metadata table. In this case, the returned SVs will be restricted to the sample_ids within the data frame.\n\ncell_line_manta &lt;- get_manta_sv(\n    these_samples_metadata = metadata$cell_lines\n)\n\n# How many SVs do we get back?\nnrow(cell_line_manta)\n\n[1] 13\n\n# How many samples do we have SV calls for?\nlength(unique(cell_line_manta$tumour_sample_id))\n\n[1] 3\n\n# What does the returned data frame look like?\nhead(cell_line_manta)\n\n  CHROM_A   START_A     END_A CHROM_B  START_B    END_B\n1      14 106329462 106329462      18 60774579 60774579\n2      14 106329465 106329465      18 60793497 60793497\n3      14 106330466 106330466      18 60793914 60793914\n4      14 106349765 106349765      18 60793914 60793914\n5      14 106379091 106379091      18 60793492 60793492\n6      14 106380227 106380227      18 60774578 60774578\n                 manta_name SCORE STRAND_A STRAND_B tumour_sample_id\n1 MantaBND:220769:1:2:0:0:0   134        +        -        SU-DHL-10\n2 MantaBND:194451:1:2:0:0:0   103        +        -           DOHH-2\n3 MantaBND:217561:1:2:0:0:0   182        +        -         SU-DHL-4\n4 MantaBND:217561:0:1:0:0:0   198        -        +         SU-DHL-4\n5 MantaBND:194451:0:1:0:0:0    91        -        +           DOHH-2\n6 MantaBND:220769:0:1:0:0:0   169        -        +        SU-DHL-10\n  normal_sample_id VAF_tumour DP pair_status FILTER\n1        14-11247N      0.318 66   unmatched   PASS\n2        14-11247N      0.290 69   unmatched   PASS\n3        14-11247N      0.474 57   unmatched   PASS\n4        14-11247N      0.500 62   unmatched   PASS\n5        14-11247N      0.300 60   unmatched   PASS\n6        14-11247N      0.578 45   unmatched   PASS\n\n\n\n\n\nWe can call get_manta_sv specifying the region of interest first in the region format and then with specifying the chromosome, start and end individually.\n\n\n\n\n\n\nNote\n\n\n\nDon’t know coordinates of MYC gene region? GAMBLR got you covered!\n\n\n\n# Convert the gene name to the region\nmyc_region &lt;- gene_to_region(\n    gene_symbol = \"MYC\"\n)\n\nmyc_region\n\n                    MYC \n\"8:128747680-128753674\" \n\n# Specifying MYC in region format\nmyc_manta_region &lt;- get_manta_sv(\n    these_samples_metadata = metadata$genomes,\n    region = myc_region,\n    min_vaf = 0,\n    min_score = 0\n)\n\n# Specifying MYC with chromosome, qstart and qend arguments\nmyc_manta_chunks &lt;- get_manta_sv(\n    these_samples_metadata = metadata$genomes,\n    chromosome = 8,\n    qstart = 128747680,\n    qend = 128753674,\n    min_vaf = 0,\n    min_score = 0\n)\n\n# Are the returned data frames the same?\nidentical(\n    myc_manta_region,\n    myc_manta_chunks\n)\n\n[1] TRUE\n\n\n\n\n\nHere we are demonstrating the filtering options to obtain SVs. In this example, we are calling get_manta_sv on the DLBCL metadata subset. For demonstration purposes, we are also requesting a non-default projection and adding some more filtering.\n\n# Get manta SVs for the samples with DLBCL pathology\ndlbcl_manta &lt;- get_manta_sv(\n    these_samples_metadata = metadata$dlbcl,\n    projection = \"hg38\",\n    min_vaf = 0.4,\n    min_score = 100\n)\n\n# How many variants do we get back with these filters?\nnrow(dlbcl_manta)\n\n[1] 68\n\n# Does the advertised VAF filters work?\nall(dlbcl_manta$VAF_tumour &gt;= 0.4)\n\n[1] TRUE\n\n# Do the advertised SCORE filter work?\nall(dlbcl_manta$SCORE &gt;= 100)\n\n[1] TRUE\n\n# What does the returned data frame look like?\nhead(cell_line_manta)\n\n  CHROM_A   START_A     END_A CHROM_B  START_B    END_B\n1      14 106329462 106329462      18 60774579 60774579\n2      14 106329465 106329465      18 60793497 60793497\n3      14 106330466 106330466      18 60793914 60793914\n4      14 106349765 106349765      18 60793914 60793914\n5      14 106379091 106379091      18 60793492 60793492\n6      14 106380227 106380227      18 60774578 60774578\n                 manta_name SCORE STRAND_A STRAND_B tumour_sample_id\n1 MantaBND:220769:1:2:0:0:0   134        +        -        SU-DHL-10\n2 MantaBND:194451:1:2:0:0:0   103        +        -           DOHH-2\n3 MantaBND:217561:1:2:0:0:0   182        +        -         SU-DHL-4\n4 MantaBND:217561:0:1:0:0:0   198        -        +         SU-DHL-4\n5 MantaBND:194451:0:1:0:0:0    91        -        +           DOHH-2\n6 MantaBND:220769:0:1:0:0:0   169        -        +        SU-DHL-10\n  normal_sample_id VAF_tumour DP pair_status FILTER\n1        14-11247N      0.318 66   unmatched   PASS\n2        14-11247N      0.290 69   unmatched   PASS\n3        14-11247N      0.474 57   unmatched   PASS\n4        14-11247N      0.500 62   unmatched   PASS\n5        14-11247N      0.300 60   unmatched   PASS\n6        14-11247N      0.578 45   unmatched   PASS",
    "crumbs": [
      "Tutorial: getting started"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "GAMBLR.open",
    "section": "",
    "text": "Why use GAMBLR.open?\n  \n  \n    \n     How to install?\n  \n  \n    \n     How to use?\n  \n  \n    \n     Release notes\n  \n  \n    \n     GitHub"
  },
  {
    "objectID": "index.html#about",
    "href": "index.html#about",
    "title": "GAMBLR.open",
    "section": "About",
    "text": "About\nThe GAMBLR-verse is a database, mining, manipulation and collection of a convenience functions for working with genomic data of mature B-cell lymphomas. The GAMBLR.open is an open-source package that is a wrapper providing a convenient one-stop access to load the following packages from the GAMBLR family:\n\nGAMBLR.open - collection of genomic data for analysis of Mature B-cell neoplasms\nGAMBLR.helpers - a set of low-level functions for data operation\nGAMBLR.utils - higher level set of functions to operate on genomic data\nGAMBLR.viz - set of functions used mostly for visualizations\nGAMBLR.predict - collection of functions and helpers to classify B-cell lymphomas\n\nIn addition, a number of simple functions is included, giving access to a light-weight version of the functionality available for the GAMBL consortium members.\n\n\n\n\n\n\nWho should use this package?\n\n\n\nThis package is recommended for the community interested in lymphoma genomics research and are not members of the GAMBL consortium, or if you are waiting for your access approval but want to get started. In addition to being a large resource for lymphoma researchers, this package is also a great educational resource for junior users interested in bioinformatics analyses, genomics, software analysis, data engineering, R package development, GitHub workflows, and other best practices."
  },
  {
    "objectID": "index.html#install",
    "href": "index.html#install",
    "title": "GAMBLR.open",
    "section": "Install",
    "text": "Install\nTo install this package, we recommend doing it by accessing the latest master version directly from GitHub (requires devtools dependency):\ndevtools::install_github(\n    \"morinlab/GAMBLR.open\",\n    repos = BiocManager::repositories()\n)\n\n\n\nQuickstart"
  },
  {
    "objectID": "index.html#quickstart",
    "href": "index.html#quickstart",
    "title": "GAMBLR.open",
    "section": "Quickstart",
    "text": "Quickstart\nThe quick and easy way to get started is to make sure the devtools dependency is installed, then install the GAMBLR.open and run the simplest functions to confirm successful setup:\n# Verify devtools is installed\nif (!require(\"devtools\")) install.packages(\"devtools\")\n\n# Install GAMBLR.open\ndevtools::install_github(\n    \"morinlab/GAMBLR.open\",\n    repos = BiocManager::repositories()\n)\nWe recommend restarting your R session after the installation.\n\nlibrary(GAMBLR.open)\n\n# Confirm successful setup\nmetadata &lt;- get_gambl_metadata()\nmaf &lt;- get_coding_ssm()"
  },
  {
    "objectID": "index.html#installation-for-developers",
    "href": "index.html#installation-for-developers",
    "title": "GAMBLR.open",
    "section": "Installation for developers",
    "text": "Installation for developers\nThe easiest way to obtain and contribute to GAMBLR.open is to do this via cloning the repository\ncd\ngit clone git@github.com:morinlab/GAMBLR.open.git\nIn your R editor of choice (which is hopefully VS Code), set your working directory to the directory you just cloned the repo into.\nsetwd(\"~/GAMBLR.open\")\nInstall the package in R by running the following command (requires the devtools package):\ndevtools::install()\nAfter applying your modifications to the code, use the following command to quickly test your changes without directly installing the package (requires the devtools dependency):\ndevtools::load_all()\nGAMBLR.open is a free open-source package, but the Master branch is protected. We welcome contributions (pull request, bug report, feature request, PR review) from all levels of users. All commits must be submitted via pull request on a branch. Please refer to the GitHub documentation for details on how to do pull request."
  }
]