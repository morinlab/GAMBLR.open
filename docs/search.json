[{"path":"https://morinlab.github.io/GAMBLR.open/articles/GAMBLR-open.html","id":"open-data-access-simplified","dir":"Articles","previous_headings":"","what":"Open data access, simplified!","title":"Why GAMBLR.open?","text":"GAMBLR.open designed make open-access genomic data mature B-cell lymphomas accessible easier analyze. Whether ’re researcher, data scientist, student, package provides seamless interface querying, retrieving, preprocessing genomic data, can focus analysis rather data wrangling. GAMBLR.open part larger family R tools analysis lymphoma genomic data (GAMBLRverse, ). GAMBLR began toolkit analysts participating Genomic Analysis Mature B-cell Lymphomas project, led Morin Lab BC Cancer Simon Fraser University.","code":"/$$$$$$     /$$$$$$    /$$      /$$   /$$$$$$$    /$$        .:::::::  /$$__  $$   /$$__  $$  | $$$    /$$$  | $$__  $$  | $$        .::    .:: | $$  \\__/  | $$  \\ $$  | $$$$  /$$$$  | $$  \\ $$  | $$        .::    .:: | $$ /$$$$  | $$$$$$$$  | $$ $$/$$ $$  | $$$$$$$   | $$   <-   .: .:: | $$|_  $$  | $$__  $$  | $$  $$$| $$  | $$__  $$  | $$        .::  .:: | $$  \\ $$  | $$  | $$  | $$\\  $ | $$  | $$  \\ $$  | $$        .::    .:: |  $$$$$$/  | $$  | $$  | $$ \\/  | $$  | $$$$$$$/  | $$$$$$$$  .::      .::  \\______/   |__/  |__/  |__/     |__/  |_______/   |________/  ~GENOMIC~~~~~~~~~~~~~OF~~~~~~~~~~~~~~~~~B-CELL~~~~~~~~~~~~~~~~~~IN~~~~~~  ~~~~~~~~~~~~ANALYSIS~~~~~~MATURE~~~~~~~~~~~~~~~~~~~LYMPHOMAS~~~~~~~~~~R~"},{"path":"https://morinlab.github.io/GAMBLR.open/articles/GAMBLR-open.html","id":"who-is-it-for","dir":"Articles","previous_headings":"","what":"Who Is It For?","title":"Why GAMBLR.open?","text":"GAMBLR.open primarily caters : researchers need rapid access standardized genomic datasets. data scientists bioinformaticians looking structured easily queryable cancer genomics data. students want explore real-world genomic data learning environment.","code":""},{"path":"https://morinlab.github.io/GAMBLR.open/articles/GAMBLR-open.html","id":"what-does-gamblr-open-offer","dir":"Articles","previous_headings":"","what":"What does GAMBLR.open offer?","title":"Why GAMBLR.open?","text":"advantages GAMBLR.open : Access preprocessed genomic data: retrieve genomic datasets without worrying complex file handling. Standardized data queries: easily search filter genomic data using consistent intuitive API. Integration GAMBLR ecosystem: work seamlessly broader GAMBLR suite packages design analytical workflows. Reproducibility transparency: leverage well-documented pipelines ensure consistent transparent data retrieval.","code":""},{"path":"https://morinlab.github.io/GAMBLR.open/articles/GAMBLR-open.html","id":"the-gamblr-open-family-includes","dir":"Articles","previous_headings":"","what":"The GAMBLR.open family includes:","title":"Why GAMBLR.open?","text":"GAMBLR.data - “storage unit” different types bundled data. GAMBLR.helpers - set low-level functions data operation. GAMBLR.utils - higher level set functions operate genomic data. GAMBLR.viz - set functions used mostly visualizations. GAMBLR.predict - collection machine learning algorithms functions pre-format inputs models. Contains classifiers Burkitt Follicular lymphomas originally published, well reproduced DLBCL classification groupings Chapuy et al, Lacy et al, Runge et al. GAMBLR.open - package. diagram illustrates simplified way dependency relationship different packages GAMBLR family:     dependencies installed automatically , just like R package. , please report issue appropriate GitHub repo.","code":"%%{     init : {         \"flowchart\" : { \"curve\" : \"monotoneX\" },         'themeVariables': {'fontSize': '24px'}     }  }%% flowchart LR   A(\"GAMBLR.data\") ==> B(\"GAMBLR.helpers\")   B ==> C(\"GAMBLR.utils\")   B ==> D(\"GAMBLR.predict\")   D ==> E(\"GAMBLR.open\")   C ==> F(\"GAMBLR.viz\")   F ==> E   classDef A,B font-size:18pt;   style E fill:#6aa84f,stroke:#333,stroke-width:4,font-size:20px"},{"path":"https://morinlab.github.io/GAMBLR.open/articles/GAMBLR-open.html","id":"community","dir":"Articles","previous_headings":"","what":"Community","title":"Why GAMBLR.open?","text":"Community discussions primarily happen issue submission GitHub.","code":""},{"path":"https://morinlab.github.io/GAMBLR.open/articles/feature_matrix.html","id":"tutorial-assemble-feature-matrix","dir":"Articles","previous_headings":"","what":"Tutorial: assemble feature matrix","title":"Summarizing mutation status as a feature matrix","text":"2023, Morin Lab developed classifier Follicular Lymphoma (FL) predictive histological transformation aggressive DLBCL. study published Blood (2023). binary feature matrix assembled machine learning model? quick tour show GAMBLR.data resources functionality GAMBLR.open can help generate matrix. tutorial explores obtain metadata samples, simple somatic mutations maf format, auto-magically transform binary matrix features. simplify tutorial, include small subset features (whole set used original paper), example able illustrate functionality highlight main steps process. previous tutorial, already explored function get_gambl_metadata(). use retreive metadata: can now see samples FL study cohort FL_Dreval. Let’s explore samples : illustration purposes, let’s take 10 samples FL study: 5 FL 5 DLBCL: subsetting worked can now proceed matrix assembly. now use metadata previous step assemble binary feature matrix. First, lets return data frame simple somatic mutations maf format store variable. Technically step strictly necessary, function used able retreive maf data provided, advocate good practice maf data stored designated variable. utilizing coding non-coding mutations, take advantage returning variants per sample (without necessarily restricting coding-variants). Wow, super easy blazing fast! even work?? Let’s confirm: can see outputs got somatic mutations requested samples maf contains coding non-coding variants. can now proceed next steps. feature matrix FL study contained coding mutation status selected genes denoted 1 mutation present 0 mutation. addition , mutation hotspots genes also taken account. complicate things , annotation hotspots performed differently depending specific gene mutational effect. Specifically, CREBBP missemse mutations considered hotspots occured KAT domain, outside . mutations FOXO1 considered hotspots AA change M1. GAMBLR.data provides one-stop shop achieve level details ---box simple convenient way, directly used get_coding_ssm_status function. function logical arguments include_hotspots separate regular mutations ones occurring hotspots, review_hotspots, handle specific cases described automated way. arguments TRUE default, need toggle separately, example specify explicitly just illustrate happen function call. keep example clean concise, also annotate mutation status selected genes. can see example one sample hotspot mutation CREBBP, SP59424 (annotated 1 column CREBBPHOTSPOT). Let’s sanity check annotation illustration purposes: mutation falls within KAT domain missense variant, indeed correct annotated hotspot. can check fall within KAT domain? easy GAMBLR.data! now generated matrix coding mutations SSM hotspots binary format ready proceed next step. FL study also annotated non-coding mutations selected aSHM targets features binary matrix. , necessarily means simple step provided GAMBLR.data. regions targeted aSHM available GAMBLR.data. Since always complemented new regions identified, latest comprehensive version always available referring {projection}_ashm_regions. However, use case perfect example demonstarate operate versioned iterations aSHM target list, list updated since time study published time publication version 0.2 used. can refer directly version number: perform simple modifications make experience better select regions illustrative purposes: Now can see whether mutations within regions: now calculated number mutations region sample. original study used pathology-specific values per region convert counts binary, use arbitrary cutoff 5 binarize counts. also convert rownames column easier us unite matrices single one later steps: now generated matrix non-coding mutations binary format ready unite matrices together. can now combine coding non-coding mutations single matrix: ’s ! Happy GAMBLing!","code":"# Load packages library(GAMBLR.open) library(tidyverse) metadata <- get_gambl_metadata() %>%     filter(         study == \"FL_Dreval\"     ) table(metadata$pathology) COMFL DLBCL    FL    21   209   213 # Only filter for the samples from FL study metadata <- metadata %>%     filter(pathology %in% c(\"FL\", \"DLBCL\")) %>%     group_by(pathology) %>%     arrange(sample_id) %>%     slice_tail(n = 5) %>%     ungroup  # How does our metadata looks like now? str(metadata) tibble [10 × 30] (S3: tbl_df/tbl/data.frame)  $ age_group           : chr [1:10] \"Other\" \"Other\" \"Other\" \"Other\" ...  $ bam_available       : logi [1:10] TRUE TRUE TRUE TRUE TRUE TRUE ...  $ cohort              : chr [1:10] \"DLBCL_ICGC\" \"DLBCL_ICGC\" \"DLBCL_ICGC\" \"DLBCL_ICGC\" ...  $ compression         : chr [1:10] \"cram\" \"cram\" \"cram\" \"cram\" ...  $ COO_consensus       : chr [1:10] \"ABC\" \"GCB\" NA \"ABC\" ...  $ DHITsig_consensus   : chr [1:10] \"DHITsigNeg\" \"DHITsigNeg\" \"NA\" \"DHITsigNeg\" ...  $ EBV_status_inf      : chr [1:10] NA NA NA NA ...  $ ffpe_or_frozen      : chr [1:10] \"frozen\" \"frozen\" \"frozen\" \"frozen\" ...  $ fl_grade            : chr [1:10] NA NA NA NA ...  $ genetic_subgroup    : chr [1:10] \"dFL\" \"dFL\" \"dFL\" \"dFL\" ...  $ genome_build        : chr [1:10] \"hs37d5\" \"hs37d5\" \"hs37d5\" \"hs37d5\" ...  $ hiv_status          : chr [1:10] NA NA NA NA ...  $ lymphgen            : chr [1:10] \"Other\" \"Other\" \"BN2\" \"MCD-COMP\" ...  $ lymphgen_cnv_noA53  : chr [1:10] \"Other\" \"Other\" \"BN2\" \"BN2/MCD\" ...  $ lymphgen_no_cnv     : chr [1:10] \"MCD\" \"Other\" \"BN2\" \"BN2/MCD\" ...  $ lymphgen_with_cnv   : chr [1:10] \"A53\" \"A53\" \"BN2\" \"BN2/MCD\" ...  $ lymphgen_wright     : chr [1:10] NA NA NA NA ...  $ molecular_BL        : chr [1:10] \"non-BL\" \"non-BL\" NA \"non-BL\" ...  $ normal_sample_id    : chr [1:10] \"SP59410\" \"SP59446\" \"SP59450\" \"SP59454\" ...  $ pairing_status      : chr [1:10] \"matched\" \"matched\" \"matched\" \"matched\" ...  $ pathology           : chr [1:10] \"DLBCL\" \"DLBCL\" \"DLBCL\" \"DLBCL\" ...  $ pathology_rank      : num [1:10] 19 19 19 19 19 15 15 15 15 15  $ patient_id          : chr [1:10] \"DO27833\" \"DO27851\" \"DO27853\" \"DO27855\" ...  $ reference_PMID      : num [1:10] 37084389 37084389 37084389 37084389 37084389 ...  $ sample_id           : chr [1:10] \"SP59412\" \"SP59448\" \"SP59452\" \"SP59456\" ...  $ seq_type            : chr [1:10] \"genome\" \"genome\" \"genome\" \"genome\" ...  $ sex                 : chr [1:10] \"M\" \"F\" \"M\" \"F\" ...  $ study               : chr [1:10] \"FL_Dreval\" \"FL_Dreval\" \"FL_Dreval\" \"FL_Dreval\" ...  $ time_point          : chr [1:10] \"A\" \"A\" \"A\" \"A\" ...  $ Tumor_Sample_Barcode: chr [1:10] \"SP59412\" \"SP59448\" \"SP59452\" \"SP59456\" ... # Obtain simple somatic mutations maf <- get_ssm_by_samples(     these_samples_metadata = metadata ) # How many samples are present in maf? length(unique(maf$Tumor_Sample_Barcode)) [1] 10 # Are all these samples the ones we are interested in and requested with metadata? sort(unique(maf$Tumor_Sample_Barcode)) == sort(metadata$Tumor_Sample_Barcode) [1] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE # What are the mutations in the maf? Are they just coding? table(maf$Variant_Classification) 3'Flank                  3'UTR                5'Flank                     29                     20                    127                  5'UTR        Frame_Shift_Del        Frame_Shift_Ins                     61                      7                      1                    IGR           In_Frame_Del                 Intron                     46                      2                   1502      Missense_Mutation      Nonsense_Mutation                    RNA                     78                      9                     15                 Silent          Splice_Region            Splice_Site                     29                      6                      8 Translation_Start_Site                      1 # Specify genes to annotate our_genes <- c(     \"CREBBP\", \"MYD88\", \"RRAGC\",     \"PIM1\", \"BCL2\", \"BCL6\" )  # Generate binary matrix coding_matrix <- get_coding_ssm_status(     gene_symbols = our_genes,     these_samples_metadata = metadata,     maf_data = maf,     include_hotspots = TRUE,     review_hotspots = TRUE )  coding_matrix sample_id PIM1 CREBBP RRAGC MYD88 BCL6 BCL2 CREBBPHOTSPOT MYD88HOTSPOT 1    SP59412    1      1     0     0    0    0             0            0 2    SP59448    0      0     0     0    0    0             0            0 3    SP59452    1      0     0     1    1    0             0            0 4    SP59456    0      0     0     0    0    0             0            0 5    SP59460    0      0     0     0    1    1             0            1 6    SP59420    0      1     0     0    0    0             0            0 7    SP59424    0      0     0     0    0    0             1            0 8    SP59432    0      0     1     0    0    0             0            0 9    SP59436    0      1     0     0    0    0             0            0 10   SP59464    0      0     1     0    0    0             0            0 crebbp_hotspot_mutation <- maf %>%     filter(         Tumor_Sample_Barcode == \"SP59424\",         Hugo_Symbol == \"CREBBP\"     ) %>%     select(Chromosome, Start_Position, Variant_Classification)  crebbp_hotspot_mutation genomic_data Object Genome Build: grch37 Showing first 10 rows:   Chromosome Start_Position Variant_Classification 1         16        3788650      Missense_Mutation # GAMBLR.data has the regions to be considered as hotspots hotspot_regions_grch37 chrom     start       end CREBBP            16   3785000   3791000 EZH2               7 148508764 148506238 NOTCH1             9 139391455 139391455 NOTCH2             1 120459150 120459150 CD79B_trunc       17  62007172  62007172 CD79B_NONtrunc    17  62006800  62006800 # Now check that CREBBP mutations between(     crebbp_hotspot_mutation$Start_Position,     hotspot_regions_grch37[\"CREBBP\", \"start\"],     hotspot_regions_grch37[\"CREBBP\", \"end\"] ) [1] TRUE regions_bed <- somatic_hypermutation_locations_GRCh37_v0.2  head(regions_bed) chr_name hg19_start  hg19_end    gene     region regulatory_comment 1     chr2   96808901  96811913   DUSP2   intron-1           enhancer 2    chr17   56407732  56410140 TSPOAP1 intergenic           enhancer 3    chr11  128339774 128345731    ETS1    introns           enhancer 4    chr11  128388492 128394163    ETS1      TSS-2    active_promoter 5     chr6   31548325  31550717     LTB   intron-1           enhancer 6     chr3   32020518  32024930 OSBPL10      TSS-1    active_promoter our_regions <- c(     \"BCL6-TSS\",     \"BCL7A-TSS\",     \"RHOH-TSS\",     \"ZFP36L1-TSS\" )  regions_bed <- create_bed_data(     regions_bed,     fix_names = \"concat\",     concat_cols = c(\"gene\",\"region\"),     sep = \"-\",     genome_build = \"grch37\" )  regions_bed <- regions_bed %>%     filter(name %in% our_regions)  regions_bed genomic_data Object Genome Build: grch37 Showing first 10 rows:   chrom     start       end        name region regulatory_comment 1     3 187458526 187464632    BCL6-TSS    TSS               <NA> 2    12 122456912 122464036   BCL7A-TSS    TSS    poised_promoter 3    14  69257848  69259739 ZFP36L1-TSS    TSS    active_promoter 4     4  40193105  40204231    RHOH-TSS    TSS    active_promoter ashm_matrix <- cool_overlaps(     maf,     regions_bed,     columns2 = c(\"chrom\", \"start\", \"end\") ) %>%     group_by(Tumor_Sample_Barcode, name) %>%     summarize(n = n()) %>%     pivot_wider(         id_cols = Tumor_Sample_Barcode,         names_from = name,         values_from = n,         values_fill = 0     ) %>%     column_to_rownames(\"Tumor_Sample_Barcode\") ashm_matrix BCL6-TSS ZFP36L1-TSS BCL7A-TSS RHOH-TSS SP59412        4           1         0        0 SP59420        1           0         1        0 SP59424        0           0         0        1 SP59436        1           0         0        0 SP59448        6           4        14        3 SP59452       18           2        12       28 SP59456        2           6         0        9 SP59460        1           1         1        2 SP59464        1           0         0        0 ashm_matrix[ashm_matrix <= 5] = 0 ashm_matrix[ashm_matrix > 5] = 1 ashm_matrix <- ashm_matrix %>%     rownames_to_column(\"sample_id\")  ashm_matrix sample_id BCL6-TSS ZFP36L1-TSS BCL7A-TSS RHOH-TSS 1   SP59412        0           0         0        0 2   SP59420        0           0         0        0 3   SP59424        0           0         0        0 4   SP59436        0           0         0        0 5   SP59448        1           0         1        0 6   SP59452        1           0         1        1 7   SP59456        0           1         0        1 8   SP59460        0           0         0        0 9   SP59464        0           0         0        0 feature_matrix <- left_join(     coding_matrix,     ashm_matrix ) %>%     mutate(         across(             where(is.numeric), ~ replace_na(.x, 0)         )     )  feature_matrix sample_id PIM1 CREBBP RRAGC MYD88 BCL6 BCL2 CREBBPHOTSPOT MYD88HOTSPOT 1    SP59412    1      1     0     0    0    0             0            0 2    SP59448    0      0     0     0    0    0             0            0 3    SP59452    1      0     0     1    1    0             0            0 4    SP59456    0      0     0     0    0    0             0            0 5    SP59460    0      0     0     0    1    1             0            1 6    SP59420    0      1     0     0    0    0             0            0 7    SP59424    0      0     0     0    0    0             1            0 8    SP59432    0      0     1     0    0    0             0            0 9    SP59436    0      1     0     0    0    0             0            0 10   SP59464    0      0     1     0    0    0             0            0    BCL6-TSS ZFP36L1-TSS BCL7A-TSS RHOH-TSS 1         0           0         0        0 2         1           0         1        0 3         1           0         1        1 4         0           1         0        1 5         0           0         0        0 6         0           0         0        0 7         0           0         0        0 8         0           0         0        0 9         0           0         0        0 10        0           0         0        0 /$$$$$$     /$$$$$$    /$$      /$$   /$$$$$$$    /$$        .:::::::  /$$__  $$   /$$__  $$  | $$$    /$$$  | $$__  $$  | $$        .::    .:: | $$  \\__/  | $$  \\ $$  | $$$$  /$$$$  | $$  \\ $$  | $$        .::    .:: | $$ /$$$$  | $$$$$$$$  | $$ $$/$$ $$  | $$$$$$$   | $$   <-   .: .:: | $$|_  $$  | $$__  $$  | $$  $$$| $$  | $$__  $$  | $$        .::  .:: | $$  \\ $$  | $$  | $$  | $$\\  $ | $$  | $$  \\ $$  | $$        .::    .:: |  $$$$$$/  | $$  | $$  | $$ \\/  | $$  | $$$$$$$/  | $$$$$$$$  .::      .::  \\______/   |__/  |__/  |__/     |__/  |_______/   |________/  ~GENOMIC~~~~~~~~~~~~~OF~~~~~~~~~~~~~~~~~B-CELL~~~~~~~~~~~~~~~~~~IN~~~~~~  ~~~~~~~~~~~~ANALYSIS~~~~~~MATURE~~~~~~~~~~~~~~~~~~~LYMPHOMAS~~~~~~~~~~R~"},{"path":"https://morinlab.github.io/GAMBLR.open/articles/feature_matrix.html","id":"obtain-metadata","dir":"Articles","previous_headings":"","what":"Obtain metadata","title":"Summarizing mutation status as a feature matrix","text":"previous tutorial, already explored function get_gambl_metadata(). use retreive metadata: can now see samples FL study cohort FL_Dreval. Let’s explore samples : illustration purposes, let’s take 10 samples FL study: 5 FL 5 DLBCL: subsetting worked can now proceed matrix assembly.","code":"metadata <- get_gambl_metadata() %>%     filter(         study == \"FL_Dreval\"     ) table(metadata$pathology) COMFL DLBCL    FL    21   209   213 # Only filter for the samples from FL study metadata <- metadata %>%     filter(pathology %in% c(\"FL\", \"DLBCL\")) %>%     group_by(pathology) %>%     arrange(sample_id) %>%     slice_tail(n = 5) %>%     ungroup  # How does our metadata looks like now? str(metadata) tibble [10 × 30] (S3: tbl_df/tbl/data.frame)  $ age_group           : chr [1:10] \"Other\" \"Other\" \"Other\" \"Other\" ...  $ bam_available       : logi [1:10] TRUE TRUE TRUE TRUE TRUE TRUE ...  $ cohort              : chr [1:10] \"DLBCL_ICGC\" \"DLBCL_ICGC\" \"DLBCL_ICGC\" \"DLBCL_ICGC\" ...  $ compression         : chr [1:10] \"cram\" \"cram\" \"cram\" \"cram\" ...  $ COO_consensus       : chr [1:10] \"ABC\" \"GCB\" NA \"ABC\" ...  $ DHITsig_consensus   : chr [1:10] \"DHITsigNeg\" \"DHITsigNeg\" \"NA\" \"DHITsigNeg\" ...  $ EBV_status_inf      : chr [1:10] NA NA NA NA ...  $ ffpe_or_frozen      : chr [1:10] \"frozen\" \"frozen\" \"frozen\" \"frozen\" ...  $ fl_grade            : chr [1:10] NA NA NA NA ...  $ genetic_subgroup    : chr [1:10] \"dFL\" \"dFL\" \"dFL\" \"dFL\" ...  $ genome_build        : chr [1:10] \"hs37d5\" \"hs37d5\" \"hs37d5\" \"hs37d5\" ...  $ hiv_status          : chr [1:10] NA NA NA NA ...  $ lymphgen            : chr [1:10] \"Other\" \"Other\" \"BN2\" \"MCD-COMP\" ...  $ lymphgen_cnv_noA53  : chr [1:10] \"Other\" \"Other\" \"BN2\" \"BN2/MCD\" ...  $ lymphgen_no_cnv     : chr [1:10] \"MCD\" \"Other\" \"BN2\" \"BN2/MCD\" ...  $ lymphgen_with_cnv   : chr [1:10] \"A53\" \"A53\" \"BN2\" \"BN2/MCD\" ...  $ lymphgen_wright     : chr [1:10] NA NA NA NA ...  $ molecular_BL        : chr [1:10] \"non-BL\" \"non-BL\" NA \"non-BL\" ...  $ normal_sample_id    : chr [1:10] \"SP59410\" \"SP59446\" \"SP59450\" \"SP59454\" ...  $ pairing_status      : chr [1:10] \"matched\" \"matched\" \"matched\" \"matched\" ...  $ pathology           : chr [1:10] \"DLBCL\" \"DLBCL\" \"DLBCL\" \"DLBCL\" ...  $ pathology_rank      : num [1:10] 19 19 19 19 19 15 15 15 15 15  $ patient_id          : chr [1:10] \"DO27833\" \"DO27851\" \"DO27853\" \"DO27855\" ...  $ reference_PMID      : num [1:10] 37084389 37084389 37084389 37084389 37084389 ...  $ sample_id           : chr [1:10] \"SP59412\" \"SP59448\" \"SP59452\" \"SP59456\" ...  $ seq_type            : chr [1:10] \"genome\" \"genome\" \"genome\" \"genome\" ...  $ sex                 : chr [1:10] \"M\" \"F\" \"M\" \"F\" ...  $ study               : chr [1:10] \"FL_Dreval\" \"FL_Dreval\" \"FL_Dreval\" \"FL_Dreval\" ...  $ time_point          : chr [1:10] \"A\" \"A\" \"A\" \"A\" ...  $ Tumor_Sample_Barcode: chr [1:10] \"SP59412\" \"SP59448\" \"SP59452\" \"SP59456\" ..."},{"path":"https://morinlab.github.io/GAMBLR.open/articles/feature_matrix.html","id":"generate-feature-matrix","dir":"Articles","previous_headings":"","what":"Generate feature matrix","title":"Summarizing mutation status as a feature matrix","text":"now use metadata previous step assemble binary feature matrix. First, lets return data frame simple somatic mutations maf format store variable. Technically step strictly necessary, function used able retreive maf data provided, advocate good practice maf data stored designated variable. utilizing coding non-coding mutations, take advantage returning variants per sample (without necessarily restricting coding-variants). Wow, super easy blazing fast! even work?? Let’s confirm: can see outputs got somatic mutations requested samples maf contains coding non-coding variants. can now proceed next steps. feature matrix FL study contained coding mutation status selected genes denoted 1 mutation present 0 mutation. addition , mutation hotspots genes also taken account. complicate things , annotation hotspots performed differently depending specific gene mutational effect. Specifically, CREBBP missemse mutations considered hotspots occured KAT domain, outside . mutations FOXO1 considered hotspots AA change M1. GAMBLR.data provides one-stop shop achieve level details ---box simple convenient way, directly used get_coding_ssm_status function. function logical arguments include_hotspots separate regular mutations ones occurring hotspots, review_hotspots, handle specific cases described automated way. arguments TRUE default, need toggle separately, example specify explicitly just illustrate happen function call. keep example clean concise, also annotate mutation status selected genes. can see example one sample hotspot mutation CREBBP, SP59424 (annotated 1 column CREBBPHOTSPOT). Let’s sanity check annotation illustration purposes: mutation falls within KAT domain missense variant, indeed correct annotated hotspot. can check fall within KAT domain? easy GAMBLR.data! now generated matrix coding mutations SSM hotspots binary format ready proceed next step. FL study also annotated non-coding mutations selected aSHM targets features binary matrix. , necessarily means simple step provided GAMBLR.data. regions targeted aSHM available GAMBLR.data. Since always complemented new regions identified, latest comprehensive version always available referring {projection}_ashm_regions. However, use case perfect example demonstarate operate versioned iterations aSHM target list, list updated since time study published time publication version 0.2 used. can refer directly version number: perform simple modifications make experience better select regions illustrative purposes: Now can see whether mutations within regions: now calculated number mutations region sample. original study used pathology-specific values per region convert counts binary, use arbitrary cutoff 5 binarize counts. also convert rownames column easier us unite matrices single one later steps: now generated matrix non-coding mutations binary format ready unite matrices together. can now combine coding non-coding mutations single matrix: ’s ! Happy GAMBLing!","code":"# Obtain simple somatic mutations maf <- get_ssm_by_samples(     these_samples_metadata = metadata ) # How many samples are present in maf? length(unique(maf$Tumor_Sample_Barcode)) [1] 10 # Are all these samples the ones we are interested in and requested with metadata? sort(unique(maf$Tumor_Sample_Barcode)) == sort(metadata$Tumor_Sample_Barcode) [1] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE # What are the mutations in the maf? Are they just coding? table(maf$Variant_Classification) 3'Flank                  3'UTR                5'Flank                     29                     20                    127                  5'UTR        Frame_Shift_Del        Frame_Shift_Ins                     61                      7                      1                    IGR           In_Frame_Del                 Intron                     46                      2                   1502      Missense_Mutation      Nonsense_Mutation                    RNA                     78                      9                     15                 Silent          Splice_Region            Splice_Site                     29                      6                      8 Translation_Start_Site                      1 # Specify genes to annotate our_genes <- c(     \"CREBBP\", \"MYD88\", \"RRAGC\",     \"PIM1\", \"BCL2\", \"BCL6\" )  # Generate binary matrix coding_matrix <- get_coding_ssm_status(     gene_symbols = our_genes,     these_samples_metadata = metadata,     maf_data = maf,     include_hotspots = TRUE,     review_hotspots = TRUE )  coding_matrix sample_id PIM1 CREBBP RRAGC MYD88 BCL6 BCL2 CREBBPHOTSPOT MYD88HOTSPOT 1    SP59412    1      1     0     0    0    0             0            0 2    SP59448    0      0     0     0    0    0             0            0 3    SP59452    1      0     0     1    1    0             0            0 4    SP59456    0      0     0     0    0    0             0            0 5    SP59460    0      0     0     0    1    1             0            1 6    SP59420    0      1     0     0    0    0             0            0 7    SP59424    0      0     0     0    0    0             1            0 8    SP59432    0      0     1     0    0    0             0            0 9    SP59436    0      1     0     0    0    0             0            0 10   SP59464    0      0     1     0    0    0             0            0 crebbp_hotspot_mutation <- maf %>%     filter(         Tumor_Sample_Barcode == \"SP59424\",         Hugo_Symbol == \"CREBBP\"     ) %>%     select(Chromosome, Start_Position, Variant_Classification)  crebbp_hotspot_mutation genomic_data Object Genome Build: grch37 Showing first 10 rows:   Chromosome Start_Position Variant_Classification 1         16        3788650      Missense_Mutation # GAMBLR.data has the regions to be considered as hotspots hotspot_regions_grch37 chrom     start       end CREBBP            16   3785000   3791000 EZH2               7 148508764 148506238 NOTCH1             9 139391455 139391455 NOTCH2             1 120459150 120459150 CD79B_trunc       17  62007172  62007172 CD79B_NONtrunc    17  62006800  62006800 # Now check that CREBBP mutations between(     crebbp_hotspot_mutation$Start_Position,     hotspot_regions_grch37[\"CREBBP\", \"start\"],     hotspot_regions_grch37[\"CREBBP\", \"end\"] ) [1] TRUE regions_bed <- somatic_hypermutation_locations_GRCh37_v0.2  head(regions_bed) chr_name hg19_start  hg19_end    gene     region regulatory_comment 1     chr2   96808901  96811913   DUSP2   intron-1           enhancer 2    chr17   56407732  56410140 TSPOAP1 intergenic           enhancer 3    chr11  128339774 128345731    ETS1    introns           enhancer 4    chr11  128388492 128394163    ETS1      TSS-2    active_promoter 5     chr6   31548325  31550717     LTB   intron-1           enhancer 6     chr3   32020518  32024930 OSBPL10      TSS-1    active_promoter our_regions <- c(     \"BCL6-TSS\",     \"BCL7A-TSS\",     \"RHOH-TSS\",     \"ZFP36L1-TSS\" )  regions_bed <- create_bed_data(     regions_bed,     fix_names = \"concat\",     concat_cols = c(\"gene\",\"region\"),     sep = \"-\",     genome_build = \"grch37\" )  regions_bed <- regions_bed %>%     filter(name %in% our_regions)  regions_bed genomic_data Object Genome Build: grch37 Showing first 10 rows:   chrom     start       end        name region regulatory_comment 1     3 187458526 187464632    BCL6-TSS    TSS               <NA> 2    12 122456912 122464036   BCL7A-TSS    TSS    poised_promoter 3    14  69257848  69259739 ZFP36L1-TSS    TSS    active_promoter 4     4  40193105  40204231    RHOH-TSS    TSS    active_promoter ashm_matrix <- cool_overlaps(     maf,     regions_bed,     columns2 = c(\"chrom\", \"start\", \"end\") ) %>%     group_by(Tumor_Sample_Barcode, name) %>%     summarize(n = n()) %>%     pivot_wider(         id_cols = Tumor_Sample_Barcode,         names_from = name,         values_from = n,         values_fill = 0     ) %>%     column_to_rownames(\"Tumor_Sample_Barcode\") ashm_matrix BCL6-TSS ZFP36L1-TSS BCL7A-TSS RHOH-TSS SP59412        4           1         0        0 SP59420        1           0         1        0 SP59424        0           0         0        1 SP59436        1           0         0        0 SP59448        6           4        14        3 SP59452       18           2        12       28 SP59456        2           6         0        9 SP59460        1           1         1        2 SP59464        1           0         0        0 ashm_matrix[ashm_matrix <= 5] = 0 ashm_matrix[ashm_matrix > 5] = 1 ashm_matrix <- ashm_matrix %>%     rownames_to_column(\"sample_id\")  ashm_matrix sample_id BCL6-TSS ZFP36L1-TSS BCL7A-TSS RHOH-TSS 1   SP59412        0           0         0        0 2   SP59420        0           0         0        0 3   SP59424        0           0         0        0 4   SP59436        0           0         0        0 5   SP59448        1           0         1        0 6   SP59452        1           0         1        1 7   SP59456        0           1         0        1 8   SP59460        0           0         0        0 9   SP59464        0           0         0        0 feature_matrix <- left_join(     coding_matrix,     ashm_matrix ) %>%     mutate(         across(             where(is.numeric), ~ replace_na(.x, 0)         )     )  feature_matrix sample_id PIM1 CREBBP RRAGC MYD88 BCL6 BCL2 CREBBPHOTSPOT MYD88HOTSPOT 1    SP59412    1      1     0     0    0    0             0            0 2    SP59448    0      0     0     0    0    0             0            0 3    SP59452    1      0     0     1    1    0             0            0 4    SP59456    0      0     0     0    0    0             0            0 5    SP59460    0      0     0     0    1    1             0            1 6    SP59420    0      1     0     0    0    0             0            0 7    SP59424    0      0     0     0    0    0             1            0 8    SP59432    0      0     1     0    0    0             0            0 9    SP59436    0      1     0     0    0    0             0            0 10   SP59464    0      0     1     0    0    0             0            0    BCL6-TSS ZFP36L1-TSS BCL7A-TSS RHOH-TSS 1         0           0         0        0 2         1           0         1        0 3         1           0         1        1 4         0           1         0        1 5         0           0         0        0 6         0           0         0        0 7         0           0         0        0 8         0           0         0        0 9         0           0         0        0 10        0           0         0        0 /$$$$$$     /$$$$$$    /$$      /$$   /$$$$$$$    /$$        .:::::::  /$$__  $$   /$$__  $$  | $$$    /$$$  | $$__  $$  | $$        .::    .:: | $$  \\__/  | $$  \\ $$  | $$$$  /$$$$  | $$  \\ $$  | $$        .::    .:: | $$ /$$$$  | $$$$$$$$  | $$ $$/$$ $$  | $$$$$$$   | $$   <-   .: .:: | $$|_  $$  | $$__  $$  | $$  $$$| $$  | $$__  $$  | $$        .::  .:: | $$  \\ $$  | $$  | $$  | $$\\  $ | $$  | $$  \\ $$  | $$        .::    .:: |  $$$$$$/  | $$  | $$  | $$ \\/  | $$  | $$$$$$$/  | $$$$$$$$  .::      .::  \\______/   |__/  |__/  |__/     |__/  |_______/   |________/  ~GENOMIC~~~~~~~~~~~~~OF~~~~~~~~~~~~~~~~~B-CELL~~~~~~~~~~~~~~~~~~IN~~~~~~  ~~~~~~~~~~~~ANALYSIS~~~~~~MATURE~~~~~~~~~~~~~~~~~~~LYMPHOMAS~~~~~~~~~~R~"},{"path":"https://morinlab.github.io/GAMBLR.open/articles/feature_matrix.html","id":"return-the-simple-somatic-mutations","dir":"Articles","previous_headings":"Tutorial: assemble feature matrix","what":"Return the simple somatic mutations","title":"Summarizing mutation status as a feature matrix","text":"First, lets return data frame simple somatic mutations maf format store variable. Technically step strictly necessary, function used able retreive maf data provided, advocate good practice maf data stored designated variable. utilizing coding non-coding mutations, take advantage returning variants per sample (without necessarily restricting coding-variants). Wow, super easy blazing fast! even work?? Let’s confirm: can see outputs got somatic mutations requested samples maf contains coding non-coding variants. can now proceed next steps.","code":"# Obtain simple somatic mutations maf <- get_ssm_by_samples(     these_samples_metadata = metadata ) # How many samples are present in maf? length(unique(maf$Tumor_Sample_Barcode)) [1] 10 # Are all these samples the ones we are interested in and requested with metadata? sort(unique(maf$Tumor_Sample_Barcode)) == sort(metadata$Tumor_Sample_Barcode) [1] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE # What are the mutations in the maf? Are they just coding? table(maf$Variant_Classification) 3'Flank                  3'UTR                5'Flank                     29                     20                    127                  5'UTR        Frame_Shift_Del        Frame_Shift_Ins                     61                      7                      1                    IGR           In_Frame_Del                 Intron                     46                      2                   1502      Missense_Mutation      Nonsense_Mutation                    RNA                     78                      9                     15                 Silent          Splice_Region            Splice_Site                     29                      6                      8 Translation_Start_Site                      1"},{"path":"https://morinlab.github.io/GAMBLR.open/articles/feature_matrix.html","id":"coding-mutations-as-features","dir":"Articles","previous_headings":"Tutorial: assemble feature matrix","what":"Coding mutations as features","title":"Summarizing mutation status as a feature matrix","text":"feature matrix FL study contained coding mutation status selected genes denoted 1 mutation present 0 mutation. addition , mutation hotspots genes also taken account. complicate things , annotation hotspots performed differently depending specific gene mutational effect. Specifically, CREBBP missemse mutations considered hotspots occured KAT domain, outside . mutations FOXO1 considered hotspots AA change M1. GAMBLR.data provides one-stop shop achieve level details ---box simple convenient way, directly used get_coding_ssm_status function. function logical arguments include_hotspots separate regular mutations ones occurring hotspots, review_hotspots, handle specific cases described automated way. arguments TRUE default, need toggle separately, example specify explicitly just illustrate happen function call. keep example clean concise, also annotate mutation status selected genes. can see example one sample hotspot mutation CREBBP, SP59424 (annotated 1 column CREBBPHOTSPOT). Let’s sanity check annotation illustration purposes: mutation falls within KAT domain missense variant, indeed correct annotated hotspot. can check fall within KAT domain? easy GAMBLR.data! now generated matrix coding mutations SSM hotspots binary format ready proceed next step.","code":"# Specify genes to annotate our_genes <- c(     \"CREBBP\", \"MYD88\", \"RRAGC\",     \"PIM1\", \"BCL2\", \"BCL6\" )  # Generate binary matrix coding_matrix <- get_coding_ssm_status(     gene_symbols = our_genes,     these_samples_metadata = metadata,     maf_data = maf,     include_hotspots = TRUE,     review_hotspots = TRUE )  coding_matrix sample_id PIM1 CREBBP RRAGC MYD88 BCL6 BCL2 CREBBPHOTSPOT MYD88HOTSPOT 1    SP59412    1      1     0     0    0    0             0            0 2    SP59448    0      0     0     0    0    0             0            0 3    SP59452    1      0     0     1    1    0             0            0 4    SP59456    0      0     0     0    0    0             0            0 5    SP59460    0      0     0     0    1    1             0            1 6    SP59420    0      1     0     0    0    0             0            0 7    SP59424    0      0     0     0    0    0             1            0 8    SP59432    0      0     1     0    0    0             0            0 9    SP59436    0      1     0     0    0    0             0            0 10   SP59464    0      0     1     0    0    0             0            0 crebbp_hotspot_mutation <- maf %>%     filter(         Tumor_Sample_Barcode == \"SP59424\",         Hugo_Symbol == \"CREBBP\"     ) %>%     select(Chromosome, Start_Position, Variant_Classification)  crebbp_hotspot_mutation genomic_data Object Genome Build: grch37 Showing first 10 rows:   Chromosome Start_Position Variant_Classification 1         16        3788650      Missense_Mutation # GAMBLR.data has the regions to be considered as hotspots hotspot_regions_grch37 chrom     start       end CREBBP            16   3785000   3791000 EZH2               7 148508764 148506238 NOTCH1             9 139391455 139391455 NOTCH2             1 120459150 120459150 CD79B_trunc       17  62007172  62007172 CD79B_NONtrunc    17  62006800  62006800 # Now check that CREBBP mutations between(     crebbp_hotspot_mutation$Start_Position,     hotspot_regions_grch37[\"CREBBP\", \"start\"],     hotspot_regions_grch37[\"CREBBP\", \"end\"] ) [1] TRUE"},{"path":"https://morinlab.github.io/GAMBLR.open/articles/feature_matrix.html","id":"ashm-mutations-as-features","dir":"Articles","previous_headings":"Tutorial: assemble feature matrix","what":"aSHM mutations as features","title":"Summarizing mutation status as a feature matrix","text":"FL study also annotated non-coding mutations selected aSHM targets features binary matrix. , necessarily means simple step provided GAMBLR.data. regions targeted aSHM available GAMBLR.data. Since always complemented new regions identified, latest comprehensive version always available referring {projection}_ashm_regions. However, use case perfect example demonstarate operate versioned iterations aSHM target list, list updated since time study published time publication version 0.2 used. can refer directly version number: perform simple modifications make experience better select regions illustrative purposes: Now can see whether mutations within regions: now calculated number mutations region sample. original study used pathology-specific values per region convert counts binary, use arbitrary cutoff 5 binarize counts. also convert rownames column easier us unite matrices single one later steps: now generated matrix non-coding mutations binary format ready unite matrices together.","code":"regions_bed <- somatic_hypermutation_locations_GRCh37_v0.2  head(regions_bed) chr_name hg19_start  hg19_end    gene     region regulatory_comment 1     chr2   96808901  96811913   DUSP2   intron-1           enhancer 2    chr17   56407732  56410140 TSPOAP1 intergenic           enhancer 3    chr11  128339774 128345731    ETS1    introns           enhancer 4    chr11  128388492 128394163    ETS1      TSS-2    active_promoter 5     chr6   31548325  31550717     LTB   intron-1           enhancer 6     chr3   32020518  32024930 OSBPL10      TSS-1    active_promoter our_regions <- c(     \"BCL6-TSS\",     \"BCL7A-TSS\",     \"RHOH-TSS\",     \"ZFP36L1-TSS\" )  regions_bed <- create_bed_data(     regions_bed,     fix_names = \"concat\",     concat_cols = c(\"gene\",\"region\"),     sep = \"-\",     genome_build = \"grch37\" )  regions_bed <- regions_bed %>%     filter(name %in% our_regions)  regions_bed genomic_data Object Genome Build: grch37 Showing first 10 rows:   chrom     start       end        name region regulatory_comment 1     3 187458526 187464632    BCL6-TSS    TSS               <NA> 2    12 122456912 122464036   BCL7A-TSS    TSS    poised_promoter 3    14  69257848  69259739 ZFP36L1-TSS    TSS    active_promoter 4     4  40193105  40204231    RHOH-TSS    TSS    active_promoter ashm_matrix <- cool_overlaps(     maf,     regions_bed,     columns2 = c(\"chrom\", \"start\", \"end\") ) %>%     group_by(Tumor_Sample_Barcode, name) %>%     summarize(n = n()) %>%     pivot_wider(         id_cols = Tumor_Sample_Barcode,         names_from = name,         values_from = n,         values_fill = 0     ) %>%     column_to_rownames(\"Tumor_Sample_Barcode\") ashm_matrix BCL6-TSS ZFP36L1-TSS BCL7A-TSS RHOH-TSS SP59412        4           1         0        0 SP59420        1           0         1        0 SP59424        0           0         0        1 SP59436        1           0         0        0 SP59448        6           4        14        3 SP59452       18           2        12       28 SP59456        2           6         0        9 SP59460        1           1         1        2 SP59464        1           0         0        0 ashm_matrix[ashm_matrix <= 5] = 0 ashm_matrix[ashm_matrix > 5] = 1 ashm_matrix <- ashm_matrix %>%     rownames_to_column(\"sample_id\")  ashm_matrix sample_id BCL6-TSS ZFP36L1-TSS BCL7A-TSS RHOH-TSS 1   SP59412        0           0         0        0 2   SP59420        0           0         0        0 3   SP59424        0           0         0        0 4   SP59436        0           0         0        0 5   SP59448        1           0         1        0 6   SP59452        1           0         1        1 7   SP59456        0           1         0        1 8   SP59460        0           0         0        0 9   SP59464        0           0         0        0"},{"path":"https://morinlab.github.io/GAMBLR.open/articles/feature_matrix.html","id":"unite-into-full-feature-matrix","dir":"Articles","previous_headings":"Tutorial: assemble feature matrix","what":"Unite into full feature matrix","title":"Summarizing mutation status as a feature matrix","text":"can now combine coding non-coding mutations single matrix: ’s ! Happy GAMBLing!","code":"feature_matrix <- left_join(     coding_matrix,     ashm_matrix ) %>%     mutate(         across(             where(is.numeric), ~ replace_na(.x, 0)         )     )  feature_matrix sample_id PIM1 CREBBP RRAGC MYD88 BCL6 BCL2 CREBBPHOTSPOT MYD88HOTSPOT 1    SP59412    1      1     0     0    0    0             0            0 2    SP59448    0      0     0     0    0    0             0            0 3    SP59452    1      0     0     1    1    0             0            0 4    SP59456    0      0     0     0    0    0             0            0 5    SP59460    0      0     0     0    1    1             0            1 6    SP59420    0      1     0     0    0    0             0            0 7    SP59424    0      0     0     0    0    0             1            0 8    SP59432    0      0     1     0    0    0             0            0 9    SP59436    0      1     0     0    0    0             0            0 10   SP59464    0      0     1     0    0    0             0            0    BCL6-TSS ZFP36L1-TSS BCL7A-TSS RHOH-TSS 1         0           0         0        0 2         1           0         1        0 3         1           0         1        1 4         0           1         0        1 5         0           0         0        0 6         0           0         0        0 7         0           0         0        0 8         0           0         0        0 9         0           0         0        0 10        0           0         0        0 /$$$$$$     /$$$$$$    /$$      /$$   /$$$$$$$    /$$        .:::::::  /$$__  $$   /$$__  $$  | $$$    /$$$  | $$__  $$  | $$        .::    .:: | $$  \\__/  | $$  \\ $$  | $$$$  /$$$$  | $$  \\ $$  | $$        .::    .:: | $$ /$$$$  | $$$$$$$$  | $$ $$/$$ $$  | $$$$$$$   | $$   <-   .: .:: | $$|_  $$  | $$__  $$  | $$  $$$| $$  | $$__  $$  | $$        .::  .:: | $$  \\ $$  | $$  | $$  | $$\\  $ | $$  | $$  \\ $$  | $$        .::    .:: |  $$$$$$/  | $$  | $$  | $$ \\/  | $$  | $$$$$$$/  | $$$$$$$$  .::      .::  \\______/   |__/  |__/  |__/     |__/  |_______/   |________/  ~GENOMIC~~~~~~~~~~~~~OF~~~~~~~~~~~~~~~~~B-CELL~~~~~~~~~~~~~~~~~~IN~~~~~~  ~~~~~~~~~~~~ANALYSIS~~~~~~MATURE~~~~~~~~~~~~~~~~~~~LYMPHOMAS~~~~~~~~~~R~"},{"path":"https://morinlab.github.io/GAMBLR.open/articles/genetic_classification.html","id":"load-packages-and-data","dir":"Articles","previous_headings":"","what":"Load packages and data","title":"Genetic classification of tumours","text":"First, load required packages. GAMBLR.open tidyverse needed - load required functionality. Next, obtain data. need metadata, SSM maf format, CNV seg format, SV bedped format. demonstration purposes, use data bundled GAMBLR show classification functionality. , subset data small number samples illustrate required formatting minimal required information. metadata data frame contains column sample_id listing sample ids tumours classified, column pathology dictate sliding threshold aSHM site annotation necessary. column seq_type required classification purposes, kept tutorial purpose subsequent retreival mutation data. key data provided genetic subgroup classification SSM maf format. small subset columns required used input information, demonstrate expected format minimal required information SSM. Several classifiers (Chapuy et al, Lacy et al, Runge et al) require CNV information provided, demonstrate expected format minimal required information CNV standard seg format. Several classifiers require SV data provided, demonstrate expected format minimal required information SV standard bed format. Note column manta_name can column tool choice generated bedpe output reports unique id SV event, expected unique SV event.","code":"# Load packages library(GAMBLR.open) library(tidyverse) # Load metadata metadata <- get_gambl_metadata() %>%     filter(seq_type == \"genome\") %>%     filter(pathology %in% c(\"FL\", \"DLBCL\", \"BL\")) %>%     group_by(sample_id) %>%     slice_head() %>%     ungroup %>%     filter(!study %in% c(\"DLBCL_Arthur\", \"DLBCL_Thomas\"))  metadata %>%     count(pathology) # Demonstrate the required columns in metadata metadata <- metadata %>%     select(sample_id, pathology, seq_type)   head(metadata) maf <- get_ssm_by_samples(     these_samples_metadata = metadata ) %>% as.data.frame  # Only these columns are required maf_columns <- c(     \"Hugo_Symbol\", \"NCBI_Build\",     \"Chromosome\", \"Start_Position\", \"End_Position\",     \"Variant_Classification\", \"HGVSp_Short\",     \"Tumor_Sample_Barcode\" )  maf <- maf %>%     select(all_of(maf_columns))  head(maf) seg <- get_cn_segments(     these_samples_metadata = metadata ) %>% as.data.frame  # Only these columns are required seg_columns <- c(     \"ID\", \"chrom\", \"start\", \"end\", \"LOH_flag\", \"log.ratio\" )  seg <- seg %>%     select(all_of(seg_columns))  head(seg) bedpe <- get_manta_sv(     these_samples_metadata = metadata ) %>% as.data.frame  # Only these columns are required bedpe_columns <- colnames(bedpe)[1:11]  bedpe <- bedpe %>%     select(all_of(bedpe_columns))  head(bedpe)"},{"path":"https://morinlab.github.io/GAMBLR.open/articles/genetic_classification.html","id":"metadata","dir":"Articles","previous_headings":"","what":"Metadata","title":"Genetic classification of tumours","text":"metadata data frame contains column sample_id listing sample ids tumours classified, column pathology dictate sliding threshold aSHM site annotation necessary. column seq_type required classification purposes, kept tutorial purpose subsequent retreival mutation data.","code":"# Load metadata metadata <- get_gambl_metadata() %>%     filter(seq_type == \"genome\") %>%     filter(pathology %in% c(\"FL\", \"DLBCL\", \"BL\")) %>%     group_by(sample_id) %>%     slice_head() %>%     ungroup %>%     filter(!study %in% c(\"DLBCL_Arthur\", \"DLBCL_Thomas\"))  metadata %>%     count(pathology) # Demonstrate the required columns in metadata metadata <- metadata %>%     select(sample_id, pathology, seq_type)   head(metadata)"},{"path":"https://morinlab.github.io/GAMBLR.open/articles/genetic_classification.html","id":"ssm-maf-format","dir":"Articles","previous_headings":"","what":"SSM (maf format)","title":"Genetic classification of tumours","text":"key data provided genetic subgroup classification SSM maf format. small subset columns required used input information, demonstrate expected format minimal required information SSM.","code":"maf <- get_ssm_by_samples(     these_samples_metadata = metadata ) %>% as.data.frame  # Only these columns are required maf_columns <- c(     \"Hugo_Symbol\", \"NCBI_Build\",     \"Chromosome\", \"Start_Position\", \"End_Position\",     \"Variant_Classification\", \"HGVSp_Short\",     \"Tumor_Sample_Barcode\" )  maf <- maf %>%     select(all_of(maf_columns))  head(maf)"},{"path":"https://morinlab.github.io/GAMBLR.open/articles/genetic_classification.html","id":"cnv-seg-format","dir":"Articles","previous_headings":"","what":"CNV (seg format)","title":"Genetic classification of tumours","text":"Several classifiers (Chapuy et al, Lacy et al, Runge et al) require CNV information provided, demonstrate expected format minimal required information CNV standard seg format.","code":"seg <- get_cn_segments(     these_samples_metadata = metadata ) %>% as.data.frame  # Only these columns are required seg_columns <- c(     \"ID\", \"chrom\", \"start\", \"end\", \"LOH_flag\", \"log.ratio\" )  seg <- seg %>%     select(all_of(seg_columns))  head(seg)"},{"path":"https://morinlab.github.io/GAMBLR.open/articles/genetic_classification.html","id":"sv-bedpe-format","dir":"Articles","previous_headings":"","what":"SV (bedpe format)","title":"Genetic classification of tumours","text":"Several classifiers require SV data provided, demonstrate expected format minimal required information SV standard bed format. Note column manta_name can column tool choice generated bedpe output reports unique id SV event, expected unique SV event.","code":"bedpe <- get_manta_sv(     these_samples_metadata = metadata ) %>% as.data.frame  # Only these columns are required bedpe_columns <- colnames(bedpe)[1:11]  bedpe <- bedpe %>%     select(all_of(bedpe_columns))  head(bedpe)"},{"path":"https://morinlab.github.io/GAMBLR.open/articles/genetic_classification.html","id":"classify-dlbcl","dir":"Articles","previous_headings":"","what":"Classify DLBCL","title":"Genetic classification of tumours","text":", explore reproduced DLBCL classification groupings Chapuy et al, Lacy et al, Runge et al. classification algorithm can easily controlled switching argument method classify_dlbcl() function. Important DLBCL classifiers released publications, models provided best attempt reproducing original models. model described Chapuy et al reproduced > 92% accuracy, Lacy HMRN classifier results need taken caution accuracy bundled model 80%. paper published originally 2018 Chapuy et al first attempt use systematic approach classify DLBCL patients genetic subgroupings using genomic information. Note model classifies tumours according original 2018 publication, directly related 2024 DLBCLass model. subgroupings can recapitulated GAMBLR functionality: classify_ family functions default return assembled matrix predictions. model reports confidence tumour’s subgoup vote, well final label. paper published originally 2020 Lacy et al release classification algorithm, recapitulated training random forest model 80% accuaracy. subgroupings can recapitulated GAMBLR functionality: Similar Chapuy et al predictions, can see constructed matrix confidence tumour’s subgoup vote, well final label. paper published Runge et al modified original Lacy et al. subgoupings closely adhere genetic subgroups LymphGen classification system. difference Runge Lacy methods tumours truncating NOTCH1 mutation assigned separate subgrouping category regardless genetic alterations present tumour sample. subgroupings can recapitulated GAMBLR functionality: Take look resulting output","code":"predictions <- classify_dlbcl(     these_samples_metadata = metadata %>%         filter(pathology == \"DLBCL\"),     maf_data = maf,     seg_data = seg,     sv_data = bedpe ) # assembled matrix predictions$matrix[1:5,1:5] # subgroup assignment predictions$predictions %>%  slice_head(n=10) count(predictions$predictions, Chapuy_cluster) predictions <- classify_dlbcl(     these_samples_metadata = metadata %>%         filter(pathology == \"DLBCL\"),     maf_data = maf,     seg_data = seg,     sv_data = bedpe,     method = \"lacy\" ) # assembled matrix predictions$matrix[1:5,1:5] # subgroup assignment head(predictions$predictions) count(predictions$predictions, Lacy_cluster) predictions <- classify_dlbcl(     these_samples_metadata = metadata %>%         filter(pathology == \"DLBCL\"),     maf_data = maf,     seg_data = seg,     sv_data = bedpe,     method = \"hmrn\" ) # assembled matrix predictions$matrix[1:5,1:5] predictions$matrix[1:5,1:5] # subgroup assignment head(predictions$predictions) count(predictions$predictions, hmrn_cluster)"},{"path":"https://morinlab.github.io/GAMBLR.open/articles/genetic_classification.html","id":"chapuy-et-al--c0-c5-clusters","dir":"Articles","previous_headings":"","what":"Chapuy et al. (C0-C5 clusters)","title":"Genetic classification of tumours","text":"paper published originally 2018 Chapuy et al first attempt use systematic approach classify DLBCL patients genetic subgroupings using genomic information. Note model classifies tumours according original 2018 publication, directly related 2024 DLBCLass model. subgroupings can recapitulated GAMBLR functionality: classify_ family functions default return assembled matrix predictions. model reports confidence tumour’s subgoup vote, well final label.","code":"predictions <- classify_dlbcl(     these_samples_metadata = metadata %>%         filter(pathology == \"DLBCL\"),     maf_data = maf,     seg_data = seg,     sv_data = bedpe ) # assembled matrix predictions$matrix[1:5,1:5] # subgroup assignment predictions$predictions %>%  slice_head(n=10) count(predictions$predictions, Chapuy_cluster)"},{"path":"https://morinlab.github.io/GAMBLR.open/articles/genetic_classification.html","id":"lacy-et-al-","dir":"Articles","previous_headings":"","what":"Lacy et al.","title":"Genetic classification of tumours","text":"paper published originally 2020 Lacy et al release classification algorithm, recapitulated training random forest model 80% accuaracy. subgroupings can recapitulated GAMBLR functionality: Similar Chapuy et al predictions, can see constructed matrix confidence tumour’s subgoup vote, well final label.","code":"predictions <- classify_dlbcl(     these_samples_metadata = metadata %>%         filter(pathology == \"DLBCL\"),     maf_data = maf,     seg_data = seg,     sv_data = bedpe,     method = \"lacy\" ) # assembled matrix predictions$matrix[1:5,1:5] # subgroup assignment head(predictions$predictions) count(predictions$predictions, Lacy_cluster)"},{"path":"https://morinlab.github.io/GAMBLR.open/articles/genetic_classification.html","id":"hmrn","dir":"Articles","previous_headings":"","what":"HMRN","title":"Genetic classification of tumours","text":"paper published Runge et al modified original Lacy et al. subgoupings closely adhere genetic subgroups LymphGen classification system. difference Runge Lacy methods tumours truncating NOTCH1 mutation assigned separate subgrouping category regardless genetic alterations present tumour sample. subgroupings can recapitulated GAMBLR functionality: Take look resulting output","code":"predictions <- classify_dlbcl(     these_samples_metadata = metadata %>%         filter(pathology == \"DLBCL\"),     maf_data = maf,     seg_data = seg,     sv_data = bedpe,     method = \"hmrn\" ) # assembled matrix predictions$matrix[1:5,1:5] predictions$matrix[1:5,1:5] # subgroup assignment head(predictions$predictions) count(predictions$predictions, hmrn_cluster)"},{"path":"https://morinlab.github.io/GAMBLR.open/articles/genetic_classification.html","id":"classify-fl","dir":"Articles","previous_headings":"","what":"Classify FL","title":"Genetic classification of tumours","text":", explore classification FL tumours genetic subgroups differential propensity transformation originally described . developed model can easily accessed classify_fl() function. Similar DLBCL classifier, can take look assembled matrix, well predictions confidence tumour’s vote:","code":"predictions <- classify_fl(     these_samples_metadata = metadata %>%         filter(pathology  %in% c(\"FL\", \"DLBCL\")),     maf_data = maf,     output = \"both\" ) # assembled matrix predictions$matrix[1:10, 1:5] # subgroup assignment head(predictions$predictions) count(predictions$predictions, is_cFL)"},{"path":"https://morinlab.github.io/GAMBLR.open/articles/genetic_classification.html","id":"classify-bl","dir":"Articles","previous_headings":"","what":"Classify BL","title":"Genetic classification of tumours","text":", explore classification BL tumours genetic subgroups originally described Thomas et al. developed model reported study can easily accessed classify_bl() function. Similar classifiers, can take look assembled matrix, well predictions confidence tumour’s vote: ’s ! Happy GAMBLing!","code":"predictions <- classify_bl(     these_samples_metadata = metadata %>%         filter(pathology  %in% c(\"BL\", \"DLBCL\")),     maf_data = maf ) # assembled matrix predictions$matrix[1:10, 1:5] # subgroup assignment head(predictions$predictions) count(predictions$predictions, BL_subgroup) /$$$$$$     /$$$$$$    /$$      /$$   /$$$$$$$    /$$        .:::::::  /$$__  $$   /$$__  $$  | $$$    /$$$  | $$__  $$  | $$        .::    .:: | $$  \\__/  | $$  \\ $$  | $$$$  /$$$$  | $$  \\ $$  | $$        .::    .:: | $$ /$$$$  | $$$$$$$$  | $$ $$/$$ $$  | $$$$$$$   | $$   <-   .: .:: | $$|_  $$  | $$__  $$  | $$  $$$| $$  | $$__  $$  | $$        .::  .:: | $$  \\ $$  | $$  | $$  | $$\\  $ | $$  | $$  \\ $$  | $$        .::    .:: |  $$$$$$/  | $$  | $$  | $$ \\/  | $$  | $$$$$$$/  | $$$$$$$$  .::      .::  \\______/   |__/  |__/  |__/     |__/  |_______/   |________/  ~GENOMIC~~~~~~~~~~~~~OF~~~~~~~~~~~~~~~~~B-CELL~~~~~~~~~~~~~~~~~~IN~~~~~~  ~~~~~~~~~~~~ANALYSIS~~~~~~MATURE~~~~~~~~~~~~~~~~~~~LYMPHOMAS~~~~~~~~~~R~"},{"path":"https://morinlab.github.io/GAMBLR.open/articles/mutation_summary.html","id":"coding-and-non-coding-mutations","dir":"Articles","previous_headings":"","what":"Coding and non-coding mutations","title":"Exploring simple somatic mutations","text":"high-level overview genes mutations subset overall mutation incidence samples, can use GAMBLR.viz function prettyGeneCloud. function automatically remove non-coding variants data convenience feature. can get around assigning Variant_Classification column mutations imply Missense mutations. notice many genes prominent first cloud much smaller second one. can explained overwhelming fraction mutations representing non-coding variants. confirmed counting mutations Variant_Classification, demonstrated .","code":"fake_maf = mutate(genome_all,Variant_Classification = \"Missense_Mutation\")  prettyGeneCloud(fake_maf, zoomout = 0.2,these_genes= unique(genome_all$Hugo_Symbol)) prettyGeneCloud(genome_all, zoomout = 0.4,these_genes= unique(genome_all$Hugo_Symbol)) filter(genome_all,   Hugo_Symbol %in% c(\"BRINP3\",\"PTPRD\",\"DOCK1\",\"UNC5C\")) %>%    group_by(Hugo_Symbol,            Variant_Classification) %>%    count() %>%   kableExtra::kable(format=\"html\")"},{"path":"https://morinlab.github.io/GAMBLR.open/articles/mutation_summary.html","id":"ashm-targets","dir":"Articles","previous_headings":"","what":"aSHM targets","title":"Exploring simple somatic mutations","text":"Rather completely ignoring non-coding variants, can use approach gain overview frequency mutations regions identified targets aSHM.","code":"# re-run with the cell lines removed ashm_genome_maf = get_ssm_by_regions(these_samples_metadata = my_meta,                               this_seq_type = \"genome\",                               streamlined = F) prettyGeneCloud(mutate(ashm_genome_maf,                 Variant_Classification = \"Missense_Mutation\"),                 zoomout = 0.4,                 these_genes= unique(ashm_genome_maf$Hugo_Symbol)) # re-run with the cell lines removed ashm_genome_streamlined = get_ssm_by_regions(these_samples_metadata = my_meta,                               this_seq_type = \"genome\",                               streamlined = TRUE,                               use_name_column = TRUE) #add columns to force prettyGeneCloud to include everything  ashm_genome_streamlined = mutate(ashm_genome_streamlined,                             Hugo_Symbol = region_name,                             Variant_Classification= \"Missense_Mutation\",                             Tumor_Sample_Barcode = sample_id)  prettyGeneCloud(ashm_genome_streamlined,                 zoomout = 0.3,                 these_genes= unique(ashm_genome_streamlined$Hugo_Symbol))"},{"path":"https://morinlab.github.io/GAMBLR.open/articles/mutation_summary.html","id":"summarizing-with-ggplot2","dir":"Articles","previous_headings":"","what":"Summarizing with ggplot2","title":"Exploring simple somatic mutations","text":"Word clouds useful communicating relationship numeric values. ’ll continue using ggplot2 instead.  can see, total number coding + non-coding mutations affecting genes among samples quite variable. BCL2, IGLL5, BCL6, PAX5 etc heavily affected.","code":"ashm_genome_freq = mutate(ashm_genome_streamlined,                           gene = str_remove(Hugo_Symbol,\"-.+\")) %>%                    group_by(gene) %>%                    summarise(num_mutations=n()) %>%                     arrange(desc(num_mutations)) ashm_genome_freq$gene = factor(ashm_genome_freq$gene,                               levels = rev(unique(ashm_genome_freq$gene))) p = ggplot(ashm_genome_freq,aes(y=gene,x=num_mutations)) +      geom_col() +     theme_Morons(base_size=4) p"},{"path":"https://morinlab.github.io/GAMBLR.open/articles/mutation_summary.html","id":"building-a-maf-summary-from-scratch","dir":"Articles","previous_headings":"","what":"Building a MAF summary from scratch","title":"Exploring simple somatic mutations","text":"Many analyses probably focus mutations protein-coding space predicted effect proteins. rest tutorial, ’ll delve mutations obtained start using get_coding_ssm. , ’ll work towards reproducing output maftools::plotmafSummary, working one panel time.                    Happy GAMBLing!","code":"make_panel1 = function(maf_data,base_size=7,title=\"\"){ vc_counted  = maf_data %>%    group_by(Variant_Classification) %>%    count() %>%    arrange(n) vc_counted$Variant_Classification = factor(         vc_counted$Variant_Classification,         levels=unique(vc_counted$Variant_Classification)     ) mut_cols = get_gambl_colours(\"mutation\") p1 = ggplot(vc_counted,             aes(x=n,                 y=Variant_Classification,                 fill=Variant_Classification)) +    geom_col() + scale_fill_manual(values=mut_cols)+   theme_Morons(base_size = base_size,   my_legend_position = \"none\")  +   theme(axis.title.x = element_blank(),         axis.title.y = element_blank(),     axis.text.x=element_blank(),         axis.ticks.x=element_blank(),         panel.grid.major = element_blank(),         panel.grid.minor = element_blank()         ) +   ggtitle(title) p1 } make_panel1(genome_coding, title=\"Genomes, coding regions\") make_panel1(genome_all, title=\"Genomes, all regions\") make_panel1(capture_coding, title=\"Exomes\") make_panel2 = function(maf_data,base_size=7,title=\"\"){ type_counted  = maf_data %>%    group_by(Variant_Type) %>%    count() %>%    arrange(n) type_counted$Variant_Type = factor(         type_counted$Variant_Type,         levels=unique(type_counted$Variant_Type)     )  mut_cols = c(SNP=\"purple1\",INS=\"yellow3\",DEL=\"lightblue\",DNP=\"orange\",\"TNP\"=\"lightgreen\") p2 =ggplot(type_counted,aes(x=n,y=Variant_Type,fill=Variant_Type)) +    geom_col() + scale_fill_manual(values=mut_cols)+   theme_Morons(base_size = base_size,my_legend_position = \"none\")  +   theme(axis.title.x = element_blank(),         axis.title.y = element_blank(),     axis.text.x=element_blank(),         axis.ticks.x=element_blank(),         panel.grid.major = element_blank(),         panel.grid.minor = element_blank()         ) +   ggtitle(title)   p2 } make_panel2(genome_coding, title=\"Genomes, coding regions\") make_panel2(genome_all, title=\"Genomes, all regions\") make_panel2(capture_coding, title = \"Exomes\") make_panel3 = function(maf_data,base_size=7,title=\"\"){     comp = function(base){   chartr(\"ACTG\", \"TGAC\",base) } maf_data = mutate(maf_data,                        class = case_when(                          Reference_Allele %in% c(\"T\",\"C\") ~                             paste0(Reference_Allele,                                   \">\",                                   Tumor_Seq_Allele2),                          TRUE ~ paste0(comp(Reference_Allele),                                        \">\",                                        comp(Tumor_Seq_Allele2)))                        )  class_counted = maf_data %>% dplyr::filter(Variant_Type == \"SNP\") %>%   group_by(class) %>% count() class_counted = mutate(class_counted,class = factor(class,levels=c(\"C>A\",\"C>G\",\"C>T\",\"T>C\",\"T>A\",\"T>G\"))) mut_cols = get_gambl_colours(\"rainfall\") p3 = ggplot(class_counted,aes(x=n,y=class,fill=class)) +    geom_col() + scale_fill_manual(values=mut_cols)+   theme_Morons(base_size = base_size,my_legend_position = \"none\")  +    theme(axis.title.x = element_blank(),         axis.title.y = element_blank(),     axis.text.x=element_blank(),         axis.ticks.x=element_blank(),         panel.grid.major = element_blank(),         panel.grid.minor = element_blank()         ) +   ggtitle(title) p3 } make_panel3(genome_coding, title=\"Genomes, coding regions\") make_panel3(genome_all, title=\"Genomes, all regions\") make_panel3(capture_coding, title = \"Exomes\") make_panel4 = function(maf_data,base_size=7,title=\"\"){     type_counted  = maf_data %>%    group_by(Tumor_Sample_Barcode,Variant_Classification) %>%    count() %>%    arrange(desc(n)) type_counted$Tumor_Sample_Barcode = factor(type_counted$Tumor_Sample_Barcode,                                             levels=unique(type_counted$Tumor_Sample_Barcode))  mut_cols = get_gambl_colours(\"mutation\") p4 = ggplot(type_counted,aes(x=Tumor_Sample_Barcode,y=n,fill=Variant_Classification)) +    geom_col() +   scale_fill_manual(values=mut_cols) +      theme_Morons(base_size = base_size,my_legend_position = \"none\") +    theme(axis.title.x = element_blank(),         axis.title.y = element_blank(),     axis.text.x=element_blank(),         axis.ticks.x=element_blank(),         panel.grid.major = element_blank(),         panel.grid.minor = element_blank()         ) +   ggtitle(title)     p4 } make_panel4(genome_coding, title=\"Genomes, coding regions\") make_panel4(genome_all, title=\"Genomes, all regions\") make_panel4(capture_coding, title = \"Exomes\") library(ggbeeswarm) make_panel5 = function(maf_data,base_size=7,point_size=0.5,title=\"\"){   mut_cols = get_gambl_colours()   type_counted  = maf_data %>%    group_by(Tumor_Sample_Barcode,Variant_Classification) %>%    count() %>%    arrange(desc(n)) vc_counted  = maf_data %>%    group_by(Variant_Classification) %>%    count() %>%    arrange(n) vc_counted$Variant_Classification = factor(vc_counted$Variant_Classification,                                              levels=unique(vc_counted$Variant_Classification)) type_counted$Variant_Classification = factor(type_counted$Variant_Classification,                                              levels=rev(unique(vc_counted$Variant_Classification))) p5 = ggplot(type_counted,aes(x=Variant_Classification,y=n,colour=Variant_Classification)) +    geom_quasirandom(size=point_size) +   scale_colour_manual(values=mut_cols) +   scale_y_log10() +   theme_Morons(base_size = base_size,my_legend_position = \"none\")  +   theme(axis.title.y =element_blank(),         axis.text.x =element_blank(),         axis.title.x = element_blank(),         axis.ticks.x=element_blank()) +   ggtitle(title) p5 } make_panel5(genome_coding, title=\"Genomes, coding regions\") make_panel5(genome_all, title=\"Genomes, all regions\") make_panel5(capture_coding, title=\"Exomes\") make_panel6 = function(maf_data,base_size=7,top=10,title=\"\"){   type_counted  = maf_data %>%    group_by(Hugo_Symbol,Variant_Classification) %>%    count() %>%    arrange(n)  top_n = group_by(type_counted,Hugo_Symbol) %>%   summarise(total=sum(n)) %>%   arrange(desc(total)) %>%   slice_head(n=top) %>%   pull(Hugo_Symbol) mut_cols = get_gambl_colours() some_type_counted = dplyr::filter(type_counted,Hugo_Symbol %in% top_n) some_type_counted$Hugo_Symbol = factor(some_type_counted$Hugo_Symbol,                                             levels=rev(top_n)) p6 =    ggplot(some_type_counted,aes(y=Hugo_Symbol,x=n,fill=Variant_Classification)) +    geom_col() +   scale_fill_manual(values=mut_cols) +   theme_Morons(base_size = base_size,my_legend_position = \"none\")  +   theme(axis.text.x=element_blank(),         axis.title.y = element_blank(),         axis.title.x = element_blank(),         axis.ticks.x=element_blank()) +   ggtitle(title)  p6 } make_panel6(genome_coding,base_size=6, title=\"Genome, coding regions\") make_panel6(genome_all, title=\"Genomes, all regions\") make_panel6(capture_coding, title = \"Exomes\") library(cowplot) bs = 8 ps =0.1 p1 = make_panel1(genome_coding,base_size = bs,title=\"Variant Classification\") p2 = make_panel2(genome_coding,base_size = bs,title=\"Variant Type\") p3 = make_panel3(genome_coding,base_size = bs,title=\"SNV Class\") p4 = make_panel4(genome_coding,base_size = bs,title=\"Variants per sample\") p5 = make_panel5(genome_coding,base_size = bs,point_size=ps,title=\"Variant Classification Summary\") p6 = make_panel6(genome_coding,base_size = bs, title=\"Top 10 genes\") all_p = cowplot::plot_grid(p1,p2,p3,p4,p5,p6,nrow = 2,ncol=3) all_p /$$$$$$     /$$$$$$    /$$      /$$   /$$$$$$$    /$$        .:::::::  /$$__  $$   /$$__  $$  | $$$    /$$$  | $$__  $$  | $$        .::    .:: | $$  \\__/  | $$  \\ $$  | $$$$  /$$$$  | $$  \\ $$  | $$        .::    .:: | $$ /$$$$  | $$$$$$$$  | $$ $$/$$ $$  | $$$$$$$   | $$   <-   .: .:: | $$|_  $$  | $$__  $$  | $$  $$$| $$  | $$__  $$  | $$        .::  .:: | $$  \\ $$  | $$  | $$  | $$\\  $ | $$  | $$  \\ $$  | $$        .::    .:: |  $$$$$$/  | $$  | $$  | $$ \\/  | $$  | $$$$$$$/  | $$$$$$$$  .::      .::  \\______/   |__/  |__/  |__/     |__/  |_______/   |________/  ~GENOMIC~~~~~~~~~~~~~OF~~~~~~~~~~~~~~~~~B-CELL~~~~~~~~~~~~~~~~~~IN~~~~~~  ~~~~~~~~~~~~ANALYSIS~~~~~~MATURE~~~~~~~~~~~~~~~~~~~LYMPHOMAS~~~~~~~~~~R~"},{"path":"https://morinlab.github.io/GAMBLR.open/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Ryan Morin. Author, maintainer. Kostia Dreval. Author.","code":""},{"path":"https://morinlab.github.io/GAMBLR.open/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Morin R, Dreval K (2025). GAMBLR.open: GAMBLR.open. R package version 1.1.","code":"@Manual{,   title = {GAMBLR.open: GAMBLR.open},   author = {Ryan Morin and Kostia Dreval},   year = {2025},   note = {R package version 1.1}, }"},{"path":"https://morinlab.github.io/GAMBLR.open/index.html","id":"gamblropen","dir":"","previous_headings":"","what":"GAMBLR.open","title":"GAMBLR.open","text":"Database, mining, manipulation convenience functions working genomic data mature B-cell lymphomas. package wrapper provides convenient one-stop access load following packages GAMBLR family: GAMBLR.data - collection genomic data analysis Mature B-cell neoplasms GAMBLR.helpers - set low-level functions data operation GAMBLR.utils - higher level set functions operate genomic data GAMBLR.viz - set functions used mostly visualizations GAMBLR.predict - collection functions helpers classify B-cell lymphomas","code":""},{"path":"https://morinlab.github.io/GAMBLR.open/index.html","id":"cloning-repo-for-the-code-development","dir":"","previous_headings":"","what":"Cloning repo for the code development","title":"GAMBLR.open","text":"easiest way obtain contribute GAMBLR.open via cloning repository R editor choice, set working directory place just cloned repo. Install package R running following command (requires devtools package) GAMBL users (GAMBLRs, speak) rely functionality package, Master branch protected. commits must submitted via pull request branch.","code":"cd git clone git@github.com:morinlab/GAMBLR.open.git setwd(\"~/GAMBLR.open\") devtools::install()"},{"path":"https://morinlab.github.io/GAMBLR.open/reference/annotate_hotspots.html","id":null,"dir":"Reference","previous_headings":"","what":"Annotate Hotspots. — annotate_hotspots","title":"Annotate Hotspots. — annotate_hotspots","text":"Annotate MAF-like data frome hot_spot column indicating recurrent mutations.","code":""},{"path":"https://morinlab.github.io/GAMBLR.open/reference/annotate_hotspots.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Annotate Hotspots. — annotate_hotspots","text":"","code":"annotate_hotspots(mutation_maf, ...)"},{"path":"https://morinlab.github.io/GAMBLR.open/reference/annotate_hotspots.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Annotate Hotspots. — annotate_hotspots","text":"mutation_maf data frame MAF format. ... parameter. parameters ignored.","code":""},{"path":"https://morinlab.github.io/GAMBLR.open/reference/annotate_hotspots.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Annotate Hotspots. — annotate_hotspots","text":"data frame one additional column \"hot_spot\".","code":""},{"path":"https://morinlab.github.io/GAMBLR.open/reference/annotate_hotspots.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Annotate Hotspots. — annotate_hotspots","text":"function takes already loaded MAF data frame mutation_maf parameter.","code":""},{"path":"https://morinlab.github.io/GAMBLR.open/reference/annotate_hotspots.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Annotate Hotspots. — annotate_hotspots","text":"","code":"my_metadata = get_gambl_metadata() #> Using the bundled metadata in GAMBLR.data... all_coding_ssm = get_coding_ssm(these_samples_metadata = my_metadata,                                 projection = \"grch37\",                                 this_seq_type = \"genome\") %>%                    dplyr::filter(Hugo_Symbol %in% c(\"EZH2\",                                  \"MEF2B\",\"MYD88\",\"KMT2D\")) %>%                    dplyr::arrange(Hugo_Symbol) #> Using the bundled SSM calls (.maf) calls in GAMBLR.data... #> id_ease: WARNING! 1838 samples in the provided metadata were removed because their seq types are not the same as in the `set_type` argument. Use `verbose = TRUE` to see their IDs. #> after linking with metadata, we have mutations from 817 samples  hot_ssms = annotate_hotspots(all_coding_ssm) hot_ssms %>% dplyr::filter(!is.na(hot_spot)) %>%       dplyr::select(1:5,37,hot_spot) #> genomic_data Object #> Genome Build: grch37  #> Showing first 10 rows: #>    Hugo_Symbol Entrez_Gene_Id Center NCBI_Build Chromosome HGVSp_Short hot_spot #> 1         EZH2              0      .     GRCh37          7     p.Y646N     TRUE #> 2         EZH2              0      .     GRCh37          7     p.Y646H     TRUE #> 3         EZH2              0      .     GRCh37          7     p.Y646N     TRUE #> 4         EZH2              0      .     GRCh37          7     p.Y646F     TRUE #> 5         EZH2              0      .     GRCh37          7     p.Y646N     TRUE #> 6         EZH2              0      .     GRCh37          7     p.Y646N     TRUE #> 7         EZH2              0      .     GRCh37          7     p.Y646F     TRUE #> 8         EZH2              0      .     GRCh37          7     p.Y646S     TRUE #> 9         EZH2              0      .     GRCh37          7     p.Y646S     TRUE #> 10        EZH2              0      .     GRCh37          7     p.Y646F     TRUE"},{"path":"https://morinlab.github.io/GAMBLR.open/reference/assign_cn_to_ssm.html","id":null,"dir":"Reference","previous_headings":"","what":"Assign CN to SSM. — assign_cn_to_ssm","title":"Assign CN to SSM. — assign_cn_to_ssm","text":"Annotate mutations copy number information.","code":""},{"path":"https://morinlab.github.io/GAMBLR.open/reference/assign_cn_to_ssm.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Assign CN to SSM. — assign_cn_to_ssm","text":"","code":"assign_cn_to_ssm(   these_samples_metadata,   maf_data,   seg_data,   projection,   coding_only = FALSE,   assume_diploid = FALSE,   include_silent = FALSE,   ... )"},{"path":"https://morinlab.github.io/GAMBLR.open/reference/assign_cn_to_ssm.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Assign CN to SSM. — assign_cn_to_ssm","text":"these_samples_metadata Metadata table one rows specify samples process. maf_data data frame mutations MAF format maf_data object (e.g. get_coding_ssm get_ssm_by_sample). seg_data data frame segmented copy number data seg_data object projection Specified genome projection returned data relative . required inferred maf_df seg_df (provided). coding_only Optional. Set TRUE restrict variants coding space Default work genome-wide variants. assume_diploid Optional, parameter annotates every mutation copy neutral. Default FALSE. include_silent Logical parameter indicating whether include silent mutations coding space. Default FALSE. parameter makes sense coding_only set TRUE. ... additional parameters.","code":""},{"path":"https://morinlab.github.io/GAMBLR.open/reference/assign_cn_to_ssm.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Assign CN to SSM. — assign_cn_to_ssm","text":"list containing data frame (MAF-like format) three extra columns: - log.ratio log ratio seg file (NA overlap). - LOH - CN (rounded absolute copy number estimate region based log.ratio, NA overlap found).","code":""},{"path":"https://morinlab.github.io/GAMBLR.open/reference/assign_cn_to_ssm.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Assign CN to SSM. — assign_cn_to_ssm","text":"function takes metadata table returns mutations samples metadata. mutation annotated local copy number state mutated site. user can specify coding mutations interest. , set coding_only = TRUE. necessary, function relies get_ssm_by_samples get_cn_segments obtain required data.","code":""},{"path":"https://morinlab.github.io/GAMBLR.open/reference/assign_cn_to_ssm.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Assign CN to SSM. — assign_cn_to_ssm","text":"","code":"# long-handed way # 1. get some metadata for a collection of samples some_meta = get_gambl_metadata() %>%         dplyr::filter(study==\"FL_Dreval\",         grepl(\"SP\",sample_id)) #> Using the bundled metadata in GAMBLR.data... # 2. Get the SSMs for these samples  ssm_genomes_grch37 = get_coding_ssm(projection = \"grch37\",                                   these_samples_metadata = some_meta) #> Using the bundled SSM calls (.maf) calls in GAMBLR.data... #> after linking with metadata, we have mutations from 182 samples # peek at the results ssm_genomes_grch37 %>% dplyr::select(1:8) #> genomic_data Object #> Genome Build: grch37  #> Showing first 10 rows: #>    Hugo_Symbol Entrez_Gene_Id Center NCBI_Build Chromosome Start_Position #> 1       HNRNPU              0      .     GRCh37          1      245027102 #> 2         PCLO              0      .     GRCh37          7       82784068 #> 3        MYOM2              0      .     GRCh37          8        2063762 #> 4       CREBBP              0      .     GRCh37         16        3786740 #> 5        IGLL5              0      .     GRCh37         22       23230399 #> 6    HIST1H2BC              0      .     GRCh37          6       26123774 #> 7        SETD2              0      .     GRCh37          3       47088059 #> 8         IRF8              0      .     GRCh37         16       85942737 #> 9       ARID5B              0      .     GRCh37         10       63661999 #> 10      ARID5B              0      .     GRCh37         10       63810677 #>    End_Position Strand #> 1     245027102      + #> 2      82784068      + #> 3       2063762      + #> 4       3786740      + #> 5      23230400      + #> 6      26123774      + #> 7      47088059      + #> 8      85942737      + #> 9      63661999      + #> 10     63810677      +  # 3. Lazily let this function obtain the corresponding seg_data # for the right genome_build cn_list = assign_cn_to_ssm(some_meta,ssm_genomes_grch37) #> Using the bundled CN segments (.seg) calls in GAMBLR.data... #> Running in default mode of any...  cn_list$maf %>% dplyr::select(1:8,log.ratio,CN) #> genomic_data Object #> Genome Build: grch37  #> Showing first 10 rows: #>    Hugo_Symbol Entrez_Gene_Id Center NCBI_Build Chromosome Start_Position #> 1       HNRNPU              0      .     GRCh37          1      245027102 #> 2         PCLO              0      .     GRCh37          7       82784068 #> 3        MYOM2              0      .     GRCh37          8        2063762 #> 4       CREBBP              0      .     GRCh37         16        3786740 #> 5        IGLL5              0      .     GRCh37         22       23230399 #> 6    HIST1H2BC              0      .     GRCh37          6       26123774 #> 7        SETD2              0      .     GRCh37          3       47088059 #> 8         IRF8              0      .     GRCh37         16       85942737 #> 9       ARID5B              0      .     GRCh37         10       63661999 #> 10      ARID5B              0      .     GRCh37         10       63810677 #>    End_Position Strand log.ratio CN #> 1     245027102      + 0.4306932  3 #> 2      82784068      + 0.0000000  2 #> 3       2063762      + 0.0000000  2 #> 4       3786740      + 0.0000000  2 #> 5      23230400      + 0.0000000  2 #> 6      26123774      + 0.0000000  2 #> 7      47088059      + 0.0000000  2 #> 8      85942737      + 1.3219281  5 #> 9      63661999      + 0.5849625  3 #> 10     63810677      + 0.5849625  3 if (FALSE) { # \\dontrun{ # This wouldn't work because the hg38 seg_data is not bundled ssm_genomes_hg38 = get_coding_ssm(projection = \"hg38\",                                   these_samples_metadata = some_meta) cn_list = assign_cn_to_ssm(some_meta,ssm_genomes_hg38)  # Easiest/laziest way: cn_list = assign_cn_to_ssm(projection = \"grch37\")   cn_list$maf %>% dplyr::group_by(Tumor_Sample_Barcode,CN) %>%   dplyr::count() } # }"},{"path":"https://morinlab.github.io/GAMBLR.open/reference/calc_mutation_frequency_bin_region.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate Mutation Frequency By Sliding Window. — calc_mutation_frequency_bin_region","title":"Calculate Mutation Frequency By Sliding Window. — calc_mutation_frequency_bin_region","text":"Count number mutations sliding window across region samples.","code":""},{"path":"https://morinlab.github.io/GAMBLR.open/reference/calc_mutation_frequency_bin_region.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate Mutation Frequency By Sliding Window. — calc_mutation_frequency_bin_region","text":"","code":"calc_mutation_frequency_bin_region(   region,   these_samples_metadata = NULL,   these_sample_ids = NULL,   this_seq_type = \"genome\",   maf_data = NULL,   projection = \"grch37\",   slide_by = 100,   window_size = 1000,   return_format = \"long\",   min_count_per_bin = 0,   return_count = TRUE,   drop_unmutated = FALSE,   ... )"},{"path":"https://morinlab.github.io/GAMBLR.open/reference/calc_mutation_frequency_bin_region.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate Mutation Frequency By Sliding Window. — calc_mutation_frequency_bin_region","text":"region string describing genomic region \"chrom:start-end\" format. region must specified format separate chromosome, start_pos, end_pos arguments. these_samples_metadata Optional data frame containing sample_id column. providing maf file, seq_type also required column. these_sample_ids Optional vector sample IDs. Output subset IDs present vector. this_seq_type Optional vector seq_types include heatmap. Default \"genome\". Uses default seq_type priority samples >1 seq_type. maf_data Optional maf data frame. subset rows Tumor_Sample_Barcode matches provided sample IDs metadata table. provided, maf data obtained get_ssm_by_regions(). projection Specify genome build use. Required. Default grch37. slide_by Slide size sliding window. Default 100. window_size Size sliding window. Default 1000. return_format Return format mutations. Accepted inputs \"long\" \"wide\". Long returns data frame one sample ID/window per row. Wide returns matrix one sample ID per row one window per column. Using \"wide\" format retain samples windows regardless drop_unmutated min_count_per_bin parameters. min_count_per_bin Minimum counts per bin, default 0. Setting greater 0 drop unmutated windows return_format long. return_count Boolean statement return mutation count per window (TRUE) binary mutated/unmutated status (FALSE). Default TRUE. drop_unmutated Boolean whether drop windows 0 mutations. effective \"long\" return format. ... additional parameters.","code":""},{"path":"https://morinlab.github.io/GAMBLR.open/reference/calc_mutation_frequency_bin_region.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate Mutation Frequency By Sliding Window. — calc_mutation_frequency_bin_region","text":"Either matrix long tidy table counts per window.","code":""},{"path":"https://morinlab.github.io/GAMBLR.open/reference/calc_mutation_frequency_bin_region.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Calculate Mutation Frequency By Sliding Window. — calc_mutation_frequency_bin_region","text":"function called return mutation frequency given region, either provided input maf data frame GAMBL maf data. Regions specified region parameter. Alternatively, region interest can also specified calling function chromosome, start_pos, end_pos parameters. function operates single region. return matrix sliding window counts multiple regions, see calc_mutation_frequency_bin_regions.","code":""},{"path":"https://morinlab.github.io/GAMBLR.open/reference/calc_mutation_frequency_bin_region.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate Mutation Frequency By Sliding Window. — calc_mutation_frequency_bin_region","text":"","code":"myc_region = \"8:128747680-128753674\"  myc_mut_freq = calc_mutation_frequency_bin_region(region = myc_region,                                                   slide_by = 10,                                                   window_size = 10000) #> Using the bundled metadata in GAMBLR.data... #> processing bins of size 10000 across 5994 bp region #> Using GAMBLR.data::get_ssm_by_region... #> Using the bundled metadata in GAMBLR.data... #> Joining with `by = join_by(sample_id)` #> Joining with `by = join_by(window_start)` dplyr::arrange(myc_mut_freq,desc(mutation_count)) #> # A tibble: 612,000 × 3 #>    sample_id                 bin         mutation_count #>    <chr>                     <chr>                <int> #>  1 BLGSP-71-26-00399-01A-01E 8_128747680             41 #>  2 BLGSP-71-26-00399-01A-01E 8_128747690             41 #>  3 BLGSP-71-26-00399-01A-01E 8_128747700             41 #>  4 BLGSP-71-26-00399-01A-01E 8_128747710             41 #>  5 BLGSP-71-26-00399-01A-01E 8_128747720             41 #>  6 BLGSP-71-26-00399-01A-01E 8_128747730             41 #>  7 BLGSP-71-26-00399-01A-01E 8_128747740             41 #>  8 BLGSP-71-26-00399-01A-01E 8_128747750             41 #>  9 BLGSP-71-26-00399-01A-01E 8_128747760             41 #> 10 BLGSP-71-26-00399-01A-01E 8_128747770             41 #> # ℹ 611,990 more rows"},{"path":"https://morinlab.github.io/GAMBLR.open/reference/calc_mutation_frequency_bin_regions.html","id":null,"dir":"Reference","previous_headings":"","what":"Mutation counts across sliding windows for multiple regions. — calc_mutation_frequency_bin_regions","title":"Mutation counts across sliding windows for multiple regions. — calc_mutation_frequency_bin_regions","text":"Obtain long tidy wide matrix mutation counts across sliding windows multiple regions.","code":""},{"path":"https://morinlab.github.io/GAMBLR.open/reference/calc_mutation_frequency_bin_regions.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Mutation counts across sliding windows for multiple regions. — calc_mutation_frequency_bin_regions","text":"","code":"calc_mutation_frequency_bin_regions(   regions_list = NULL,   regions_bed = NULL,   these_samples_metadata = NULL,   these_sample_ids = NULL,   this_seq_type = \"genome\",   maf_data = NULL,   projection = \"grch37\",   region_padding = 1000,   drop_unmutated = FALSE,   skip_regions = NULL,   only_regions = NULL,   slide_by = 100,   window_size = 500,   return_format = \"wide\",   ... )"},{"path":"https://morinlab.github.io/GAMBLR.open/reference/calc_mutation_frequency_bin_regions.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Mutation counts across sliding windows for multiple regions. — calc_mutation_frequency_bin_regions","text":"regions_list Named vector regions format c(name1 = \"chr:start-end\", name2 = \"chr:start-end\"). neither regions regions_bed specified, function use GAMBLR aSHM region information. regions_bed Data frame regions four columns (chrom, start, end, name). these_samples_metadata Metadata least sample_id column. providing maf data frame, seq_type also required. these_sample_ids Vector sample IDs. Metadata subset sample IDs present vector. this_seq_type Optional vector seq_types include heatmap. Default \"genome\". Uses default seq_type priority samples >1 seq_type. maf_data Optional maf data frame. subset rows Tumor_Sample_Barcode matches provided sample IDs metadata table. provided, maf data obtained get_ssm_by_regions(). projection Genome build function operate . Ensure matches provided regions maf data correct chr prefix handling. Default \"grch37\". region_padding Amount pad start end coordinates . Default 1000. drop_unmutated Whether drop bins 0 mutations. returning matrix format, drop bins mutations samples. skip_regions Optional character vector genes exclude default aSHM regions. only_regions Optional character vector genes include default aSHM regions. slide_by Slide size sliding window. Default 100. window_size Size sliding window. Default 500. return_format Return format mutations. Accepted inputs \"long\" \"wide\". Long returns data frame one sample ID/window per row. Wide returns matrix one sample ID per row one window per column. Using \"wide\" format retain samples windows regardless drop_unmutated min_count_per_bin parameters. Default wide. ... additional parameters.","code":""},{"path":"https://morinlab.github.io/GAMBLR.open/reference/calc_mutation_frequency_bin_regions.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Mutation counts across sliding windows for multiple regions. — calc_mutation_frequency_bin_regions","text":"table mutation counts sliding windows across one regions. May long wide.","code":""},{"path":"https://morinlab.github.io/GAMBLR.open/reference/calc_mutation_frequency_bin_regions.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Mutation counts across sliding windows for multiple regions. — calc_mutation_frequency_bin_regions","text":"function takes metadata table these_samples_metadata parameter internally calls calc_mutation_frequency_bin_region (internally calls get_ssm_by_regions). retrieve mutation counts sliding windows across one regions. May optionally provide combination maf data frame, existing metadata, regions data frame named vector.","code":""},{"path":"https://morinlab.github.io/GAMBLR.open/reference/calc_mutation_frequency_bin_regions.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Mutation counts across sliding windows for multiple regions. — calc_mutation_frequency_bin_regions","text":"","code":"#load metadata.  my_meta = get_gambl_metadata() #> Using the bundled metadata in GAMBLR.data...  dlbcl_bl_meta = dplyr::filter(my_meta, pathology %in% c(\"DLBCL\", \"BL\"))    #get ashm regions  some_regions = create_bed_data(grch37_ashm_regions,                                 fix_names = \"concat\",                                 concat_cols = c(\"gene\",\"region\"),                                 sep=\"-\")  print(some_regions) #> BED Data Object #> Genome Build: grch37  #> Showing first 10 rows: #>    chrom     start       end           name region regulatory_comment #> 1      1   6661482   6662702     KLHL21-TSS    TSS               <NA> #> 2      1  23885584  23885835        ID3-TSS    TSS               <NA> #> 3      1  28832551  28836339       RCC1-TSS    TSS               <NA> #> 4      1  31229012  31232011     LAPTM5-TSS    TSS               <NA> #> 5      1 150550814 150552135    MCL1-intron intron               <NA> #> 6      2  88904839  88909096 EIF2Ak3-intron intron               <NA> #> 7      2  88925456  88927581    EIF2Ak3-TSS    TSS               <NA> #> 8      2 232572640 232574297       PTMA-TSS    TSS               <NA> #> 9      2 157669490 157671299      FCRL3-TSS    TSS               <NA> #> 10     1 203274698 203275778    BTG2-intron intron    active_promoter  mut_count_matrix <- calc_mutation_frequency_bin_regions(    these_samples_metadata = dlbcl_bl_meta,    regions_bed = some_regions  ) #> id_ease: WARNING! 1783 samples in the provided metadata were removed because their seq types are not the same as in the `set_type` argument. Use `verbose = TRUE` to see their IDs. dim(mut_count_matrix) #> [1]   763 14697 tail(mut_count_matrix[,c(1:10)]) #> # A tibble: 6 × 10 #>   sample_id `1_6661382` `1_6661482` `1_6661582` `1_6661682` `1_6661782` #>   <chr>           <int>       <int>       <int>       <int>       <int> #> 1 SP59456             0           0           0           0           0 #> 2 SP59460             0           0           0           0           0 #> 3 SU-DHL-10           0           0           0           0           0 #> 4 SU-DHL-4            0           0           0           0           0 #> 5 Seraphina           0           0           0           0           0 #> 6 Thomas              0           0           0           0           0 #> # ℹ 4 more variables: `1_6661882` <int>, `1_6661982` <int>, `1_6662082` <int>, #> #   `1_6662182` <int>"},{"path":"https://morinlab.github.io/GAMBLR.open/reference/check_excess_params.html","id":null,"dir":"Reference","previous_headings":"","what":"Check Excess Params — check_excess_params","title":"Check Excess Params — check_excess_params","text":"Function checking excessive parameter names. function notify user unavailable parameters called given given function. function designed work internal function-call already available GAMBLR functions.","code":""},{"path":"https://morinlab.github.io/GAMBLR.open/reference/check_excess_params.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check Excess Params — check_excess_params","text":"","code":"check_excess_params(...)"},{"path":"https://morinlab.github.io/GAMBLR.open/reference/check_excess_params.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check Excess Params — check_excess_params","text":"... Parameters check.","code":""},{"path":"https://morinlab.github.io/GAMBLR.open/reference/check_excess_params.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Check Excess Params — check_excess_params","text":"Nothing","code":""},{"path":"https://morinlab.github.io/GAMBLR.open/reference/check_excess_params.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Check Excess Params — check_excess_params","text":"Catch function calls containing unsupported arguments.","code":""},{"path":"https://morinlab.github.io/GAMBLR.open/reference/collate_results.html","id":null,"dir":"Reference","previous_headings":"","what":"Collate Results — collate_results","title":"Collate Results — collate_results","text":"Bring together collated results selection gambl samples.","code":""},{"path":"https://morinlab.github.io/GAMBLR.open/reference/collate_results.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Collate Results — collate_results","text":"","code":"collate_results(   sample_table,   these_samples_metadata,   join_with_full_metadata = FALSE,   seq_type_filter = c(\"genome\", \"capture\"),   ... )"},{"path":"https://morinlab.github.io/GAMBLR.open/reference/collate_results.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Collate Results — collate_results","text":"sample_table vector characters sample IDs, data frame sample IDs column (sample_id). provided, overwrite sample subsets provided these_samples_metadata. these_samples_metadata metadata table sample IDs interest. provided, function get metadata available samples. parameter intended use combination join_with_full_metadata. join_with_full_metadata Set TRUE horizontally expand metadata QC results. Default FALSE. these_samples_metadata provided, collated resutls added metadata table. provided, function join collated results available metadata specified seq_type (seq_type_filter). seq_type_filter Filtering criteria get_gambl_metadata these_samples_metadata provided, default genomes captures. ... additional parameters.","code":""},{"path":"https://morinlab.github.io/GAMBLR.open/reference/collate_results.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Collate Results — collate_results","text":"data frame collated results.","code":""},{"path":"https://morinlab.github.io/GAMBLR.open/reference/collate_results.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Collate Results — collate_results","text":"Currently, function gathers QC metrics (mirage_metrics) collated result. Potentially, future, additional collated results can added function well.","code":""},{"path":"https://morinlab.github.io/GAMBLR.open/reference/collate_results.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Collate Results — collate_results","text":"","code":"#load packages library(dplyr) #>  #> Attaching package: ‘dplyr’ #> The following objects are masked from ‘package:stats’: #>  #>     filter, lag #> The following objects are masked from ‘package:base’: #>  #>     intersect, setdiff, setequal, union  #return collated results for all available samples all_collated = collate_results() #> Using the bundled collated results in GAMBLR.data... #> Using the bundled metadata in GAMBLR.data...  #return available collated results for a metadata subset fl_collated = collate_results(  these_samples_metadata = get_gambl_metadata(    seq_type_filter = \"genome\") %>%     dplyr::filter(pathology == \"FL\")) #> Using the bundled collated results in GAMBLR.data... #> Using the bundled metadata in GAMBLR.data...  #horizontally expand a metadata subset with collated results fl_meta_collated = collate_results(  join_with_full_metadata = TRUE,   these_samples_metadata = get_gambl_metadata(    seq_type_filter = \"genome\") %>%     dplyr::filter(pathology == \"FL\")) #> Using the bundled collated results in GAMBLR.data... #> Using the bundled metadata in GAMBLR.data... #> Joining with `by = join_by(sample_id, study)`  #horizontally expand all available metadata with collated results all_meta_collated = collate_results(join_with_full_metadata = TRUE) #> Using the bundled collated results in GAMBLR.data... #> Using the bundled metadata in GAMBLR.data... #> Joining with `by = join_by(sample_id, study)`"},{"path":"https://morinlab.github.io/GAMBLR.open/reference/get_all_coding_ssm.html","id":null,"dir":"Reference","previous_headings":"","what":"Get all Coding SSMs — get_all_coding_ssm","title":"Get all Coding SSMs — get_all_coding_ssm","text":"Retrieve coding SSMs GAMBL MAF-like format, regardless seq_type.","code":""},{"path":"https://morinlab.github.io/GAMBLR.open/reference/get_all_coding_ssm.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get all Coding SSMs — get_all_coding_ssm","text":"","code":"get_all_coding_ssm(   these_samples_metadata = NULL,   include_silent = FALSE,   projection = \"grch37\" )"},{"path":"https://morinlab.github.io/GAMBLR.open/reference/get_all_coding_ssm.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get all Coding SSMs — get_all_coding_ssm","text":"these_samples_metadata Supply metadata table containing sample/seq_type combinations want. include_silent set TRUE, silent/synonymous mutations coding regions also returned. projection desired genome build 'grch37' 'hg38' allowed. Default grch37","code":""},{"path":"https://morinlab.github.io/GAMBLR.open/reference/get_all_coding_ssm.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get all Coding SSMs — get_all_coding_ssm","text":"data frame containing MAF data columns (one row per mutation).","code":""},{"path":"https://morinlab.github.io/GAMBLR.open/reference/get_all_coding_ssm.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Get all Coding SSMs — get_all_coding_ssm","text":"Effectively retrieve coding SSM calls one DNA seq_type. additional optional arguments, see GAMBLR.results::get_coding_ssm","code":""},{"path":"https://morinlab.github.io/GAMBLR.open/reference/get_all_coding_ssm.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get all Coding SSMs — get_all_coding_ssm","text":"","code":"library(GAMBLR.open) my_meta = get_gambl_metadata(seq_type_filter = c(\"genome\",\"capture\")) #> Using the bundled metadata in GAMBLR.data... my_meta = check_and_clean_metadata(my_meta,duplicate_action=\"keep_first\") #> Duplicate rows (keeping first occurrence) for 'sample_id' and 'seq_type' have been dropped. maf_all_seqtype = get_all_coding_ssm(my_meta)  table(maf_all_seqtype$maf_seq_type) #>  #> capture  genome  #>   57951 3171050   # most common mutations by gene and Variant_Classification dplyr::group_by(maf_all_seqtype,                 Hugo_Symbol,                 Variant_Classification) %>%    dplyr::count() %>%    dplyr::arrange(desc(n)) #> genomic_data Object #> Genome Build: grch37  #> Showing first 10 rows: #>    Hugo_Symbol Variant_Classification       n #> 1      Unknown                    IGR 1306295 #> 2        PTPRD                 Intron   20317 #> 3        IGLL5                 Intron   12050 #> 4         PCLO                 Intron    5932 #> 5        UNC5D                 Intron    5530 #> 6         BCL6                 Intron    5207 #> 7        ROBO2                 Intron    4850 #> 8         BCL2                 Intron    4737 #> 9         BCL2                  5'UTR    4728 #> 10       PTPRK                 Intron    4369"},{"path":"https://morinlab.github.io/GAMBLR.open/reference/get_ashm_count_matrix.html","id":null,"dir":"Reference","previous_headings":"","what":"Get ASHM Count Matrix. — get_ashm_count_matrix","title":"Get ASHM Count Matrix. — get_ashm_count_matrix","text":"Prepare matrix one row per sample one column per region using set hypermutated regions.","code":""},{"path":"https://morinlab.github.io/GAMBLR.open/reference/get_ashm_count_matrix.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get ASHM Count Matrix. — get_ashm_count_matrix","text":"","code":"get_ashm_count_matrix(   regions_bed,   these_samples_metadata,   this_seq_type,   projection = \"grch37\" )"},{"path":"https://morinlab.github.io/GAMBLR.open/reference/get_ashm_count_matrix.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get ASHM Count Matrix. — get_ashm_count_matrix","text":"regions_bed bed file one row region. these_samples_metadata used complete matrix. GAMBL samples used default. Provide data frame least sample_id samples using non-GAMBL data. this_seq_type seq type return results . used metadata provided these_samples_metadata. projection genome build use mutations (must match coordinate system regions avoid nonsense result)","code":""},{"path":"https://morinlab.github.io/GAMBLR.open/reference/get_ashm_count_matrix.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get ASHM Count Matrix. — get_ashm_count_matrix","text":"matrix","code":""},{"path":"https://morinlab.github.io/GAMBLR.open/reference/get_ashm_count_matrix.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Get ASHM Count Matrix. — get_ashm_count_matrix","text":"Values number mutations patient region.","code":""},{"path":"https://morinlab.github.io/GAMBLR.open/reference/get_ashm_count_matrix.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get ASHM Count Matrix. — get_ashm_count_matrix","text":"","code":"regions_bed = create_bed_data(GAMBLR.data::grch37_ashm_regions,                               fix_names=\"concat\",                               concat_cols=c(\"gene\",\"region\"),                               sep=\"-\") my_meta = get_gambl_metadata() %>% dplyr::filter(pathology==\"DLBCL\") #> Using the bundled metadata in GAMBLR.data... shm_matrix <- get_ashm_count_matrix(      regions_bed = regions_bed,      this_seq_type = \"genome\",      these_samples_metadata = my_meta ) #> Using the bundled SSM calls (.maf) calls in GAMBLR.data... #> Using the bundled SSM calls (.maf) calls in GAMBLR.data... #> id_ease: WARNING! 1783 samples in the provided metadata were removed because their seq types are not the same as in the `set_type` argument. Use `verbose = TRUE` to see their IDs. #> Running in default mode of any... #> Joining with `by = join_by(sample_id, region_name)` head(shm_matrix[,c(1:12)]) #>           AICDA-TSS BACH2-TSS BCL11A-TSS BCL2-TSS BCL2-intron BCL6-Intergenic-1 #> 02-13135T         0         1          0       20           0                 0 #> 02-20170T         1         1          0        0           0                 0 #> 02-22991T         0         0          0        0           0                 0 #> 04-24937T         0         2         15        4           0                 0 #> 04-28140T         0         0          0        0           0                 0 #> 04-29264T         0         0          0        0           0                 0 #>           BCL6-Intergenic-2 BCL6-Intergenic-3 BCL6-Intergenic-4 #> 02-13135T                 0                 1                 0 #> 02-20170T                 0                 2                 0 #> 02-22991T                 0                 0                 1 #> 04-24937T                 0                 1                 0 #> 04-28140T                 0                 0                 0 #> 04-29264T                 0                 2                 2 #>           BCL6-Intergenic-5 BCL6-TSS BCL7A-TSS #> 02-13135T                 0        4         3 #> 02-20170T                 0        2         0 #> 02-22991T                 0        1         0 #> 04-24937T                 0       12         2 #> 04-28140T                 0        0         0 #> 04-29264T                 1        3         3 if (FALSE) { # \\dontrun{ #this example should fail because the regions_bed is not hg38 shm_matrix <- get_ashm_count_matrix(regions_bed=regions_bed,                             this_seq_type = \"genome\",                             these_samples_metadata = my_meta,                             projection = \"hg38\") # Error in get_ashm_count_matrix( # Your projection argument does not match the genome_build of regions_bed } # } # format the name column to include the coordinates instead of the gene regions_bed = create_bed_data(GAMBLR.data::hg38_ashm_regions,                            fix_names=\"concat\",                            concat_cols=c(\"chr_name\",\"hg38_start\",\"hg38_end\"),                            sep=\"-\")   matrix_hg38 <- get_ashm_count_matrix(regions_bed=regions_bed,                                       this_seq_type = \"genome\",                                       these_samples_metadata = my_meta,                                       projection = \"hg38\") #> Using the bundled SSM calls (.maf) calls in GAMBLR.data... #> Using the bundled SSM calls (.maf) calls in GAMBLR.data... #> id_ease: WARNING! 1783 samples in the provided metadata were removed because their seq types are not the same as in the `set_type` argument. Use `verbose = TRUE` to see their IDs. #> Running in default mode of any... #> Joining with `by = join_by(sample_id, region_name)` print(dim(matrix_hg38)) #> [1] 2312  129 print(head(matrix_hg38[,c(1:8)])) #>           chr1-203305570-203306650 chr1-226732862-226740184 #> 02-13135T                        0                        0 #> 02-20170T                        0                        0 #> 02-22991T                        0                        0 #> 04-24937T                       21                        0 #> 04-28140T                        0                        0 #> 04-29264T                        1                        0 #>           chr1-226733387-226740281 chr1-28506039-28509827 #> 02-13135T                        0                      0 #> 02-20170T                        0                      0 #> 02-22991T                        0                      0 #> 04-24937T                        0                      0 #> 04-28140T                        0                      0 #> 04-29264T                        0                      0 #>           chr1-30756165-30759164 chr11-102317439-102319346 #> 02-13135T                      0                         0 #> 02-20170T                      0                         1 #> 02-22991T                      0                         0 #> 04-24937T                      0                         4 #> 04-28140T                      0                         0 #> 04-29264T                      0                         0 #>           chr11-111377353-111379499 chr11-118883749-118885805 #> 02-13135T                         0                         0 #> 02-20170T                         0                         0 #> 02-22991T                         0                         0 #> 04-24937T                         1                         0 #> 04-28140T                         0                         0 #> 04-29264T                         1                         0"},{"path":"https://morinlab.github.io/GAMBLR.open/reference/get_cn_segments.html","id":null,"dir":"Reference","previous_headings":"","what":"Get CN Segments. — get_cn_segments","title":"Get CN Segments. — get_cn_segments","text":"Retrieve copy number segments GAMBL outputs","code":""},{"path":"https://morinlab.github.io/GAMBLR.open/reference/get_cn_segments.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get CN Segments. — get_cn_segments","text":"","code":"get_cn_segments(   these_samples_metadata,   projection = \"grch37\",   this_seq_type,   ... )"},{"path":"https://morinlab.github.io/GAMBLR.open/reference/get_cn_segments.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get CN Segments. — get_cn_segments","text":"these_samples_metadata User must provide metadata table restrict data samples table. metadata also ensures proper handling duplicate sample_id across seq_types ensures seq_type metadata faithfully represents seq_type data projection Desired genome coordinate system returned CN segments. Default \"grch37\". this_seq_type Deprecated. ... Additional parameters passed function.","code":""},{"path":"https://morinlab.github.io/GAMBLR.open/reference/get_cn_segments.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get CN Segments. — get_cn_segments","text":"data frame CN segments specified region.","code":""},{"path":"https://morinlab.github.io/GAMBLR.open/reference/get_cn_segments.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Get CN Segments. — get_cn_segments","text":"function merely loads returns seg_data available projection (genome build)","code":""},{"path":"https://morinlab.github.io/GAMBLR.open/reference/get_cn_segments.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get CN Segments. — get_cn_segments","text":"","code":"# Example for the capture samples:  genome_metadata = get_gambl_metadata(seq_type_filter=\"genome\") #> Using the bundled metadata in GAMBLR.data...  genome_segments_hg38 = get_cn_segments(                              these_samples_metadata = genome_metadata,                              projection=\"hg38\") #> Using the bundled CN segments (.seg) calls in GAMBLR.data..."},{"path":"https://morinlab.github.io/GAMBLR.open/reference/get_cnv_and_ssm_status.html","id":null,"dir":"Reference","previous_headings":"","what":"Get CNV and coding SSM combined status — get_cnv_and_ssm_status","title":"Get CNV and coding SSM combined status — get_cnv_and_ssm_status","text":"specified chromosome region (gene name), return status 1 copy number (CN) state non-neutral, .e. different 2, region contains coding simple somatic mutation (SSM).","code":""},{"path":"https://morinlab.github.io/GAMBLR.open/reference/get_cnv_and_ssm_status.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get CNV and coding SSM combined status — get_cnv_and_ssm_status","text":"","code":"get_cnv_and_ssm_status(   genes_and_cn_threshs,   these_samples_metadata,   maf_df,   seg_data,   cn_matrix,   only_cnv = \"none\",   genome_build = \"grch37\",   include_hotspots = TRUE,   review_hotspots = TRUE,   adjust_for_ploidy = TRUE,   include_silent = FALSE,   this_seq_type )"},{"path":"https://morinlab.github.io/GAMBLR.open/reference/get_cnv_and_ssm_status.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get CNV and coding SSM combined status — get_cnv_and_ssm_status","text":"genes_and_cn_threshs data frame columns \"gene_id\" \"cn_thresh\". \"gene_id\" column stores gene symbols (characters) determine regions return CNV /coding SSM status. \"cn_thresh\" column stores integers mean maximum minimum CN states return status 1 (contains CNV) respective gene. integer 2 (neutral CN state diploids), taken maximum (gene consider tumor suppressor); 2, minimum (oncogene); equal 2, consider CNV return status. these_samples_metadata metadata samples interest included returned matrix. Can created get_gambl_metadata function. maf_df Optional data frame containing coding variants samples (.e. output get_all_coding_ssm) seg_data Optionally provide function data frame segments used instead GAMBL flatfiles cn_matrix Instead seg_data, can provide matrix CN values samples metadata. See GAMBLR.utils::segmented_data_to_cn_matrix information create matrix. only_cnv vector gene names indicating genes CNV status considered, ignoring SSM status. Set argument \"\" \"none\" (default) apply behavior none genes, respectively. genome_build Reference genome build. Possible values \"grch37\" (default) \"hg38\". include_hotspots Logical parameter indicating whether hotspots object also tabulated. Default TRUE. review_hotspots Logical parameter indicating whether hotspots object reviewed include functionally relevant mutations rare lymphoma-related genes. Default TRUE. adjust_for_ploidy Set FALSE disable scaling CN values genome-wide average per sample include_silent Set TRUE want Synonymous mutations also considered this_seq_type Deprecated","code":""},{"path":"https://morinlab.github.io/GAMBLR.open/reference/get_cnv_and_ssm_status.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get CNV and coding SSM combined status — get_cnv_and_ssm_status","text":"data frame CNV SSM combined status.","code":""},{"path":"https://morinlab.github.io/GAMBLR.open/reference/get_cnv_and_ssm_status.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Get CNV and coding SSM combined status — get_cnv_and_ssm_status","text":"user can choose regions intended return copy number variation (CNV) status, coding SSM status, least presence one . behavior controlled arguments genes_and_cn_threshs (column cn_thresh) only_cnv. function internally calls get_cn_states, get_ssm_by_samples get_coding_ssm_statusfunctions. Therefore, many arguments assigned functions. needed, see documentation functions information. case returning NA values, due get_cn_segments function able internally return copy number segments specified chromosome region.","code":""},{"path":"https://morinlab.github.io/GAMBLR.open/reference/get_cnv_and_ssm_status.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get CNV and coding SSM combined status — get_cnv_and_ssm_status","text":"","code":"library(GAMBLR.open) # Get sample metadata including a mix of seq_type all_types_meta = suppressMessages(get_gambl_metadata()) %>%              dplyr::filter(pathology == \"BL\") dplyr::group_by(all_types_meta, seq_type) %>%       dplyr::summarize(n=dplyr::n()) #> # A tibble: 1 × 2 #>   seq_type     n #>   <chr>    <int> #> 1 genome     234  # For MYC and SYNCRIP, return CNV and SSM combined status; for MIR17HG,  # return only CNV status; for CCND3 return only SSM status genes_and_cn_threshs = data.frame(   gene_id=c(\"MYC\", \"MIR17HG\", \"CCND3\",\"ID3\",\"DDX3X\", \"SYNCRIP\"),   cn_thresh=c(3, 3, 2, 2, 2, 1) )  genome_cnv_ssm_status = suppressMessages(get_cnv_and_ssm_status(                            genes_and_cn_threshs,                            genome_build = \"hg38\",                            dplyr::filter(all_types_meta,seq_type==\"genome\"),                            only_cnv = \"MIR17HG\"))  print(dim(genome_cnv_ssm_status))     #> [1] 234   6 head(genome_cnv_ssm_status)    #>                           MYC MIR17HG CCND3 ID3 DDX3X SYNCRIP #> Akata                       1       1     0   1     1       0 #> BL2                         1       1     0   1     1       0 #> BL30                        1       1     0   1     1       0 #> BL41                        1       1     1   1     0       0 #> BL70                        1       1     1   1     1       0 #> BLGSP-71-06-00001-01A-11D   0       0     1   1     1       0 colSums(genome_cnv_ssm_status) #>     MYC MIR17HG   CCND3     ID3   DDX3X SYNCRIP  #>     172      38      68     112     118      12          all_path_meta = suppressMessages(get_gambl_metadata()) all_path_meta = check_and_clean_metadata(all_path_meta,duplicate_action=\"keep_first\") #> Duplicate rows (keeping first occurrence) for 'sample_id' and 'seq_type' have been dropped. dplyr::group_by(all_types_meta, seq_type) %>%       dplyr::summarize(n=dplyr::n())              #> # A tibble: 1 × 2 #>   seq_type     n #>   <chr>    <int> #> 1 genome     234 all_pathology_status = suppressMessages(get_cnv_and_ssm_status(                            genes_and_cn_threshs,                            all_path_meta,                            genome_build = \"grch37\",                            only_cnv = \"MIR17HG\"))  print(dim(all_pathology_status))    #> [1] 448   6 head(all_pathology_status) #>           MYC MIR17HG CCND3 ID3 DDX3X SYNCRIP #> 01-20260T   1       0     0   0     0       0 #> 02-13135T   1       0     0   0     1       0 #> 02-20170T   0       1     0   0     0       1 #> 02-22991T   1       0     0   0     0       0 #> 03-34157T   0       0     0   0     0       0 #> 04-24029T   0       0     0   0     0       0 colSums(all_pathology_status) #>     MYC MIR17HG   CCND3     ID3   DDX3X SYNCRIP  #>     114      62      25       5      25     134"},{"path":"https://morinlab.github.io/GAMBLR.open/reference/get_coding_ssm.html","id":null,"dir":"Reference","previous_headings":"","what":"Get Coding SSMs — get_coding_ssm","title":"Get Coding SSMs — get_coding_ssm","text":"Convenience function loading coding Simple Somatic Mutations (SSM) bundled data GAMBLR.data::sample_data.","code":""},{"path":"https://morinlab.github.io/GAMBLR.open/reference/get_coding_ssm.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get Coding SSMs — get_coding_ssm","text":"","code":"get_coding_ssm(   these_sample_ids = NULL,   these_samples_metadata = NULL,   projection = \"grch37\",   this_seq_type = \"genome\",   tool_name = \"slms-3\",   min_read_support = 3,   include_silent = TRUE,   verbose = FALSE,   ... )"},{"path":"https://morinlab.github.io/GAMBLR.open/reference/get_coding_ssm.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get Coding SSMs — get_coding_ssm","text":"these_sample_ids Optional, vector multiple sample_id (single sample ID string) want results . these_samples_metadata Optional, metadata table (sample IDs column) subset return . provided (these_sample_ids provided), function return samples specified seq_type metadata. projection Reference genome build coordinates MAF file. default grch37. this_seq_type this_seq_type want back, default genome. tool_name Optionally specify tool report variant . default slms-3, also supports \"publication\" return exact variants reported original papers. min_read_support returns variants least many reads t_alt_count. include_silent Logical parameter indicating whether include silent mutations coding mutations. Default TRUE. verbose Set FALSE minimize output console. Default TRUE. parameter also dictates verbosity helper function internally called inside main function. ... additional parameters.","code":""},{"path":"https://morinlab.github.io/GAMBLR.open/reference/get_coding_ssm.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get Coding SSMs — get_coding_ssm","text":"data frame","code":""},{"path":"https://morinlab.github.io/GAMBLR.open/reference/get_coding_ssm.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Get Coding SSMs — get_coding_ssm","text":"\"bare bones\" function developed retrieve coding SSM calls non-GSC-users. Effectively retrieve coding SSM calls. Multiple filtering parameters available function. information implement filtering parameters, refer parameter descriptions well examples vignettes. function depends bundled sample data package.","code":""},{"path":"https://morinlab.github.io/GAMBLR.open/reference/get_coding_ssm.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get Coding SSMs — get_coding_ssm","text":"","code":"# Get mutations from exome data originally aligned to grch37 ssm_exomes_grch37 = get_coding_ssm(projection = \"grch37\",this_seq_type = \"capture\") #> Using the bundled SSM calls (.maf) calls in GAMBLR.data... #> Using the bundled metadata in GAMBLR.data... #> after linking with metadata, we have mutations from 1787 samples  # Get mutations from genome data, hg38 build ssm_genomes_hg38 = get_coding_ssm(projection = \"hg38\",this_seq_type = \"genome\") #> Using the bundled SSM calls (.maf) calls in GAMBLR.data... #> Using the bundled metadata in GAMBLR.data... #> after linking with metadata, we have mutations from 860 samples"},{"path":"https://morinlab.github.io/GAMBLR.open/reference/get_coding_ssm_status.html","id":null,"dir":"Reference","previous_headings":"","what":"Get Coding SSM Status. — get_coding_ssm_status","title":"Get Coding SSM Status. — get_coding_ssm_status","text":"Tabulate mutation status (SSM) set genes.","code":""},{"path":"https://morinlab.github.io/GAMBLR.open/reference/get_coding_ssm_status.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get Coding SSM Status. — get_coding_ssm_status","text":"","code":"get_coding_ssm_status(   gene_symbols,   these_samples_metadata,   maf_data,   include_hotspots = TRUE,   keep_multihit_hotspot = FALSE,   review_hotspots = TRUE,   genes_of_interest = c(\"FOXO1\", \"MYD88\", \"CREBBP\"),   genome_build,   include_silent = FALSE,   include_silent_genes,   ... )"},{"path":"https://morinlab.github.io/GAMBLR.open/reference/get_coding_ssm_status.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get Coding SSM Status. — get_coding_ssm_status","text":"gene_symbols vector gene symbols mutation status tabulated. provided, lymphoma genes returned default. these_samples_metadata metadata samples interest included returned matrix. column \"sample_id\" required. provided, example metadata used default. maf_data data frame maf format. Must grch37 projection. include_hotspots Logical parameter indicating whether hotspots object also tabulated. Default TRUE. keep_multihit_hotspot Logical parameter indicating whether keep gene annotation mutated gene hot spot non-hotspot mutation. Default FALSE. set TRUE, report number non-hotspot mutations instead tabulating just mutation presence. review_hotspots Logical parameter indicating whether hotspots object reviewed include functionally relevant mutations rare lymphoma-related genes. Default TRUE. genes_of_interest vector genes hotspot review. Currently FOXO1, MYD88, CREBBP supported. genome_build Reference genome build coordinates MAF file. default inferred maf_data. include_silent Logical parameter indicating whether include silent mutations coding mutations. Default FALSE. include_silent_genes Optionally, provide list genes Silent variants considered. provided, Silent variants genes included regardless include_silent argument. ... parameter. parameters ignored.","code":""},{"path":"https://morinlab.github.io/GAMBLR.open/reference/get_coding_ssm_status.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get Coding SSM Status. — get_coding_ssm_status","text":"data frame tabulated mutation status.","code":""},{"path":"https://morinlab.github.io/GAMBLR.open/reference/get_coding_ssm_status.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Get Coding SSM Status. — get_coding_ssm_status","text":"function takes data frame (MAF-like format) converts binary one-hot encoded matrix mutation status either set user-specified genes (via gene_symbols) , genes provided, default lymphoma genes. default behaviour assign gene/sample_id combination mutated protein coding mutation sample MAF can configured use synonymous variants (via include_silent_genes) (via include_silent) genes. function also filtering convenience parameters giving user full control return. information, refer parameter descriptions examples. Currently grch37 genome build supported hotspot annotation review version function.","code":""},{"path":"https://morinlab.github.io/GAMBLR.open/reference/get_coding_ssm_status.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get Coding SSM Status. — get_coding_ssm_status","text":"","code":"coding_tabulated_df = get_coding_ssm_status(  maf_data = get_coding_ssm(),  gene_symbols = c(\"EZH2\",\"KMT2D\",\"CREBBP\",\"MYC\") ) #> Using the bundled SSM calls (.maf) calls in GAMBLR.data... #> Using the bundled metadata in GAMBLR.data... #> after linking with metadata, we have mutations from 817 samples #> Using the bundled metadata in GAMBLR.data... #> Joining with `by = join_by(sample_id)` #> annotating hotspots #> Joining with `by = join_by(sample_id)` #> CREBBPHOTSPOT #> OK #> MYD88HOTSPOT #> FOXO1HOTSPOT  head(coding_tabulated_df) #>                   sample_id KMT2D CREBBP EZH2 MYC CREBBPHOTSPOT MYD88HOTSPOT #> 1                     Akata     0      0    0   1             0            0 #> 2                       BL2     0      0    0   1             0            1 #> 3                      BL30     1      0    0   1             0            0 #> 4                      BL41     0      0    0   1             0            0 #> 5                      BL70     0      0    0   1             0            0 #> 6 BLGSP-71-06-00001-01A-11D     0      0    0   0             0            0 #>   FOXO1HOTSPOT #> 1            1 #> 2            1 #> 3            0 #> 4            0 #> 5            0 #> 6            1  #all lymphoma genes from bundled NHL gene list coding_tabulated_df = get_coding_ssm_status(                            maf_data = get_coding_ssm()                       ) #> Using the bundled SSM calls (.maf) calls in GAMBLR.data... #> Using the bundled metadata in GAMBLR.data... #> after linking with metadata, we have mutations from 817 samples #> No gene_symbols provided, defaulting to all lymphoma genes. #> Using the bundled metadata in GAMBLR.data... #> Joining with `by = join_by(sample_id)` #> annotating hotspots #> Joining with `by = join_by(sample_id)` #> CREBBPHOTSPOT #> OK #> MYD88HOTSPOT #> OK #> FOXO1HOTSPOT #> OK head(coding_tabulated_df[,c(1:10)]) #>                   sample_id TNFRSF14 SPEN CARD11 KMT2D BCL7A FOXO1 BCL2 BTK #> 1                     Akata        0    1      0     0     0     0    0   0 #> 2                       BL2        0    0      0     0     0     0    0   0 #> 3                      BL30        0    0      0     1     0     0    0   0 #> 4                      BL41        0    0      0     0     0     0    0   0 #> 5                      BL70        0    0      0     0     0     0    0   0 #> 6 BLGSP-71-06-00001-01A-11D        0    0      0     0     0     0    0   0 #>   CREBBP #> 1      0 #> 2      0 #> 3      0 #> 4      0 #> 5      0 #> 6      0 if (FALSE) { # \\dontrun{ #this example would fail because hg38 is not supported by this function (yet) coding_tabulated_df = get_coding_ssm_status(maf_data=                         get_coding_ssm(projection = \"hg38\")) # Error in get_coding_ssm_status(maf_data = get_coding_ssm(projection = \"hg38\")) :  # Currently only grch37 projection (hg19 genome build) is supported. } # }"},{"path":"https://morinlab.github.io/GAMBLR.open/reference/get_gambl_metadata.html","id":null,"dir":"Reference","previous_headings":"","what":"Get GAMBL Metadata. — get_gambl_metadata","title":"Get GAMBL Metadata. — get_gambl_metadata","text":"Convenience function loading sample metadata.","code":""},{"path":"https://morinlab.github.io/GAMBLR.open/reference/get_gambl_metadata.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get GAMBL Metadata. — get_gambl_metadata","text":"","code":"get_gambl_metadata(seq_type_filter = c(\"genome\", \"capture\"), case_set, ...)"},{"path":"https://morinlab.github.io/GAMBLR.open/reference/get_gambl_metadata.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get GAMBL Metadata. — get_gambl_metadata","text":"seq_type_filter Specify seq type want return metadata . Default \"genome\". case_set Optionally specify study details return samples particular case set. See function description supported case sets. ... additional parameters.","code":""},{"path":"https://morinlab.github.io/GAMBLR.open/reference/get_gambl_metadata.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get GAMBL Metadata. — get_gambl_metadata","text":"data frame metadata, tailored user without GSC access. compression Format original data used input analysis pipelines (cram, bam fastq) bam_available Whether file available last checked. patient_id anonymized unique identifier patient. BC samples, Res ID. sample_id unique identifier sample analyzed. seq_type assay type used produce data (one \"genome\",\"capture, \"mrna\", \"promethION\") genome_build name genome reference data aligned . cohort Name group samples added together (usually single study), often format pathology_cohort_descriptor. pathology diagnosis pathology sample time_point Timing biopsy increasing alphabetical order (= diagnosis, B = first relapse etc) ffpe_or_frozen Whether nucleic acids extracted frozen FFPE sample COO_consensus Consensus call COO different sources. DHITsig_consensus Consensus call DHIT signature status different sources. EBV_status_inf Inferred EBV status tumor lymphgen_no_cnv LymphGen label using model without CNV lymphgen_with_cnv LymphGen label using model CNV lymphgen_cnv_noA53 LymphGen label using model CNV excluding A53 class lymphgen_wright LymphGen call sample Wright et (applicable) fl_grade Grade FL samples normal_sample_id Sample id normal tissue used analysis pairing_status Matching status sample lymphgen LymphGen label molecular_BL label sample according molecular BL classifier Tumor_Sample_Barcode Duplicate sample_id simplifying joins MAF data frames pathology_rank Numeric rank consistent ordering samples pathology hiv_status HIV status sample age_group Adult_BL Pediatric_BL , specific BLGSP study sex biological sex patient, available. Allowable options: M, F, NA","code":""},{"path":"https://morinlab.github.io/GAMBLR.open/reference/get_gambl_metadata.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Get GAMBL Metadata. — get_gambl_metadata","text":"bare bones function developed retrieve metadata non-GSC-users. Specify seq type (seq_type_filter) samples want returned argument. relies bundled metadata package. Specify case_set argument retreive samples particular study. Currently supported case_sets : FL_Dreval (FL samples Dreval et al), DLBCL_Dreval (DLBCL samples Dreval et al), FL-DLBCL-study (samples Dreval et al), DLBCL_Arthur (samples Arthur et al study), DLBCL_Hilton (samples Hilton et al DLBCL Trios study), DLBCL_cell_lines (5 DLBCL cell lines), DLBCL_Chapuy (samples Chapuy et al study), DLBCL_Schmitz (samples Schmitz et al study), DLBCL_Reddy (samples Reddy et al study), DLBCL_Thomas (HTMCP DLBCLs Thomas et al study), BL_Thomas (BL samples Thomas et al study)","code":""},{"path":"https://morinlab.github.io/GAMBLR.open/reference/get_gambl_metadata.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get GAMBL Metadata. — get_gambl_metadata","text":"","code":"#return metadata for genome samples (here, the parameter is redundant because 'genome' is the default) genome_meta = get_gambl_metadata(seq_type_filter = \"genome\") #> Using the bundled metadata in GAMBLR.data...  #return metadata for capture samples. capture_meta = get_gambl_metadata(seq_type_filter = \"capture\") #> Using the bundled metadata in GAMBLR.data...  #If you want metadata for genome and capture samples you can provide a vector of seq types all_meta = get_gambl_metadata(seq_type_filter = c(\"genome\", \"capture\")) #> Using the bundled metadata in GAMBLR.data...  dplyr::group_by(all_meta,cohort,seq_type) %>%      dplyr::count() #> # A tibble: 21 × 3 #> # Groups:   cohort, seq_type [21] #>    cohort             seq_type     n #>    <chr>              <chr>    <int> #>  1 BL_Adult           genome      91 #>  2 BL_Pediatric       genome     121 #>  3 BL_cell_lines      genome      22 #>  4 DLBCL_Gascoyne     genome      21 #>  5 DLBCL_GenomeCanada genome      59 #>  6 DLBCL_HTMCP        genome      43 #>  7 DLBCL_ICGC         genome      84 #>  8 DLBCL_LSARP_Trios  capture     12 #>  9 DLBCL_LSARP_Trios  genome     142 #> 10 DLBCL_Marra        genome      38 #> # ℹ 11 more rows"},{"path":"https://morinlab.github.io/GAMBLR.open/reference/get_manta_sv.html","id":null,"dir":"Reference","previous_headings":"","what":"Get Manta SVs — get_manta_sv","title":"Get Manta SVs — get_manta_sv","text":"Retrieve Manta SVs one many samples","code":""},{"path":"https://morinlab.github.io/GAMBLR.open/reference/get_manta_sv.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get Manta SVs — get_manta_sv","text":"","code":"get_manta_sv(   these_samples_metadata = NULL,   projection = \"grch37\",   region,   min_vaf = 0.1,   min_score = 40,   pass_filters = TRUE,   verbose = FALSE,   chromosome,   qstart,   qend,   pairing_status,   these_sample_ids = NULL,   ... )"},{"path":"https://morinlab.github.io/GAMBLR.open/reference/get_manta_sv.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get Manta SVs — get_manta_sv","text":"these_samples_metadata metadata data frame limit result sample_ids within projection projection genome build. Default grch37. region Specify single region fetch SVs anchored within using format \"chrom:start-end\" min_vaf minimum tumour VAF SV returned. Default 0.1. min_score lowest Manta somatic score SV returned. Default 40. pass_filters TRUE (default) return SVs annotated PASS FILTER column. Set FALSE keep variants, regardless PASS filters. verbose Set FALSE minimize output console. Default TRUE. parameter also dictates verbose-ness helper function internally called inside main function. chromosome DEPRECATED. Use region instead. qstart DEPRECATED. Use region instead. qend DEPRECATED. Use region instead. pairing_status DEPRECATED. these_sample_ids DEPRECATED. Subset metadata supply `these_samples_metadata“ instead. ... additional parameters.","code":""},{"path":"https://morinlab.github.io/GAMBLR.open/reference/get_manta_sv.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Get Manta SVs — get_manta_sv","text":"Retrieve Manta SVs additional VCF information allow filtering high-confidence variants. get SV calls multiple samples, supply metadata table via these_samples_metadata subset samples. results restricted sample_ids within data frame. function can also restrict returned breakpoints within genomic region specified via region (chr:start-end format). Useful filtering parameters also available, use min_vaf set minimum tumour VAF SV returned min_score set lowest Manta somatic score SV returned. addition, user can chose return variants, even ones passing filter criteria. , set pass_filters = FALSE (defaults TRUE).","code":""},{"path":"https://morinlab.github.io/GAMBLR.open/reference/get_manta_sv.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get Manta SVs — get_manta_sv","text":"","code":"# lazily get every SV in the table with default quality filters all_sv <- get_manta_sv() #> Using the bundled metadata in GAMBLR.data... #> Using the bundled Manta SV (.bedpe) calls in GAMBLR.data... head(all_sv) #> genomic_data Object #> Genome Build: grch37  #> Showing first 10 rows: #>   CHROM_A   START_A     END_A CHROM_B   START_B     END_B #> 1       1 161658631 161658631       3  16509907  16509907 #> 2       1 161663959 161663959       9  37363320  37363320 #> 3       1 161663959 161663959       9  37363320  37363320 #> 4      11  65267283  65267283      14 106110907 106110907 #> 5      11  65267422  65267422      14 106110905 106110905 #> 6      13  91976545  91976545      14 106211857 106211857 #>                      manta_name SCORE STRAND_A STRAND_B tumour_sample_id #> 1      MantaBND:21171:0:1:0:0:0   133        +        +         FL2002T1 #> 2     MantaBND:206628:0:1:0:0:0   122        +        +  09-15842_tumorA #> 3     MantaBND:195941:0:1:0:0:0   151        +        +  09-15842_tumorB #> 4   MantaBND:152220:0:1:0:0:0:0    88        +        -        15-38154T #> 5   MantaBND:152220:0:1:0:0:0:0   135        -        +        15-38154T #> 6 MantaBND:18:59794:59817:0:1:0    90        -        +        15-31924T #>   normal_sample_id VAF_tumour  DP pair_status FILTER #> 1          FL2002N      0.331 127     matched   PASS #> 2  09-15842_normal      0.281 196     matched   PASS #> 3  09-15842_normal      0.364 187     matched   PASS #> 4        15-38154N      0.150 167     matched   PASS #> 5        15-38154N      0.290 169     matched   PASS #> 6        15-31924N      0.365  85     matched   PASS  # get all SVs for just one cohort cohort_meta = suppressMessages(get_gambl_metadata()) %>%                dplyr::filter(cohort == \"DLBCL_cell_lines\")  some_sv <- get_manta_sv(these_samples_metadata = cohort_meta, verbose=FALSE) #> Using the bundled Manta SV (.bedpe) calls in GAMBLR.data... head(some_sv) #> genomic_data Object #> Genome Build: grch37  #> Showing first 10 rows: #>   CHROM_A   START_A     END_A CHROM_B  START_B    END_B #> 1      14 106329462 106329462      18 60774579 60774579 #> 2      14 106329465 106329465      18 60793497 60793497 #> 3      14 106330466 106330466      18 60793914 60793914 #> 4      14 106349765 106349765      18 60793914 60793914 #> 5      14 106379091 106379091      18 60793492 60793492 #> 6      14 106380227 106380227      18 60774578 60774578 #>                  manta_name SCORE STRAND_A STRAND_B tumour_sample_id #> 1 MantaBND:220769:1:2:0:0:0   134        +        -        SU-DHL-10 #> 2 MantaBND:194451:1:2:0:0:0   103        +        -           DOHH-2 #> 3 MantaBND:217561:1:2:0:0:0   182        +        -         SU-DHL-4 #> 4 MantaBND:217561:0:1:0:0:0   198        -        +         SU-DHL-4 #> 5 MantaBND:194451:0:1:0:0:0    91        -        +           DOHH-2 #> 6 MantaBND:220769:0:1:0:0:0   169        -        +        SU-DHL-10 #>   normal_sample_id VAF_tumour DP pair_status FILTER #> 1        14-11247N      0.318 66   unmatched   PASS #> 2        14-11247N      0.290 69   unmatched   PASS #> 3        14-11247N      0.474 57   unmatched   PASS #> 4        14-11247N      0.500 62   unmatched   PASS #> 5        14-11247N      0.300 60   unmatched   PASS #> 6        14-11247N      0.578 45   unmatched   PASS nrow(some_sv) #> [1] 13  # get the SVs in a region around MYC # WARNING: This is not the best way to find MYC SVs. # Use annotate_sv on the full SV set instead. myc_region_hg38 = \"chr8:127710883-127761821\" myc_region_grch37 = \"8:128723128-128774067\"  hg38_myc_locus_sv <- get_manta_sv(region = myc_region_hg38,                                 projection = \"hg38\",                                 verbose = FALSE) #> Using the bundled metadata in GAMBLR.data... #> Using the bundled Manta SV (.bedpe) calls in GAMBLR.data... head(hg38_myc_locus_sv) #> genomic_data Object #> Genome Build: hg38  #> Showing first 10 rows: #>   CHROM_A   START_A     END_A CHROM_B   START_B     END_B #> 1    chr2  88860304  88860306    chr8 127751936 127751938 #> 2    chr2  88860417  88860417    chr8 127751955 127751955 #> 3    chr2  88861500  88861500    chr8 127748752 127748752 #> 4    chr3 187811601 187811601    chr8 127745649 127745649 #> 5    chr8 127741233 127741234   chr12  25049104  25049105 #> 6    chr8 127713694 127713694   chr14 105857950 105857950 #>                     manta_name SCORE STRAND_A STRAND_B #> 1  MantaBND:194837:0:1:0:0:0:0   102        +        + #> 2  MantaBND:194837:0:1:0:0:0:0    73        -        - #> 3   MantaBND:1102030:0:1:0:0:0    89        +        + #> 4     MantaBND:48510:0:2:0:0:0   106        -        + #> 5    MantaBND:174836:0:1:0:0:0   219        +        + #> 6 MantaBND:1:10030:23823:0:0:0   109        -        + #>            tumour_sample_id          normal_sample_id VAF_tumour  DP #> 1 BLGSP-71-27-00414-01A-01E BLGSP-71-27-00414-10A-01D      0.171 280 #> 2 BLGSP-71-27-00414-01A-01E BLGSP-71-27-00414-10A-01D      0.117 230 #> 3 BLGSP-71-30-00647-01A-01E BLGSP-71-06-00286-99A-01D      0.283  46 #> 4                  FL1008T2                   FL1008N      0.171 245 #> 5                  FL1018T2                   FL1018N      0.323 288 #> 6 BLGSP-71-06-00280-01A-01D BLGSP-71-06-00280-99A-01D      0.272 235 #>   pair_status FILTER #> 1     matched   PASS #> 2     matched   PASS #> 3   unmatched   PASS #> 4     matched   PASS #> 5     matched   PASS #> 6     matched   PASS nrow(hg38_myc_locus_sv) #> [1] 260  incorrect_myc_locus_sv <- get_manta_sv(region = myc_region_grch37,                                 projection = \"hg38\",                                 verbose = FALSE) #> Using the bundled metadata in GAMBLR.data... #> Using the bundled Manta SV (.bedpe) calls in GAMBLR.data... head(incorrect_myc_locus_sv) #> genomic_data Object #> Genome Build: hg38  #> Showing first 10 rows: #>  [1] CHROM_A          START_A          END_A            CHROM_B          #>  [5] START_B          END_B            manta_name       SCORE            #>  [9] STRAND_A         STRAND_B         tumour_sample_id normal_sample_id #> [13] VAF_tumour       DP               pair_status      FILTER           #> <0 rows> (or 0-length row.names) nrow(incorrect_myc_locus_sv) #> [1] 0 # The effect of specifying the wrong coordinate is evident  # Despite potentially being incomplete, we can nonetheless # annotate these directly for more details annotated_myc_hg38 = suppressMessages(          annotate_sv(hg38_myc_locus_sv, genome_build = \"hg38\") ) head(annotated_myc_hg38) #>   chrom1    start1      end1 chrom2    start2      end2 name score strand1 #> 1      8 127741233 127741234     12  25049104  25049105    .   219       + #> 2      8 127713694 127713694     14 105857950 105857950    .   109       - #> 3      8 127716025 127716934     14 105862581 105863164    .   112       + #> 4      8 127716523 127716523     14 105862757 105862757    .   173       - #> 5      8 127718148 127718148     14 105860256 105860256    .   152       + #> 6      8 127718150 127718150     14 105860564 105860564    .   163       - #>   strand2          tumour_sample_id gene partner   fusion #> 1       +                  FL1018T2  MYC    LRMP LRMP-MYC #> 2       + BLGSP-71-06-00280-01A-01D  MYC     IGH  IGH-MYC #> 3       - BLGSP-71-06-00084-01A-01D  MYC     IGH  IGH-MYC #> 4       + BLGSP-71-06-00084-01A-01D  MYC     IGH  IGH-MYC #> 5       - BLGSP-71-08-00036-01A-01D  MYC     IGH  IGH-MYC #> 6       + BLGSP-71-08-00036-01A-01D  MYC     IGH  IGH-MYC table(annotated_myc_hg38$partner) #>  #> BCL6  DMD  IGH  IGK  IGL LRMP PAX5  #>    1    2  247    3    2    1    4  # The usual MYC partners are seen here"},{"path":"https://morinlab.github.io/GAMBLR.open/reference/get_sample_cn_segments.html","id":null,"dir":"Reference","previous_headings":"","what":"Get Sample CN Segments. — get_sample_cn_segments","title":"Get Sample CN Segments. — get_sample_cn_segments","text":"Get segments single (multiple) sample_id(s).","code":""},{"path":"https://morinlab.github.io/GAMBLR.open/reference/get_sample_cn_segments.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get Sample CN Segments. — get_sample_cn_segments","text":"","code":"get_sample_cn_segments(   these_sample_ids = NULL,   these_samples_metadata = NULL,   projection = \"grch37\",   this_seq_type = \"genome\",   with_chr_prefix = FALSE,   streamlined = FALSE,   verbose = FALSE,   ... )"},{"path":"https://morinlab.github.io/GAMBLR.open/reference/get_sample_cn_segments.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get Sample CN Segments. — get_sample_cn_segments","text":"these_sample_ids Optional, vector multiple sample_id (single sample ID string) want results . these_samples_metadata Optional, metadata table (sample IDs column) subset return . provided (these_sample_ids provided), function return samples specified seq_type metadata. projection Selected genome projection returned CN segments. Default \"grch37\". this_seq_type Seq type returned CN segments. Default genome. with_chr_prefix Set TRUE add chr prefix chromosome names. Default FALSE. streamlined Return minimal output rather full details. Default FALSE. verbose Set FALSE minimize output console. Default TRUE. parameter also dictates verbosity helper function internally called inside main function. ... additional parameters.","code":""},{"path":"https://morinlab.github.io/GAMBLR.open/reference/get_sample_cn_segments.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get Sample CN Segments. — get_sample_cn_segments","text":"data frame segments specific multiple sample ID(s).","code":""},{"path":"https://morinlab.github.io/GAMBLR.open/reference/get_sample_cn_segments.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Get Sample CN Segments. — get_sample_cn_segments","text":"function returns CN segments. works single sample multiple samples. Specify sample IDs interested these_sample_ids (vector characters), call function these_samples_metadata already metadata table subset sample IDs interest. none parameters specified, function return CN segments available samples (get_gambl_metadata). Note, . function internally calls id_ease dealing sample IDs metadata tables.","code":""},{"path":"https://morinlab.github.io/GAMBLR.open/reference/get_sample_cn_segments.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get Sample CN Segments. — get_sample_cn_segments","text":"","code":"#load pacakges library(dplyr)  #get CN segments for one sample dohh2_segs = get_sample_cn_segments(these_sample_ids = \"DOHH-2\",                                     projection = \"hg38\",                                     streamlined = TRUE) #> Using the bundled CN segments (.seg) calls in GAMBLR.data... #> Using the bundled metadata in GAMBLR.data...  #get CN segments for DLBCL cell line cell_line_meta = GAMBLR.data::sample_data$meta %>%   dplyr::filter(cohort == \"DLBCL_cell_lines\")  dlbcl_segs = get_sample_cn_segments(these_samples_metadata = cell_line_meta,                                     streamlined = TRUE) #> Using the bundled CN segments (.seg) calls in GAMBLR.data..."},{"path":"https://morinlab.github.io/GAMBLR.open/reference/get_ssm_by_patients.html","id":null,"dir":"Reference","previous_headings":"","what":"Get SSM By Patients. — get_ssm_by_patients","title":"Get SSM By Patients. — get_ssm_by_patients","text":"Get MAF-format data frame one patient.","code":""},{"path":"https://morinlab.github.io/GAMBLR.open/reference/get_ssm_by_patients.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get SSM By Patients. — get_ssm_by_patients","text":"","code":"get_ssm_by_patients(   these_patient_ids,   these_samples_metadata,   projection = \"grch37\",   this_seq_type = \"genome\",   tool_name = \"slms-3\",   this_study,   verbose = FALSE,   ... )"},{"path":"https://morinlab.github.io/GAMBLR.open/reference/get_ssm_by_patients.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get SSM By Patients. — get_ssm_by_patients","text":"these_patient_ids vector patient IDs want results . user can also use metadata table subset patient IDs interest (see these_samples_metadata). these_samples_metadata metadata subset contain rows corresponding patients interest. vector patient IDs missing (these_patient_ids), function default patient IDs metadata table given parameter. projection Obtain variants projected reference (one grch37 hg38). Default grch37. this_seq_type seq type want results . Default \"genome\". tool_name Optionally specify tool report variant . default slms-3, also supports \"publication\" return exact variants reported original papers. this_study Optionally specify first name author paper variants returned . parameter can either vector indexes (integer) vector characters (matching columns MAF). verbose Set FALSE minimize output console. Default TRUE. parameter also dictates verbosity helper function internally called inside main function. ... additional parameters.","code":""},{"path":"https://morinlab.github.io/GAMBLR.open/reference/get_ssm_by_patients.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get SSM By Patients. — get_ssm_by_patients","text":"data frame SSM calls selected patients MAF format.","code":""},{"path":"https://morinlab.github.io/GAMBLR.open/reference/get_ssm_by_patients.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Get SSM By Patients. — get_ssm_by_patients","text":"function returns variants set patients. function internally calls get_ssm_by_samples. Thus, main contents function wrangle provided patient IDs, corresponding sample IDs can provided internal call get_ssm_by_samples. function expects either vector patient IDs (these_patients_ids) already subset metadata table (these_samples_metadata).","code":""},{"path":"https://morinlab.github.io/GAMBLR.open/reference/get_ssm_by_patients.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get SSM By Patients. — get_ssm_by_patients","text":"","code":"# Lets find which patient_id occur more than once in the metadata first my_ids = get_gambl_metadata(seq_type_filter = c(\"genome\",\"capture\")) %>%              dplyr::group_by(patient_id) %>%              dplyr::tally() %>%              dplyr::filter(n>1) %>%              dplyr::pull(patient_id) #> Using the bundled metadata in GAMBLR.data...  #now let's get every SSM for all samples from these patients patient_maf = get_ssm_by_patients(these_patient_ids = my_ids) #> Using the bundled metadata in GAMBLR.data... #> Patient IDs and metadata were provided, this function will resort to all available patient IDs in the provided metadata. #> Using the bundled SSM calls (.maf) calls in GAMBLR.data... patient_maf %>% dplyr::group_by(Tumor_Sample_Barcode) %>%                  dplyr::count() %>% head() #> genomic_data Object #> Genome Build: grch37  #> Showing first 10 rows: #>   Tumor_Sample_Barcode   n #> 1      00-14595_tumorA 476 #> 2      00-14595_tumorB 596 #> 3      00-14595_tumorC 679 #> 4      00-14595_tumorD 679 #> 5      00-15201_tumorA 208 #> 6      00-15201_tumorB 142"},{"path":"https://morinlab.github.io/GAMBLR.open/reference/get_ssm_by_region.html","id":null,"dir":"Reference","previous_headings":"","what":"Get SSM By Region. — get_ssm_by_region","title":"Get SSM By Region. — get_ssm_by_region","text":"Retrieve SSMs GAMBL database within single genomic coordinate range.","code":""},{"path":"https://morinlab.github.io/GAMBLR.open/reference/get_ssm_by_region.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get SSM By Region. — get_ssm_by_region","text":"","code":"get_ssm_by_region(   these_sample_ids = NULL,   these_samples_metadata = NULL,   maf_data,   chromosome,   qstart,   qend,   region = \"\",   streamlined = FALSE,   projection = \"grch37\",   this_seq_type = \"genome\",   tool_name = \"slms-3\",   this_study,   verbose = FALSE,   ... )"},{"path":"https://morinlab.github.io/GAMBLR.open/reference/get_ssm_by_region.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get SSM By Region. — get_ssm_by_region","text":"these_sample_ids Optional, vector multiple sample_id (single sample ID string) want results . these_samples_metadata Optional, metadata table (sample IDs column) subset return . provided (these_sample_ids provided), function return samples specified seq_type metadata. maf_data Optional data frame mutations MAF format. user provides maf, function trusts user already subset samples interest, correct seq_type. .e following parameters ignored; these_samples_metadata, these_sample_ids, this_seq_type chromosome chromosome restricting (without chr prefix). qstart Query start coordinate range restricting . qend Query end coordinate range restricting . region Region formatted like chrX:1234-5678 instead specifying chromosome, start end separately. streamlined Return Start_Position Tumor_Smaple_Barcode two MAF columns. Default FALSE. projection Obtain variants projected reference (one grch37 hg38). this_seq_type seq_type want back, default genome. tool_name Optionally specify tool report variant . default slms-3, also supports \"publication\" return exact variants reported original papers. this_study Optionally specify first name author paper variants returned . verbose Set FALSE prevent message printed. cases, parameter left TRUE. parameter added accommodate noisy output running function loop retrieving SSM multiple regions get_ssm_by_regions. ... additional parameters.","code":""},{"path":"https://morinlab.github.io/GAMBLR.open/reference/get_ssm_by_region.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get SSM By Region. — get_ssm_by_region","text":"data frame containing mutations (MAF) specified region.","code":""},{"path":"https://morinlab.github.io/GAMBLR.open/reference/get_ssm_by_region.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Get SSM By Region. — get_ssm_by_region","text":"function lets user specify region interest returning SSM calls within region. multiple ways region can specified. example, user can provide full region \"region\" format (chr:start-end) region parameter. , user can provide chromosome, start end coordinates individually chr, start, end parameters.","code":""},{"path":"https://morinlab.github.io/GAMBLR.open/reference/get_ssm_by_region.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get SSM By Region. — get_ssm_by_region","text":"","code":"my_mutations = get_ssm_by_region(region = \"chr8:128,723,128-128,774,067\") #> Using the bundled metadata in GAMBLR.data...  #specifying chromosome, start and end individually my_mutations = get_ssm_by_region(chromosome = \"8\",                                  qstart = 128723128,                                  qend = 128774067) #> Using the bundled metadata in GAMBLR.data..."},{"path":"https://morinlab.github.io/GAMBLR.open/reference/get_ssm_by_regions.html","id":null,"dir":"Reference","previous_headings":"","what":"Get SSM By Regions. — get_ssm_by_regions","title":"Get SSM By Regions. — get_ssm_by_regions","text":"Efficiently retrieve mutations across range genomic regions.","code":""},{"path":"https://morinlab.github.io/GAMBLR.open/reference/get_ssm_by_regions.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get SSM By Regions. — get_ssm_by_regions","text":"","code":"get_ssm_by_regions(   these_samples_metadata,   regions_list,   regions_bed,   this_seq_type = \"genome\",   streamlined = TRUE,   projection = \"grch37\",   verbose = FALSE,   use_name_column = FALSE,   tool_name = \"slms-3\",   ... )"},{"path":"https://morinlab.github.io/GAMBLR.open/reference/get_ssm_by_regions.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get SSM By Regions. — get_ssm_by_regions","text":"these_samples_metadata Optional, metadata table (sample IDs column) subset return . regions_list vector regions chr:start-end format restrict returned SSM calls . regions_bed data frame BED format coordinates want retrieve (recommended). parameter can also accept additional column region names added return use_name_column = TRUE this_seq_type this_seq_type want back, default genome. streamlined set TRUE (default) 3 columns kept returned data frame (start, sample_id region_name). projection Obtain variants projected reference (one grch37 hg38), default grch37. verbose Set TRUE maximize output console. Default TRUE. parameter also dictates verbosity helper function internally called inside main function. use_name_column bed-format data frame name column (must named \"name\") can used name regions. tool_name Optionally specify tool report variant . default slms-3, also supports \"publication\" return exact variants reported original papers. ... additional parameters.","code":""},{"path":"https://morinlab.github.io/GAMBLR.open/reference/get_ssm_by_regions.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get SSM By Regions. — get_ssm_by_regions","text":"Returns data frame variants MAF-like format.","code":""},{"path":"https://morinlab.github.io/GAMBLR.open/reference/get_ssm_by_regions.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Get SSM By Regions. — get_ssm_by_regions","text":"function internally calls get_ssm_by_region retrieve SSM calls specified regions.","code":""},{"path":"https://morinlab.github.io/GAMBLR.open/reference/get_ssm_by_regions.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get SSM By Regions. — get_ssm_by_regions","text":"","code":"#basic usage, adding custom names from bundled ashm data frame regions_bed = create_bed_data( GAMBLR.data::grch37_ashm_regions,                           fix_names = \"concat\",                           concat_cols = c(\"gene\",\"region\"),                           sep=\"-\")  my_meta = get_gambl_metadata() #> Using the bundled metadata in GAMBLR.data... # get a full MAF-format data frame for all aSHM regions on grch37 coordinates ashm_maf = get_ssm_by_regions(regions_bed = regions_bed,                               these_samples_metadata = my_meta,                               streamlined = FALSE) #> Using the bundled SSM calls (.maf) calls in GAMBLR.data... #> Using the bundled SSM calls (.maf) calls in GAMBLR.data... #> id_ease: WARNING! 1838 samples in the provided metadata were removed because their seq types are not the same as in the `set_type` argument. Use `verbose = TRUE` to see their IDs. #> Running in default mode of any...    one_region_maf = get_ssm_by_regions(regions_list = \"2:136875000-136875097\",                          streamlined = FALSE,                          projection = \"grch37\",                          these_samples_metadata = my_meta) #> Using the bundled SSM calls (.maf) calls in GAMBLR.data... #> Using the bundled SSM calls (.maf) calls in GAMBLR.data... #> id_ease: WARNING! 1838 samples in the provided metadata were removed because their seq types are not the same as in the `set_type` argument. Use `verbose = TRUE` to see their IDs. #> Running in default mode of any... if (FALSE) { # \\dontrun{ # This example fails, as it should #ashm_maf = get_ssm_by_regions(regions_bed = regions_bed, #                              these_samples_metadata = my_meta, #                               projection=\"hg38\") # Error in get_ssm_by_regions(regions_bed = regions_bed, these_samples_metadata = my_meta,  :  # requested projection: hg38 and genome_build of regions_bed: grch37 don't match } # }"},{"path":"https://morinlab.github.io/GAMBLR.open/reference/get_ssm_by_samples.html","id":null,"dir":"Reference","previous_headings":"","what":"Get SSM By Samples. — get_ssm_by_samples","title":"Get SSM By Samples. — get_ssm_by_samples","text":"Get SSMs (.e. load MAF) single sample collection samples.","code":""},{"path":"https://morinlab.github.io/GAMBLR.open/reference/get_ssm_by_samples.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get SSM By Samples. — get_ssm_by_samples","text":"","code":"get_ssm_by_samples(   these_sample_ids = NULL,   these_samples_metadata = NULL,   this_seq_type = \"genome\",   projection = \"grch37\",   tool_name = \"slms-3\",   verbose = FALSE,   ... )"},{"path":"https://morinlab.github.io/GAMBLR.open/reference/get_ssm_by_samples.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get SSM By Samples. — get_ssm_by_samples","text":"these_sample_ids vector one sample IDs want results . these_samples_metadata Optional, metadata table (sample_id column) auto-subset data samples table returning. provided these_sample_ids also provided, function return SSM samples specified seq_type bundled metadata. this_seq_type Default genome. projection projection genome build. Supports hg38 grch37. tool_name Optionally specify tool report variant . default slms-3, also supports \"publication\" return exact variants reported original papers. verbose Enable debugging/noisier output. ... additional parameters.","code":""},{"path":"https://morinlab.github.io/GAMBLR.open/reference/get_ssm_by_samples.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get SSM By Samples. — get_ssm_by_samples","text":"data frame MAF format.","code":""},{"path":"https://morinlab.github.io/GAMBLR.open/reference/get_ssm_by_samples.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Get SSM By Samples. — get_ssm_by_samples","text":"Retrieve maf specific sample set samples. Either specify sample IDs interest these_sample_ids. metadata table subset sample IDs interest these_samples_metadata.","code":""},{"path":"https://morinlab.github.io/GAMBLR.open/reference/get_ssm_by_samples.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get SSM By Samples. — get_ssm_by_samples","text":"","code":"#Get genome-wide set of mutations from all DLBCL cell lines  # 1. get our metadata for the DLBCL cell lines cell_line_meta = get_gambl_metadata() %>%   dplyr::filter(cohort == \"DLBCL_cell_lines\") #> Using the bundled metadata in GAMBLR.data...  # 2. get the SSMs for the DLBCL cell lines dlbcl_maf = get_ssm_by_samples(these_samples_metadata = cell_line_meta) #> Using the bundled SSM calls (.maf) calls in GAMBLR.data...  # 3. have a look: dlbcl_maf %>% dplyr::group_by(Tumor_Sample_Barcode) %>%               dplyr::count() #> genomic_data Object #> Genome Build: grch37  #> Showing first 10 rows: #>   Tumor_Sample_Barcode     n #> 1               DOHH-2 22089 #> 2             OCI-Ly10 30051 #> 3              OCI-Ly3 31532 #> 4            SU-DHL-10 26855 #> 5             SU-DHL-4 32824"},{"path":"https://morinlab.github.io/GAMBLR.open/reference/id_ease.html","id":null,"dir":"Reference","previous_headings":"","what":"ID Ease — id_ease","title":"ID Ease — id_ease","text":"Internal convenience function standardize way GAMBLR functions deals sample IDs (these_sample_ids) metadata (these_samples_metadata).","code":""},{"path":"https://morinlab.github.io/GAMBLR.open/reference/id_ease.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"ID Ease — id_ease","text":"","code":"id_ease(   these_samples_metadata = NULL,   these_sample_ids = NULL,   this_seq_type = c(\"genome\", \"capture\"),   verbose = FALSE )"},{"path":"https://morinlab.github.io/GAMBLR.open/reference/id_ease.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"ID Ease — id_ease","text":"these_samples_metadata optional data frame metadata, subset sample IDs interest. provided retrieve GAMBL metadata available samples. these_sample_ids Optional character vector GAMBL sample IDs. this_seq_type seq type interest. Default genome exome, priority genome sample >1 seq_type. verbose Set FALSE limit information gets printed console. Default FALSE.","code":""},{"path":"https://morinlab.github.io/GAMBLR.open/reference/id_ease.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"ID Ease — id_ease","text":"Metadata (data frame).","code":""},{"path":"https://morinlab.github.io/GAMBLR.open/reference/id_ease.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"ID Ease — id_ease","text":"function can take sample IDs vector characters, metadata table data frame format. sample IDs provided function, function operate gambl sample IDs available given seq type. highly recommended run function verbose = TRUE. Since improve overall logic function operates. also might help debugging functions internally calling function. function also performs sanity checks notifies user requested sample IDs found metadata. addition, function also notifies dimensions returned object, providing insight returned. GAMBLR functions, providing curated metadata table GAMBLR function (opposed vector IDs) safest way ensure get expected result.","code":""},{"path":"https://morinlab.github.io/GAMBLR.open/reference/id_ease.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"ID Ease — id_ease","text":"","code":"#load packages library(dplyr)  #give the function nothing (i.e return all sample IDs in the metadata for the default seq type) #return metadata for all samples in the default seq type all_meta = id_ease() #> Using the bundled metadata in GAMBLR.data...  #return metadata based on a sample ID sample_meta = id_ease(these_sample_ids = \"94-15772_tumorA\") #> Using the bundled metadata in GAMBLR.data...  #return sample IDs based on an already filtered metadata this_metadata = get_gambl_metadata(seq_type_filter = \"genome\") %>%    head(5) #> Using the bundled metadata in GAMBLR.data...  these_ids = id_ease(these_samples_metadata = this_metadata)"},{"path":"https://morinlab.github.io/GAMBLR.open/reference/pipe.html","id":null,"dir":"Reference","previous_headings":"","what":"Pipe operator — %>%","title":"Pipe operator — %>%","text":"See magrittr::%>% details.","code":""},{"path":"https://morinlab.github.io/GAMBLR.open/reference/pipe.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Pipe operator — %>%","text":"","code":"lhs %>% rhs"},{"path":"https://morinlab.github.io/GAMBLR.open/reference/pipe.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Pipe operator — %>%","text":"lhs value magrittr placeholder. rhs function call using magrittr semantics.","code":""},{"path":"https://morinlab.github.io/GAMBLR.open/reference/pipe.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Pipe operator — %>%","text":"result calling rhs(lhs).","code":""}]
