[
  {
    "objectID": "concepts/GAMBLR_family.html",
    "href": "concepts/GAMBLR_family.html",
    "title": "GAMBLR family of packages",
    "section": "",
    "text": "GAMBLR.open is the open-source package recommended for the community interested in lymphoma genomics research and are not members of the GAMBL consortium, or if you are waiting for your access approval but want to get started.\nThe GAMBLR.open family includes:\n\nGAMBLR.data - a “storage unit” with different types of bundled data.\nGAMBLR.helpers - a set of low-level functions for data operation.\nGAMBLR.utils - higher level set of functions to operate on genomic data.\nGAMBLR.viz - set of functions used mostly for visualizations.\nGAMBLR.predict - a collection of machine learning algorithms and functions to pre-format inputs for these models. Contains classifiers of Burkitt and Follicular lymphomas originally published, as well as reproduced of DLBCL classification by the groupings of Chapuy et al, Lacy et al, and Runge et al.\nGAMBLR.open - this package.\n\nThis diagram illustrates in a simplified way the dependency relationship of different packages in the GAMBLR family:\n\n\n\n\n\n%%{\n    init : {\n        \"flowchart\" : { \"curve\" : \"monotoneX\" },\n        'themeVariables': {'fontSize': '24px'}\n    }\n\n}%%\nflowchart LR\n  A(\"GAMBLR.data\") ==&gt; B(\"GAMBLR.helpers\")\n  B ==&gt; C(\"GAMBLR.utils\")\n  B ==&gt; D(\"GAMBLR.predict\")\n  D ==&gt; E(\"GAMBLR.open\")\n  C ==&gt; F(\"GAMBLR.viz\")\n  F ==&gt; E\n  classDef A,B font-size:18pt;\n  style E fill:#6aa84f,stroke:#333,stroke-width:4,font-size:20px\n\n\n\n\n\n\nAll dependencies should be installed automatically for you, just like with any other R package. If not, please report the issue in the appropriate GitHub repo.\n\n\n\n Back to top",
    "crumbs": [
      "GAMBLR family of packages"
    ]
  },
  {
    "objectID": "tutorials/getting_started.html",
    "href": "tutorials/getting_started.html",
    "title": "Tutorial: getting started",
    "section": "",
    "text": "This is a quick tour of some basic commands and usage patterns, just to get you started.\n\n# Load packages\nlibrary(GAMBLR.open)\nlibrary(tidyverse)\n\n# Set a custom GAMBLR theme\ntheme_set(theme_Morons())\n\n# Custom ggplot function that always adds consistent colors and sets scales\nggplot_consistent &lt;- function(...) {\n    ggplot(...) +\n        scale_fill_manual(values = get_gambl_colours()) +\n        scale_y_continuous(expand = expansion(mult = c(0, 0.1)))\n}\n\n# Example gene\nmy_genes &lt;- c(\"MYC\")\n\nThis tutorial explores how to retrieve different data types bundled within GAMBLR.data. Commonly, GAMBLR functions are prefixed with get_. These functions are readily available for returning data of different types: Simple Somatic Mutations (SSM), Copy Number (CN) segments and Structural Variants (SV). This resource explores commonly occurring arguments across different functions, best-practices and recommendations in the scope of retrieving data.\n\n\nFirst, let’s start with retrieving metadata for all GAMBL samples. We can control which samples to be included in the output with seq_type_filter argument, which returns genome samples by default. To return metadata for capture samples, set seq_type_filter = \"capture\". It is also possible to return metadata for more than one seq type, e.g seq_type_filter = c(\"genome\", \"capture\").\n\nmetadata &lt;- list()\n# Get gambl metadata for genome samples\nmetadata$genomes &lt;- get_gambl_metadata(\n    seq_type_filter = \"genome\"\n)\nmetadata$capture &lt;- get_gambl_metadata(\n    seq_type_filter = \"capture\"\n)\nmetadata$all &lt;- get_gambl_metadata(\n    seq_type_filter = c(\"genome\", \"capture\")\n)\n\nmetadata$cell_lines &lt;- get_gambl_metadata() %&gt;%\n    filter(\n        cohort == \"DLBCL_cell_lines\"\n    )\n\nNow that we have the metadata, we can look at the expected column names and their format:\n\nstr(metadata$all)\n\n'data.frame':   2863 obs. of  29 variables:\n $ age_group           : chr  \"Other\" \"Other\" \"Other\" \"Other\" ...\n $ bam_available       : logi  TRUE TRUE TRUE TRUE TRUE TRUE ...\n $ cohort              : chr  \"BL_Thomas\" \"BL_Thomas\" \"BL_Thomas\" \"BL_Thomas\" ...\n $ compression         : chr  \"cram\" \"cram\" \"cram\" \"cram\" ...\n $ COO_consensus       : chr  NA NA NA NA ...\n $ DHITsig_consensus   : chr  \"NA\" \"NA\" \"NA\" \"NA\" ...\n $ EBV_status_inf      : chr  \"EBV-positive\" \"EBV-negative\" \"EBV-negative\" \"EBV-negative\" ...\n $ ffpe_or_frozen      : chr  \"frozen\" \"frozen\" \"frozen\" \"frozen\" ...\n $ fl_grade            : chr  NA NA NA NA ...\n $ genetic_subgroup    : chr  \"DGG-BL\" \"DGG-BL\" \"IC-BL\" \"IC-BL\" ...\n $ genome_build        : chr  \"hg38\" \"hg38\" \"hg38\" \"hg38\" ...\n $ hiv_status          : chr  NA NA NA NA ...\n $ lymphgen            : chr  \"ST2\" \"Other\" \"Other\" \"Other\" ...\n $ lymphgen_cnv_noA53  : chr  \"ST2\" \"Other\" \"Other\" \"Other\" ...\n $ lymphgen_no_cnv     : chr  \"ST2\" \"Other\" \"Other\" \"Other\" ...\n $ lymphgen_with_cnv   : chr  \"ST2\" \"Other\" \"Other\" \"Other\" ...\n $ lymphgen_wright     : chr  NA NA NA NA ...\n $ molecular_BL        : chr  NA NA NA NA ...\n $ normal_sample_id    : chr  NA NA NA NA ...\n $ pairing_status      : chr  \"unmatched\" \"unmatched\" \"unmatched\" \"unmatched\" ...\n $ pathology           : chr  \"BL\" \"BL\" \"BL\" \"BL\" ...\n $ pathology_rank      : num  7 7 7 7 7 7 7 7 7 7 ...\n $ patient_id          : chr  \"BLGSP-71-29-00539\" \"BLGSP-71-29-00525\" \"BLGSP-71-29-00528\" \"BLGSP-71-29-00526\" ...\n $ reference_PMID      : num  36201743 36201743 36201743 36201743 36201743 ...\n $ sample_id           : chr  \"Akata\" \"BL2\" \"BL30\" \"BL41\" ...\n $ seq_type            : chr  \"genome\" \"genome\" \"genome\" \"genome\" ...\n $ sex                 : chr  \"NA\" \"NA\" \"NA\" \"NA\" ...\n $ time_point          : chr  \"A\" \"A\" \"A\" \"A\" ...\n $ Tumor_Sample_Barcode: chr  \"Akata\" \"BL2\" \"BL30\" \"BL41\" ...\n\n\nWe can now use the metadata as we wish. For example, we can visualize the counts of samples per pathology and sequencing type:\n\n# We can see what is included in the metadata\nmetadata$all %&gt;%\n    count(pathology, seq_type) %&gt;%\n    ggplot_consistent(\n        aes(\n            x = pathology,\n            y = n,\n            fill = pathology\n        )\n    ) +\n    geom_bar(stat = \"identity\") +\n    facet_wrap(~seq_type, scales = \"free\") +\n    geom_text(aes(label=n), size=3.5) +\n    theme(\n        axis.text.x = element_text(\n            angle = 90,\n            vjust = 0.5,\n            hjust = 1\n        )\n    )\n\n\n\n\n\n\n\n# We can also visualize these counts when subset to only DLBCL:\n# Subset metadata on a set of samples (samples classified as DLBCL for pathology)\nmetadata$dlbcl &lt;- metadata$all %&gt;%\n    filter(pathology == \"DLBCL\")\n\nmetadata$dlbcl %&gt;%\n    count(pathology, seq_type) %&gt;%\n    ggplot_consistent(\n        aes(\n            x = pathology,\n            y = n,\n            fill = pathology\n        )\n    ) +\n    geom_bar(stat = \"identity\") +\n    facet_wrap(~seq_type) +\n    geom_text(aes(label=n), size=3.5)\n\n\n\n\n\n\n\n\n\n\n\nBased on the information available to you, your application, or your downstream analysis, there are multiple ways to retrieve SSM data. For example, if you know the sample ID and are only interested in looking at SSM results for that particular sample, you can use get_ssm_by_sample. If multiple samples are to be analyzed, get_ssm_by_samples (plural version) is recommended. You can also use patient IDs for retrieving this data, in this case get_ssm_by_patients is available. In addition, you can also restrict SSM calls to specific genomic regions with get_ssm_by_regions or get_ssm_by_region.\nAnother possibility is to focus on coding mutations only and call get_coding_ssm, this function returns all coding SSMs from the bundled data in maf-like format. If you have an already pre-filtered metadata, the these_samples_metadata argument can be used with all SSM functions to restrict the variants returned to the sample IDs in this data frame, handy!\n\n\nReturn SSMs for one or more samples with get_ssm_by_samples. In the example below, we are requesting SSM for the DOHH-2 cell line in two different ways:\n\n\n\nmy_sample_id &lt;- \"DOHH-2\"\n\n# Using the these_samples_id argument\nssm_sample &lt;- get_ssm_by_samples(these_sample_ids = my_sample_id)\n\n# How many mutations do we get back?\ndim(ssm_sample)\n\n[1] 22089    49\n\n# What columns are available?\ncolnames(ssm_sample)\n\n [1] \"Hugo_Symbol\"                   \"Entrez_Gene_Id\"               \n [3] \"Center\"                        \"NCBI_Build\"                   \n [5] \"Chromosome\"                    \"Start_Position\"               \n [7] \"End_Position\"                  \"Strand\"                       \n [9] \"Variant_Classification\"        \"Variant_Type\"                 \n[11] \"Reference_Allele\"              \"Tumor_Seq_Allele1\"            \n[13] \"Tumor_Seq_Allele2\"             \"dbSNP_RS\"                     \n[15] \"dbSNP_Val_Status\"              \"Tumor_Sample_Barcode\"         \n[17] \"Matched_Norm_Sample_Barcode\"   \"Match_Norm_Seq_Allele1\"       \n[19] \"Match_Norm_Seq_Allele2\"        \"Tumor_Validation_Allele1\"     \n[21] \"Tumor_Validation_Allele2\"      \"Match_Norm_Validation_Allele1\"\n[23] \"Match_Norm_Validation_Allele2\" \"Verification_Status\"          \n[25] \"Validation_Status\"             \"Mutation_Status\"              \n[27] \"Sequencing_Phase\"              \"Sequence_Source\"              \n[29] \"Validation_Method\"             \"Score\"                        \n[31] \"BAM_File\"                      \"Sequencer\"                    \n[33] \"Tumor_Sample_UUID\"             \"Matched_Norm_Sample_UUID\"     \n[35] \"HGVSc\"                         \"HGVSp\"                        \n[37] \"HGVSp_Short\"                   \"Transcript_ID\"                \n[39] \"Exon_Number\"                   \"t_depth\"                      \n[41] \"t_ref_count\"                   \"t_alt_count\"                  \n[43] \"n_depth\"                       \"n_ref_count\"                  \n[45] \"n_alt_count\"                   \"RefSeq\"                       \n[47] \"Pipeline\"                      \"Study\"                        \n[49] \"maf_seq_type\"                 \n\n# What variants are available?\nssm_sample %&gt;%\n    count(Variant_Classification) %&gt;%\n    ggplot_consistent(\n        aes(\n            x = Variant_Classification,\n            y = n,\n            fill = Variant_Classification\n        )\n    ) +\n    geom_bar(stat = \"identity\") +\n    geom_text(aes(label=n), size=3.5, vjust = -0.5) +\n    theme(\n        axis.text.x = element_text(\n            angle = 90,\n            vjust = 0.5,\n            hjust = 1\n        )\n    )\n\n\n\n\n\n\n\n\n\n\n\nWe can supply instead a metadata table that has already been subset to the sample ID(s) of interest.\n\nmetadata$dohh2 &lt;- metadata$genome %&gt;%\n    filter(sample_id == \"DOHH-2\")\n\n# Using the these_samples_metadata argument\nssm_meta &lt;- get_ssm_by_samples(\n    these_samples_metadata = metadata$dohh2\n)\n\n# How many mutations do we get back?\ndim(ssm_meta)\n\n[1] 22089    49\n\n# What columns are available?\ncolnames(ssm_meta)\n\n [1] \"Hugo_Symbol\"                   \"Entrez_Gene_Id\"               \n [3] \"Center\"                        \"NCBI_Build\"                   \n [5] \"Chromosome\"                    \"Start_Position\"               \n [7] \"End_Position\"                  \"Strand\"                       \n [9] \"Variant_Classification\"        \"Variant_Type\"                 \n[11] \"Reference_Allele\"              \"Tumor_Seq_Allele1\"            \n[13] \"Tumor_Seq_Allele2\"             \"dbSNP_RS\"                     \n[15] \"dbSNP_Val_Status\"              \"Tumor_Sample_Barcode\"         \n[17] \"Matched_Norm_Sample_Barcode\"   \"Match_Norm_Seq_Allele1\"       \n[19] \"Match_Norm_Seq_Allele2\"        \"Tumor_Validation_Allele1\"     \n[21] \"Tumor_Validation_Allele2\"      \"Match_Norm_Validation_Allele1\"\n[23] \"Match_Norm_Validation_Allele2\" \"Verification_Status\"          \n[25] \"Validation_Status\"             \"Mutation_Status\"              \n[27] \"Sequencing_Phase\"              \"Sequence_Source\"              \n[29] \"Validation_Method\"             \"Score\"                        \n[31] \"BAM_File\"                      \"Sequencer\"                    \n[33] \"Tumor_Sample_UUID\"             \"Matched_Norm_Sample_UUID\"     \n[35] \"HGVSc\"                         \"HGVSp\"                        \n[37] \"HGVSp_Short\"                   \"Transcript_ID\"                \n[39] \"Exon_Number\"                   \"t_depth\"                      \n[41] \"t_ref_count\"                   \"t_alt_count\"                  \n[43] \"n_depth\"                       \"n_ref_count\"                  \n[45] \"n_alt_count\"                   \"RefSeq\"                       \n[47] \"Pipeline\"                      \"Study\"                        \n[49] \"maf_seq_type\"                 \n\n# What variants are available?\nssm_meta %&gt;%\n    count(Variant_Classification) %&gt;%\n    ggplot_consistent(\n        aes(\n            x = Variant_Classification,\n            y = n,\n            fill = Variant_Classification\n        )\n    ) +\n    geom_bar(stat = \"identity\") +\n    geom_text(aes(label=n), size=3.5, vjust = -0.5) +\n    theme(\n        axis.text.x = element_text(\n            angle = 90,\n            vjust = 0.5,\n            hjust = 1\n        )\n    )\n\n\n\n\n\n\n\n\nWe can make sure that both approaches generate identical outputs:\n\nidentical(\n    ssm_sample,\n    ssm_meta\n)\n\n[1] TRUE\n\n\nThus, there is no “right” or “wrong” way, it is simply your personal preference!\n\n\n\nOften many downstream tools can only work on one specific genome build, and GAMBLR.data provides a simple and straightforward way to obtain variants in different projections. The default output is always with respect to grch37, and it can be easily modified with argument projection:\n\nssm_hg38 &lt;- get_ssm_by_samples(\n    projection = \"hg38\"\n)\n\n# Sanity check the projection\nssm_hg38 %&gt;%\n    count(NCBI_Build) %&gt;%\n    ggplot_consistent(\n        aes(\n            x = NCBI_Build,\n            y = n,\n            fill = NCBI_Build\n        )\n    ) +\n    geom_bar(stat = \"identity\") +\n    geom_text(aes(label=n), size=3.5, vjust = -0.5)\n\n\n\n\n\n\n\n\nAs we did not specify any sample ID, metadata, or gene to the above call, it returned the data for all samples available in GAMBLR.data, and we can see from the plot that all of the variants are with respect to hg38. Sweet! 😎\n\n\n\n\nIn this section, we are exploring the different ways you can obtain the maf data for a specific region (or regions) of interest.\nIn this example, we will obtain SSM calls for all aSHM regions associated with PAX5 across all available samples. With this function we also will get the region name added to the returned data frame. If you are providing regions as a bed file (regions_bed), you have the option of setting use_name_column = TRUE. If you do so, your bed file should have a column simply named “name”. In this case, the function will keep this column for naming the returned regions in the maf. With streamlined = TRUE the function returns the minimal number of columns.\n\n\n\n\n\n\nNote\n\n\n\nDon’t know coordinates of aSHM at PAX5? GAMBLR.data has you covered!\n\n\n\n# Get aSHM genes, select the columns of interest and rename for\n# get_ssm_by_regions compatibility\nashm_gene &lt;- \"PAX5\"\nregions &lt;- create_bed_data(\n    GAMBLR.data::grch37_ashm_regions %&gt;%\n        filter(gene == ashm_gene),\n    fix_names = \"concat\",\n    concat_cols = c(\"gene\",\"region\"),\n    sep=\"-\"\n)\n\n# Get ssm for all ashm regions\nashm_ssm &lt;- get_ssm_by_regions(\n    these_samples_metadata = metadata$genomes,\n    regions_bed = regions,\n    streamlined = FALSE\n)\n\ndim(ashm_ssm)\n\n[1] 3238   50\n\nashm_ssm[1:5,1:10]\n\nMAF Data Object\nGenome Build: \nShowing first 10 rows:\n  Hugo_Symbol Entrez_Gene_Id Center NCBI_Build Chromosome Start_Position\n1        PAX5              0      .     GRCh37          9       37033520\n2        PAX5              0      .     GRCh37          9       37034762\n3        PAX5              0      .     GRCh37          9       37033894\n4        PAX5              0      .     GRCh37          9       37035326\n5        PAX5              0      .     GRCh37          9       37030604\n  End_Position Strand Variant_Classification Variant_Type\n1     37033520      +                 Intron          SNP\n2     37034762      +                5'Flank          SNP\n3     37033894      +                 Intron          SNP\n4     37035326      +                5'Flank          SNP\n5     37030604      +                 Intron          SNP\n\n\n\n\n\nLastly, another way to retrieve SSM is to call get_coding_ssm. This function returns coding SSM for any given sample. This function is a convenient option for anyone interested in focusing only on coding mutations. Convenient filtering arguments are included in this function for easy and straightforward subsetting. If these arguments are not used, coding SSM will be returned for all samples. Of course, similar to the examples above, you can provide a metadata subset that has already been filtered to the sample IDs of interest (using these_samples_metadata).\n\n# All default arguments\nall_ssm &lt;- get_coding_ssm()\ndim(all_ssm)\n\n[1] 13913    49\n\n# Provide metadata\ndlbcl_cell_lines &lt;- get_coding_ssm(\n    these_samples_metadata = metadata$cell_lines\n)\ndim(dlbcl_cell_lines)\n\n[1] 1616   49\n\n\n\n\n\n\nFor the purpose of retrieving CN data, we have the function get_sn_segments. If you want to query CN calls for a specific region or genomic loci, get_cn_segments is best used. In this section we will demonstrate how this function can be used.\n\n\nWe can use metadata restricted to the sample ID of interest to demonstrate what type of data will be returned:\n\nseg &lt;- get_cn_segments(\n    these_samples_metadata = metadata$cell_lines\n)\n\n# What are the columns we have available?\nhead(seg)\n\nSEG Data Object\nGenome Build: grch37 \nShowing first 10 rows:\n      ID chrom     start       end LOH_flag log.ratio CN\n1 DOHH-2     1     10001  86026719        0         0  2\n2 DOHH-2     1  86026720  86688464        1         0  2\n3 DOHH-2     1  86688465 121499999        0         0  2\n4 DOHH-2     1 142600001 249250620        0         0  2\n5 DOHH-2     2     10001  89087285        0         0  2\n6 DOHH-2     2  89087286  89997184        1       -10  0\n\n\n\n\n\nWe can retrieve CN segments while also requesting a different projection. Similar to the SSM functionality shown earlier, this can be done by toggling the projection argument and switching it to the hg38 value.\n\n# Call in hg38 projection\nseg &lt;- get_cn_segments(\n    these_samples_metadata = metadata$cell_lines,\n    projection = \"hg38\"\n)\n\nhead(seg)\n\nSEG Data Object\nGenome Build: hg38 \nShowing first 10 rows:\n      ID chrom     start       end LOH_flag log.ratio CN\n1 DOHH-2  chr1     10001  85561036        0         0  2\n2 DOHH-2  chr1  85561037  86222781        1         0  2\n3 DOHH-2  chr1  86222782 121699999        0         0  2\n4 DOHH-2  chr1 143200001 248956421        0         0  2\n5 DOHH-2  chr2         1  91799999        0         0  2\n6 DOHH-2  chr2  96000001 242193528        0         0  2\n\n\n\n\n\n\nIn this last section, we will explore how to get SV data using GAMBLR.data. For this purpose get_manta_sv was developed. This function can restrict the returned calls to any genomic regions specified with chromosome, qstart, qend, or the complete region specified with the region argument (in chr:start-end format). In addition, useful filtering arguments are also available, use min_vaf to set the minimum tumour VAF in order for a SV to be returned and min_score to set the lowest Manta somatic score in order for a SV to be returned. pair_status can be used to obtain variants from either matched or unmatched samples.\n\n\nWe will call get_manta_sv with default arguments to examine the output.\n\n# Default arguments\nall_manta &lt;- get_manta_sv()\n\n# How many SVs do we get back?\nnrow(all_manta)\n\n[1] 1154\n\n# How many samples do we have SV calls for?\nlength(unique(all_manta$tumour_sample_id))\n\n[1] 580\n\n# What does the returned data frame look like?\nhead(all_manta)\n\n  CHROM_A   START_A     END_A CHROM_B   START_B     END_B\n1       1 161658631 161658631       3  16509907  16509907\n2       1 161663959 161663959       9  37363320  37363320\n3       1 161663959 161663959       9  37363320  37363320\n4      11  65267283  65267283      14 106110907 106110907\n5      11  65267422  65267422      14 106110905 106110905\n6      13  91976545  91976545      14 106211857 106211857\n                     manta_name SCORE STRAND_A STRAND_B tumour_sample_id\n1      MantaBND:21171:0:1:0:0:0   133        +        +         FL2002T1\n2     MantaBND:206628:0:1:0:0:0   122        +        +  09-15842_tumorA\n3     MantaBND:195941:0:1:0:0:0   151        +        +  09-15842_tumorB\n4   MantaBND:152220:0:1:0:0:0:0    88        +        -        15-38154T\n5   MantaBND:152220:0:1:0:0:0:0   135        -        +        15-38154T\n6 MantaBND:18:59794:59817:0:1:0    90        -        +        15-31924T\n  normal_sample_id VAF_tumour  DP pair_status FILTER\n1          FL2002N      0.331 127     matched   PASS\n2  09-15842_normal      0.281 196     matched   PASS\n3  09-15842_normal      0.364 187     matched   PASS\n4        15-38154N      0.150 167     matched   PASS\n5        15-38154N      0.290 169     matched   PASS\n6        15-31924N      0.365  85     matched   PASS\n\n\n\n\n\nAlternatively, you can also provide these_samples_metadata argument to make use of a pre-filtered metadata table. In this case, the returned SVs will be restricted to the sample_ids within the data frame.\n\ncell_line_manta &lt;- get_manta_sv(\n    these_samples_metadata = metadata$cell_lines\n)\n\n# How many SVs do we get back?\nnrow(cell_line_manta)\n\n[1] 13\n\n# How many samples do we have SV calls for?\nlength(unique(cell_line_manta$tumour_sample_id))\n\n[1] 3\n\n# What does the returned data frame look like?\nhead(cell_line_manta)\n\n  CHROM_A   START_A     END_A CHROM_B  START_B    END_B\n1      14 106329462 106329462      18 60774579 60774579\n2      14 106329465 106329465      18 60793497 60793497\n3      14 106330466 106330466      18 60793914 60793914\n4      14 106349765 106349765      18 60793914 60793914\n5      14 106379091 106379091      18 60793492 60793492\n6      14 106380227 106380227      18 60774578 60774578\n                 manta_name SCORE STRAND_A STRAND_B tumour_sample_id\n1 MantaBND:220769:1:2:0:0:0   134        +        -        SU-DHL-10\n2 MantaBND:194451:1:2:0:0:0   103        +        -           DOHH-2\n3 MantaBND:217561:1:2:0:0:0   182        +        -         SU-DHL-4\n4 MantaBND:217561:0:1:0:0:0   198        -        +         SU-DHL-4\n5 MantaBND:194451:0:1:0:0:0    91        -        +           DOHH-2\n6 MantaBND:220769:0:1:0:0:0   169        -        +        SU-DHL-10\n  normal_sample_id VAF_tumour DP pair_status FILTER\n1        14-11247N      0.318 66   unmatched   PASS\n2        14-11247N      0.290 69   unmatched   PASS\n3        14-11247N      0.474 57   unmatched   PASS\n4        14-11247N      0.500 62   unmatched   PASS\n5        14-11247N      0.300 60   unmatched   PASS\n6        14-11247N      0.578 45   unmatched   PASS\n\n\n\n\n\nWe can call get_manta_sv specifying the region of interest first in the region format and then with specifying the chromosome, start and end individually.\n\n\n\n\n\n\nNote\n\n\n\nDon’t know coordinates of MYC gene region? GAMBLR got you covered!\n\n\n\n# Convert the gene name to the region\nmyc_region &lt;- gene_to_region(\n    gene_symbol = \"MYC\"\n)\n\nmyc_region\n\n                    MYC \n\"8:128747680-128753674\" \n\n# Specifying MYC in region format\nmyc_manta_region &lt;- get_manta_sv(\n    these_samples_metadata = metadata$genomes,\n    region = myc_region,\n    min_vaf = 0,\n    min_score = 0\n)\n\n# Specifying MYC with chromosome, qstart and qend arguments\nmyc_manta_chunks &lt;- get_manta_sv(\n    these_samples_metadata = metadata$genomes,\n    chromosome = 8,\n    qstart = 128747680,\n    qend = 128753674,\n    min_vaf = 0,\n    min_score = 0\n)\n\n# Are the returned data frames the same?\nidentical(\n    myc_manta_region,\n    myc_manta_chunks\n)\n\n[1] TRUE\n\n\n\n\n\nHere we are demonstrating the filtering options to obtain SVs. In this example, we are calling get_manta_sv on the DLBCL metadata subset. For demonstration purposes, we are also requesting a non-default projection and adding some more filtering.\n\n# Get manta SVs for the samples with DLBCL pathology\ndlbcl_manta &lt;- get_manta_sv(\n    these_samples_metadata = metadata$dlbcl,\n    projection = \"hg38\",\n    min_vaf = 0.4,\n    min_score = 100\n)\n\n# How many variants do we get back with these filters?\nnrow(dlbcl_manta)\n\n[1] 68\n\n# Does the advertised VAF filters work?\nall(dlbcl_manta$VAF_tumour &gt;= 0.4)\n\n[1] TRUE\n\n# Do the advertised SCORE filter work?\nall(dlbcl_manta$SCORE &gt;= 100)\n\n[1] TRUE\n\n# What does the returned data frame look like?\nhead(cell_line_manta)\n\n  CHROM_A   START_A     END_A CHROM_B  START_B    END_B\n1      14 106329462 106329462      18 60774579 60774579\n2      14 106329465 106329465      18 60793497 60793497\n3      14 106330466 106330466      18 60793914 60793914\n4      14 106349765 106349765      18 60793914 60793914\n5      14 106379091 106379091      18 60793492 60793492\n6      14 106380227 106380227      18 60774578 60774578\n                 manta_name SCORE STRAND_A STRAND_B tumour_sample_id\n1 MantaBND:220769:1:2:0:0:0   134        +        -        SU-DHL-10\n2 MantaBND:194451:1:2:0:0:0   103        +        -           DOHH-2\n3 MantaBND:217561:1:2:0:0:0   182        +        -         SU-DHL-4\n4 MantaBND:217561:0:1:0:0:0   198        -        +         SU-DHL-4\n5 MantaBND:194451:0:1:0:0:0    91        -        +           DOHH-2\n6 MantaBND:220769:0:1:0:0:0   169        -        +        SU-DHL-10\n  normal_sample_id VAF_tumour DP pair_status FILTER\n1        14-11247N      0.318 66   unmatched   PASS\n2        14-11247N      0.290 69   unmatched   PASS\n3        14-11247N      0.474 57   unmatched   PASS\n4        14-11247N      0.500 62   unmatched   PASS\n5        14-11247N      0.300 60   unmatched   PASS\n6        14-11247N      0.578 45   unmatched   PASS",
    "crumbs": [
      "Tutorial: getting started"
    ]
  },
  {
    "objectID": "tutorials/getting_started.html#how-do-i-obtain-metadata",
    "href": "tutorials/getting_started.html#how-do-i-obtain-metadata",
    "title": "Tutorial: getting started",
    "section": "",
    "text": "First, let’s start with retrieving metadata for all GAMBL samples. We can control which samples to be included in the output with seq_type_filter argument, which returns genome samples by default. To return metadata for capture samples, set seq_type_filter = \"capture\". It is also possible to return metadata for more than one seq type, e.g seq_type_filter = c(\"genome\", \"capture\").\n\nmetadata &lt;- list()\n# Get gambl metadata for genome samples\nmetadata$genomes &lt;- get_gambl_metadata(\n    seq_type_filter = \"genome\"\n)\nmetadata$capture &lt;- get_gambl_metadata(\n    seq_type_filter = \"capture\"\n)\nmetadata$all &lt;- get_gambl_metadata(\n    seq_type_filter = c(\"genome\", \"capture\")\n)\n\nmetadata$cell_lines &lt;- get_gambl_metadata() %&gt;%\n    filter(\n        cohort == \"DLBCL_cell_lines\"\n    )\n\nNow that we have the metadata, we can look at the expected column names and their format:\n\nstr(metadata$all)\n\n'data.frame':   2863 obs. of  29 variables:\n $ age_group           : chr  \"Other\" \"Other\" \"Other\" \"Other\" ...\n $ bam_available       : logi  TRUE TRUE TRUE TRUE TRUE TRUE ...\n $ cohort              : chr  \"BL_Thomas\" \"BL_Thomas\" \"BL_Thomas\" \"BL_Thomas\" ...\n $ compression         : chr  \"cram\" \"cram\" \"cram\" \"cram\" ...\n $ COO_consensus       : chr  NA NA NA NA ...\n $ DHITsig_consensus   : chr  \"NA\" \"NA\" \"NA\" \"NA\" ...\n $ EBV_status_inf      : chr  \"EBV-positive\" \"EBV-negative\" \"EBV-negative\" \"EBV-negative\" ...\n $ ffpe_or_frozen      : chr  \"frozen\" \"frozen\" \"frozen\" \"frozen\" ...\n $ fl_grade            : chr  NA NA NA NA ...\n $ genetic_subgroup    : chr  \"DGG-BL\" \"DGG-BL\" \"IC-BL\" \"IC-BL\" ...\n $ genome_build        : chr  \"hg38\" \"hg38\" \"hg38\" \"hg38\" ...\n $ hiv_status          : chr  NA NA NA NA ...\n $ lymphgen            : chr  \"ST2\" \"Other\" \"Other\" \"Other\" ...\n $ lymphgen_cnv_noA53  : chr  \"ST2\" \"Other\" \"Other\" \"Other\" ...\n $ lymphgen_no_cnv     : chr  \"ST2\" \"Other\" \"Other\" \"Other\" ...\n $ lymphgen_with_cnv   : chr  \"ST2\" \"Other\" \"Other\" \"Other\" ...\n $ lymphgen_wright     : chr  NA NA NA NA ...\n $ molecular_BL        : chr  NA NA NA NA ...\n $ normal_sample_id    : chr  NA NA NA NA ...\n $ pairing_status      : chr  \"unmatched\" \"unmatched\" \"unmatched\" \"unmatched\" ...\n $ pathology           : chr  \"BL\" \"BL\" \"BL\" \"BL\" ...\n $ pathology_rank      : num  7 7 7 7 7 7 7 7 7 7 ...\n $ patient_id          : chr  \"BLGSP-71-29-00539\" \"BLGSP-71-29-00525\" \"BLGSP-71-29-00528\" \"BLGSP-71-29-00526\" ...\n $ reference_PMID      : num  36201743 36201743 36201743 36201743 36201743 ...\n $ sample_id           : chr  \"Akata\" \"BL2\" \"BL30\" \"BL41\" ...\n $ seq_type            : chr  \"genome\" \"genome\" \"genome\" \"genome\" ...\n $ sex                 : chr  \"NA\" \"NA\" \"NA\" \"NA\" ...\n $ time_point          : chr  \"A\" \"A\" \"A\" \"A\" ...\n $ Tumor_Sample_Barcode: chr  \"Akata\" \"BL2\" \"BL30\" \"BL41\" ...\n\n\nWe can now use the metadata as we wish. For example, we can visualize the counts of samples per pathology and sequencing type:\n\n# We can see what is included in the metadata\nmetadata$all %&gt;%\n    count(pathology, seq_type) %&gt;%\n    ggplot_consistent(\n        aes(\n            x = pathology,\n            y = n,\n            fill = pathology\n        )\n    ) +\n    geom_bar(stat = \"identity\") +\n    facet_wrap(~seq_type, scales = \"free\") +\n    geom_text(aes(label=n), size=3.5) +\n    theme(\n        axis.text.x = element_text(\n            angle = 90,\n            vjust = 0.5,\n            hjust = 1\n        )\n    )\n\n\n\n\n\n\n\n# We can also visualize these counts when subset to only DLBCL:\n# Subset metadata on a set of samples (samples classified as DLBCL for pathology)\nmetadata$dlbcl &lt;- metadata$all %&gt;%\n    filter(pathology == \"DLBCL\")\n\nmetadata$dlbcl %&gt;%\n    count(pathology, seq_type) %&gt;%\n    ggplot_consistent(\n        aes(\n            x = pathology,\n            y = n,\n            fill = pathology\n        )\n    ) +\n    geom_bar(stat = \"identity\") +\n    facet_wrap(~seq_type) +\n    geom_text(aes(label=n), size=3.5)",
    "crumbs": [
      "Tutorial: getting started"
    ]
  },
  {
    "objectID": "tutorials/getting_started.html#how-do-i-obtain-ssm",
    "href": "tutorials/getting_started.html#how-do-i-obtain-ssm",
    "title": "Tutorial: getting started",
    "section": "",
    "text": "Based on the information available to you, your application, or your downstream analysis, there are multiple ways to retrieve SSM data. For example, if you know the sample ID and are only interested in looking at SSM results for that particular sample, you can use get_ssm_by_sample. If multiple samples are to be analyzed, get_ssm_by_samples (plural version) is recommended. You can also use patient IDs for retrieving this data, in this case get_ssm_by_patients is available. In addition, you can also restrict SSM calls to specific genomic regions with get_ssm_by_regions or get_ssm_by_region.\nAnother possibility is to focus on coding mutations only and call get_coding_ssm, this function returns all coding SSMs from the bundled data in maf-like format. If you have an already pre-filtered metadata, the these_samples_metadata argument can be used with all SSM functions to restrict the variants returned to the sample IDs in this data frame, handy!\n\n\nReturn SSMs for one or more samples with get_ssm_by_samples. In the example below, we are requesting SSM for the DOHH-2 cell line in two different ways:\n\n\n\nmy_sample_id &lt;- \"DOHH-2\"\n\n# Using the these_samples_id argument\nssm_sample &lt;- get_ssm_by_samples(these_sample_ids = my_sample_id)\n\n# How many mutations do we get back?\ndim(ssm_sample)\n\n[1] 22089    49\n\n# What columns are available?\ncolnames(ssm_sample)\n\n [1] \"Hugo_Symbol\"                   \"Entrez_Gene_Id\"               \n [3] \"Center\"                        \"NCBI_Build\"                   \n [5] \"Chromosome\"                    \"Start_Position\"               \n [7] \"End_Position\"                  \"Strand\"                       \n [9] \"Variant_Classification\"        \"Variant_Type\"                 \n[11] \"Reference_Allele\"              \"Tumor_Seq_Allele1\"            \n[13] \"Tumor_Seq_Allele2\"             \"dbSNP_RS\"                     \n[15] \"dbSNP_Val_Status\"              \"Tumor_Sample_Barcode\"         \n[17] \"Matched_Norm_Sample_Barcode\"   \"Match_Norm_Seq_Allele1\"       \n[19] \"Match_Norm_Seq_Allele2\"        \"Tumor_Validation_Allele1\"     \n[21] \"Tumor_Validation_Allele2\"      \"Match_Norm_Validation_Allele1\"\n[23] \"Match_Norm_Validation_Allele2\" \"Verification_Status\"          \n[25] \"Validation_Status\"             \"Mutation_Status\"              \n[27] \"Sequencing_Phase\"              \"Sequence_Source\"              \n[29] \"Validation_Method\"             \"Score\"                        \n[31] \"BAM_File\"                      \"Sequencer\"                    \n[33] \"Tumor_Sample_UUID\"             \"Matched_Norm_Sample_UUID\"     \n[35] \"HGVSc\"                         \"HGVSp\"                        \n[37] \"HGVSp_Short\"                   \"Transcript_ID\"                \n[39] \"Exon_Number\"                   \"t_depth\"                      \n[41] \"t_ref_count\"                   \"t_alt_count\"                  \n[43] \"n_depth\"                       \"n_ref_count\"                  \n[45] \"n_alt_count\"                   \"RefSeq\"                       \n[47] \"Pipeline\"                      \"Study\"                        \n[49] \"maf_seq_type\"                 \n\n# What variants are available?\nssm_sample %&gt;%\n    count(Variant_Classification) %&gt;%\n    ggplot_consistent(\n        aes(\n            x = Variant_Classification,\n            y = n,\n            fill = Variant_Classification\n        )\n    ) +\n    geom_bar(stat = \"identity\") +\n    geom_text(aes(label=n), size=3.5, vjust = -0.5) +\n    theme(\n        axis.text.x = element_text(\n            angle = 90,\n            vjust = 0.5,\n            hjust = 1\n        )\n    )\n\n\n\n\n\n\n\n\n\n\n\nWe can supply instead a metadata table that has already been subset to the sample ID(s) of interest.\n\nmetadata$dohh2 &lt;- metadata$genome %&gt;%\n    filter(sample_id == \"DOHH-2\")\n\n# Using the these_samples_metadata argument\nssm_meta &lt;- get_ssm_by_samples(\n    these_samples_metadata = metadata$dohh2\n)\n\n# How many mutations do we get back?\ndim(ssm_meta)\n\n[1] 22089    49\n\n# What columns are available?\ncolnames(ssm_meta)\n\n [1] \"Hugo_Symbol\"                   \"Entrez_Gene_Id\"               \n [3] \"Center\"                        \"NCBI_Build\"                   \n [5] \"Chromosome\"                    \"Start_Position\"               \n [7] \"End_Position\"                  \"Strand\"                       \n [9] \"Variant_Classification\"        \"Variant_Type\"                 \n[11] \"Reference_Allele\"              \"Tumor_Seq_Allele1\"            \n[13] \"Tumor_Seq_Allele2\"             \"dbSNP_RS\"                     \n[15] \"dbSNP_Val_Status\"              \"Tumor_Sample_Barcode\"         \n[17] \"Matched_Norm_Sample_Barcode\"   \"Match_Norm_Seq_Allele1\"       \n[19] \"Match_Norm_Seq_Allele2\"        \"Tumor_Validation_Allele1\"     \n[21] \"Tumor_Validation_Allele2\"      \"Match_Norm_Validation_Allele1\"\n[23] \"Match_Norm_Validation_Allele2\" \"Verification_Status\"          \n[25] \"Validation_Status\"             \"Mutation_Status\"              \n[27] \"Sequencing_Phase\"              \"Sequence_Source\"              \n[29] \"Validation_Method\"             \"Score\"                        \n[31] \"BAM_File\"                      \"Sequencer\"                    \n[33] \"Tumor_Sample_UUID\"             \"Matched_Norm_Sample_UUID\"     \n[35] \"HGVSc\"                         \"HGVSp\"                        \n[37] \"HGVSp_Short\"                   \"Transcript_ID\"                \n[39] \"Exon_Number\"                   \"t_depth\"                      \n[41] \"t_ref_count\"                   \"t_alt_count\"                  \n[43] \"n_depth\"                       \"n_ref_count\"                  \n[45] \"n_alt_count\"                   \"RefSeq\"                       \n[47] \"Pipeline\"                      \"Study\"                        \n[49] \"maf_seq_type\"                 \n\n# What variants are available?\nssm_meta %&gt;%\n    count(Variant_Classification) %&gt;%\n    ggplot_consistent(\n        aes(\n            x = Variant_Classification,\n            y = n,\n            fill = Variant_Classification\n        )\n    ) +\n    geom_bar(stat = \"identity\") +\n    geom_text(aes(label=n), size=3.5, vjust = -0.5) +\n    theme(\n        axis.text.x = element_text(\n            angle = 90,\n            vjust = 0.5,\n            hjust = 1\n        )\n    )\n\n\n\n\n\n\n\n\nWe can make sure that both approaches generate identical outputs:\n\nidentical(\n    ssm_sample,\n    ssm_meta\n)\n\n[1] TRUE\n\n\nThus, there is no “right” or “wrong” way, it is simply your personal preference!\n\n\n\nOften many downstream tools can only work on one specific genome build, and GAMBLR.data provides a simple and straightforward way to obtain variants in different projections. The default output is always with respect to grch37, and it can be easily modified with argument projection:\n\nssm_hg38 &lt;- get_ssm_by_samples(\n    projection = \"hg38\"\n)\n\n# Sanity check the projection\nssm_hg38 %&gt;%\n    count(NCBI_Build) %&gt;%\n    ggplot_consistent(\n        aes(\n            x = NCBI_Build,\n            y = n,\n            fill = NCBI_Build\n        )\n    ) +\n    geom_bar(stat = \"identity\") +\n    geom_text(aes(label=n), size=3.5, vjust = -0.5)\n\n\n\n\n\n\n\n\nAs we did not specify any sample ID, metadata, or gene to the above call, it returned the data for all samples available in GAMBLR.data, and we can see from the plot that all of the variants are with respect to hg38. Sweet! 😎\n\n\n\n\nIn this section, we are exploring the different ways you can obtain the maf data for a specific region (or regions) of interest.\nIn this example, we will obtain SSM calls for all aSHM regions associated with PAX5 across all available samples. With this function we also will get the region name added to the returned data frame. If you are providing regions as a bed file (regions_bed), you have the option of setting use_name_column = TRUE. If you do so, your bed file should have a column simply named “name”. In this case, the function will keep this column for naming the returned regions in the maf. With streamlined = TRUE the function returns the minimal number of columns.\n\n\n\n\n\n\nNote\n\n\n\nDon’t know coordinates of aSHM at PAX5? GAMBLR.data has you covered!\n\n\n\n# Get aSHM genes, select the columns of interest and rename for\n# get_ssm_by_regions compatibility\nashm_gene &lt;- \"PAX5\"\nregions &lt;- create_bed_data(\n    GAMBLR.data::grch37_ashm_regions %&gt;%\n        filter(gene == ashm_gene),\n    fix_names = \"concat\",\n    concat_cols = c(\"gene\",\"region\"),\n    sep=\"-\"\n)\n\n# Get ssm for all ashm regions\nashm_ssm &lt;- get_ssm_by_regions(\n    these_samples_metadata = metadata$genomes,\n    regions_bed = regions,\n    streamlined = FALSE\n)\n\ndim(ashm_ssm)\n\n[1] 3238   50\n\nashm_ssm[1:5,1:10]\n\nMAF Data Object\nGenome Build: \nShowing first 10 rows:\n  Hugo_Symbol Entrez_Gene_Id Center NCBI_Build Chromosome Start_Position\n1        PAX5              0      .     GRCh37          9       37033520\n2        PAX5              0      .     GRCh37          9       37034762\n3        PAX5              0      .     GRCh37          9       37033894\n4        PAX5              0      .     GRCh37          9       37035326\n5        PAX5              0      .     GRCh37          9       37030604\n  End_Position Strand Variant_Classification Variant_Type\n1     37033520      +                 Intron          SNP\n2     37034762      +                5'Flank          SNP\n3     37033894      +                 Intron          SNP\n4     37035326      +                5'Flank          SNP\n5     37030604      +                 Intron          SNP\n\n\n\n\n\nLastly, another way to retrieve SSM is to call get_coding_ssm. This function returns coding SSM for any given sample. This function is a convenient option for anyone interested in focusing only on coding mutations. Convenient filtering arguments are included in this function for easy and straightforward subsetting. If these arguments are not used, coding SSM will be returned for all samples. Of course, similar to the examples above, you can provide a metadata subset that has already been filtered to the sample IDs of interest (using these_samples_metadata).\n\n# All default arguments\nall_ssm &lt;- get_coding_ssm()\ndim(all_ssm)\n\n[1] 13913    49\n\n# Provide metadata\ndlbcl_cell_lines &lt;- get_coding_ssm(\n    these_samples_metadata = metadata$cell_lines\n)\ndim(dlbcl_cell_lines)\n\n[1] 1616   49",
    "crumbs": [
      "Tutorial: getting started"
    ]
  },
  {
    "objectID": "tutorials/getting_started.html#how-do-i-obtain-cnv",
    "href": "tutorials/getting_started.html#how-do-i-obtain-cnv",
    "title": "Tutorial: getting started",
    "section": "",
    "text": "For the purpose of retrieving CN data, we have the function get_sn_segments. If you want to query CN calls for a specific region or genomic loci, get_cn_segments is best used. In this section we will demonstrate how this function can be used.\n\n\nWe can use metadata restricted to the sample ID of interest to demonstrate what type of data will be returned:\n\nseg &lt;- get_cn_segments(\n    these_samples_metadata = metadata$cell_lines\n)\n\n# What are the columns we have available?\nhead(seg)\n\nSEG Data Object\nGenome Build: grch37 \nShowing first 10 rows:\n      ID chrom     start       end LOH_flag log.ratio CN\n1 DOHH-2     1     10001  86026719        0         0  2\n2 DOHH-2     1  86026720  86688464        1         0  2\n3 DOHH-2     1  86688465 121499999        0         0  2\n4 DOHH-2     1 142600001 249250620        0         0  2\n5 DOHH-2     2     10001  89087285        0         0  2\n6 DOHH-2     2  89087286  89997184        1       -10  0\n\n\n\n\n\nWe can retrieve CN segments while also requesting a different projection. Similar to the SSM functionality shown earlier, this can be done by toggling the projection argument and switching it to the hg38 value.\n\n# Call in hg38 projection\nseg &lt;- get_cn_segments(\n    these_samples_metadata = metadata$cell_lines,\n    projection = \"hg38\"\n)\n\nhead(seg)\n\nSEG Data Object\nGenome Build: hg38 \nShowing first 10 rows:\n      ID chrom     start       end LOH_flag log.ratio CN\n1 DOHH-2  chr1     10001  85561036        0         0  2\n2 DOHH-2  chr1  85561037  86222781        1         0  2\n3 DOHH-2  chr1  86222782 121699999        0         0  2\n4 DOHH-2  chr1 143200001 248956421        0         0  2\n5 DOHH-2  chr2         1  91799999        0         0  2\n6 DOHH-2  chr2  96000001 242193528        0         0  2",
    "crumbs": [
      "Tutorial: getting started"
    ]
  },
  {
    "objectID": "tutorials/getting_started.html#how-do-i-obtain-sv",
    "href": "tutorials/getting_started.html#how-do-i-obtain-sv",
    "title": "Tutorial: getting started",
    "section": "",
    "text": "In this last section, we will explore how to get SV data using GAMBLR.data. For this purpose get_manta_sv was developed. This function can restrict the returned calls to any genomic regions specified with chromosome, qstart, qend, or the complete region specified with the region argument (in chr:start-end format). In addition, useful filtering arguments are also available, use min_vaf to set the minimum tumour VAF in order for a SV to be returned and min_score to set the lowest Manta somatic score in order for a SV to be returned. pair_status can be used to obtain variants from either matched or unmatched samples.\n\n\nWe will call get_manta_sv with default arguments to examine the output.\n\n# Default arguments\nall_manta &lt;- get_manta_sv()\n\n# How many SVs do we get back?\nnrow(all_manta)\n\n[1] 1154\n\n# How many samples do we have SV calls for?\nlength(unique(all_manta$tumour_sample_id))\n\n[1] 580\n\n# What does the returned data frame look like?\nhead(all_manta)\n\n  CHROM_A   START_A     END_A CHROM_B   START_B     END_B\n1       1 161658631 161658631       3  16509907  16509907\n2       1 161663959 161663959       9  37363320  37363320\n3       1 161663959 161663959       9  37363320  37363320\n4      11  65267283  65267283      14 106110907 106110907\n5      11  65267422  65267422      14 106110905 106110905\n6      13  91976545  91976545      14 106211857 106211857\n                     manta_name SCORE STRAND_A STRAND_B tumour_sample_id\n1      MantaBND:21171:0:1:0:0:0   133        +        +         FL2002T1\n2     MantaBND:206628:0:1:0:0:0   122        +        +  09-15842_tumorA\n3     MantaBND:195941:0:1:0:0:0   151        +        +  09-15842_tumorB\n4   MantaBND:152220:0:1:0:0:0:0    88        +        -        15-38154T\n5   MantaBND:152220:0:1:0:0:0:0   135        -        +        15-38154T\n6 MantaBND:18:59794:59817:0:1:0    90        -        +        15-31924T\n  normal_sample_id VAF_tumour  DP pair_status FILTER\n1          FL2002N      0.331 127     matched   PASS\n2  09-15842_normal      0.281 196     matched   PASS\n3  09-15842_normal      0.364 187     matched   PASS\n4        15-38154N      0.150 167     matched   PASS\n5        15-38154N      0.290 169     matched   PASS\n6        15-31924N      0.365  85     matched   PASS\n\n\n\n\n\nAlternatively, you can also provide these_samples_metadata argument to make use of a pre-filtered metadata table. In this case, the returned SVs will be restricted to the sample_ids within the data frame.\n\ncell_line_manta &lt;- get_manta_sv(\n    these_samples_metadata = metadata$cell_lines\n)\n\n# How many SVs do we get back?\nnrow(cell_line_manta)\n\n[1] 13\n\n# How many samples do we have SV calls for?\nlength(unique(cell_line_manta$tumour_sample_id))\n\n[1] 3\n\n# What does the returned data frame look like?\nhead(cell_line_manta)\n\n  CHROM_A   START_A     END_A CHROM_B  START_B    END_B\n1      14 106329462 106329462      18 60774579 60774579\n2      14 106329465 106329465      18 60793497 60793497\n3      14 106330466 106330466      18 60793914 60793914\n4      14 106349765 106349765      18 60793914 60793914\n5      14 106379091 106379091      18 60793492 60793492\n6      14 106380227 106380227      18 60774578 60774578\n                 manta_name SCORE STRAND_A STRAND_B tumour_sample_id\n1 MantaBND:220769:1:2:0:0:0   134        +        -        SU-DHL-10\n2 MantaBND:194451:1:2:0:0:0   103        +        -           DOHH-2\n3 MantaBND:217561:1:2:0:0:0   182        +        -         SU-DHL-4\n4 MantaBND:217561:0:1:0:0:0   198        -        +         SU-DHL-4\n5 MantaBND:194451:0:1:0:0:0    91        -        +           DOHH-2\n6 MantaBND:220769:0:1:0:0:0   169        -        +        SU-DHL-10\n  normal_sample_id VAF_tumour DP pair_status FILTER\n1        14-11247N      0.318 66   unmatched   PASS\n2        14-11247N      0.290 69   unmatched   PASS\n3        14-11247N      0.474 57   unmatched   PASS\n4        14-11247N      0.500 62   unmatched   PASS\n5        14-11247N      0.300 60   unmatched   PASS\n6        14-11247N      0.578 45   unmatched   PASS\n\n\n\n\n\nWe can call get_manta_sv specifying the region of interest first in the region format and then with specifying the chromosome, start and end individually.\n\n\n\n\n\n\nNote\n\n\n\nDon’t know coordinates of MYC gene region? GAMBLR got you covered!\n\n\n\n# Convert the gene name to the region\nmyc_region &lt;- gene_to_region(\n    gene_symbol = \"MYC\"\n)\n\nmyc_region\n\n                    MYC \n\"8:128747680-128753674\" \n\n# Specifying MYC in region format\nmyc_manta_region &lt;- get_manta_sv(\n    these_samples_metadata = metadata$genomes,\n    region = myc_region,\n    min_vaf = 0,\n    min_score = 0\n)\n\n# Specifying MYC with chromosome, qstart and qend arguments\nmyc_manta_chunks &lt;- get_manta_sv(\n    these_samples_metadata = metadata$genomes,\n    chromosome = 8,\n    qstart = 128747680,\n    qend = 128753674,\n    min_vaf = 0,\n    min_score = 0\n)\n\n# Are the returned data frames the same?\nidentical(\n    myc_manta_region,\n    myc_manta_chunks\n)\n\n[1] TRUE\n\n\n\n\n\nHere we are demonstrating the filtering options to obtain SVs. In this example, we are calling get_manta_sv on the DLBCL metadata subset. For demonstration purposes, we are also requesting a non-default projection and adding some more filtering.\n\n# Get manta SVs for the samples with DLBCL pathology\ndlbcl_manta &lt;- get_manta_sv(\n    these_samples_metadata = metadata$dlbcl,\n    projection = \"hg38\",\n    min_vaf = 0.4,\n    min_score = 100\n)\n\n# How many variants do we get back with these filters?\nnrow(dlbcl_manta)\n\n[1] 68\n\n# Does the advertised VAF filters work?\nall(dlbcl_manta$VAF_tumour &gt;= 0.4)\n\n[1] TRUE\n\n# Do the advertised SCORE filter work?\nall(dlbcl_manta$SCORE &gt;= 100)\n\n[1] TRUE\n\n# What does the returned data frame look like?\nhead(cell_line_manta)\n\n  CHROM_A   START_A     END_A CHROM_B  START_B    END_B\n1      14 106329462 106329462      18 60774579 60774579\n2      14 106329465 106329465      18 60793497 60793497\n3      14 106330466 106330466      18 60793914 60793914\n4      14 106349765 106349765      18 60793914 60793914\n5      14 106379091 106379091      18 60793492 60793492\n6      14 106380227 106380227      18 60774578 60774578\n                 manta_name SCORE STRAND_A STRAND_B tumour_sample_id\n1 MantaBND:220769:1:2:0:0:0   134        +        -        SU-DHL-10\n2 MantaBND:194451:1:2:0:0:0   103        +        -           DOHH-2\n3 MantaBND:217561:1:2:0:0:0   182        +        -         SU-DHL-4\n4 MantaBND:217561:0:1:0:0:0   198        -        +         SU-DHL-4\n5 MantaBND:194451:0:1:0:0:0    91        -        +           DOHH-2\n6 MantaBND:220769:0:1:0:0:0   169        -        +        SU-DHL-10\n  normal_sample_id VAF_tumour DP pair_status FILTER\n1        14-11247N      0.318 66   unmatched   PASS\n2        14-11247N      0.290 69   unmatched   PASS\n3        14-11247N      0.474 57   unmatched   PASS\n4        14-11247N      0.500 62   unmatched   PASS\n5        14-11247N      0.300 60   unmatched   PASS\n6        14-11247N      0.578 45   unmatched   PASS",
    "crumbs": [
      "Tutorial: getting started"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "GAMBLR.open",
    "section": "",
    "text": "Why use GAMBLR.open?\n  \n  \n    \n     How to install?\n  \n  \n    \n     How to use?\n  \n  \n    \n     Release notes\n  \n  \n    \n     GitHub"
  },
  {
    "objectID": "index.html#about",
    "href": "index.html#about",
    "title": "GAMBLR.open",
    "section": "About",
    "text": "About\nThe GAMBLR-verse is a database, mining, manipulation and collection of a convenience functions for working with genomic data of mature B-cell lymphomas. The GAMBLR.open is an open-source package that is a wrapper providing a convenient one-stop access to load the following packages from the GAMBLR family:\n\nGAMBLR.open - collection of genomic data for analysis of Mature B-cell neoplasms\nGAMBLR.data - a “storage unit” with different types of bundled data.\nGAMBLR.helpers - a set of low-level functions for data operation\nGAMBLR.utils - higher level set of functions to operate on genomic data\nGAMBLR.viz - set of functions used mostly for visualizations\nGAMBLR.predict - collection of functions and helpers to classify B-cell lymphomas\n\nIn addition, a number of simple functions is included, giving access to a light-weight version of the functionality available for the GAMBL consortium members.\n\n\n\n\n\n\nWho should use this package?\n\n\n\nThis package is recommended for the community interested in lymphoma genomics research and are not members of the GAMBL consortium, or if you are waiting for your access approval but want to get started. In addition to being a large resource for lymphoma researchers, this package is also a great educational resource for junior users interested in bioinformatics analyses, genomics, software analysis, data engineering, R package development, GitHub workflows, and other best practices."
  },
  {
    "objectID": "index.html#install",
    "href": "index.html#install",
    "title": "GAMBLR.open",
    "section": "Install",
    "text": "Install\nTo install this package, we recommend doing it by accessing the latest master version directly from GitHub (requires devtools dependency):\ndevtools::install_github(\n    \"morinlab/GAMBLR.open\",\n    repos = BiocManager::repositories()\n)\n\n\n\nQuickstart"
  },
  {
    "objectID": "index.html#quickstart",
    "href": "index.html#quickstart",
    "title": "GAMBLR.open",
    "section": "Quickstart",
    "text": "Quickstart\nThe quick and easy way to get started is to make sure the devtools dependency is installed, then install the GAMBLR.open and run the simplest functions to confirm successful setup:\n# Verify devtools is installed\nif (!require(\"devtools\")) install.packages(\"devtools\")\n\n# Install GAMBLR.open\ndevtools::install_github(\n    \"morinlab/GAMBLR.open\",\n    repos = BiocManager::repositories()\n)\nWe recommend restarting your R session after the installation.\n\nlibrary(GAMBLR.open)\n\n# Confirm successful setup\nmetadata &lt;- get_gambl_metadata()\nmaf &lt;- get_coding_ssm()"
  },
  {
    "objectID": "index.html#installation-for-developers",
    "href": "index.html#installation-for-developers",
    "title": "GAMBLR.open",
    "section": "Installation for developers",
    "text": "Installation for developers\nThe easiest way to obtain and contribute to GAMBLR.open is to do this via cloning the repository\ncd\ngit clone git@github.com:morinlab/GAMBLR.open.git\nIn your R editor of choice (which is hopefully VS Code), set your working directory to the directory you just cloned the repo into.\nsetwd(\"~/GAMBLR.open\")\nInstall the package in R by running the following command (requires the devtools package):\ndevtools::install()\nAfter applying your modifications to the code, use the following command to quickly test your changes without directly installing the package (requires the devtools dependency):\ndevtools::load_all()\nGAMBLR.open is a free open-source package, but the Master branch is protected. We welcome contributions (pull request, bug report, feature request, PR review) from all levels of users. All commits must be submitted via pull request on a branch. Please refer to the GitHub documentation for details on how to do pull request."
  },
  {
    "objectID": "why.html",
    "href": "why.html",
    "title": "Why GAMBLR.open?",
    "section": "",
    "text": "GAMBLR.open is designed to make open-access genomic data of mature B-cell lymphomas more accessible and easier to analyze. Whether you’re a researcher, data scientist, or student, this package provides a seamless interface for querying, retrieving, and preprocessing genomic data, so you can focus on analysis rather than data wrangling.\nGAMBLR stands for Genomic Analysis of Mature B-cell Lymphomas in R, and is part of the family of R packages for lymphoma cancer research called “GAMBLR-verse” and developed in the Morin Lab at the Simon Fraser University. For more details, please refer to the GAMBLR family section.",
    "crumbs": [
      "Why GAMBLR.open?"
    ]
  },
  {
    "objectID": "why.html#open-data-access-simplified",
    "href": "why.html#open-data-access-simplified",
    "title": "Why GAMBLR.open?",
    "section": "",
    "text": "GAMBLR.open is designed to make open-access genomic data of mature B-cell lymphomas more accessible and easier to analyze. Whether you’re a researcher, data scientist, or student, this package provides a seamless interface for querying, retrieving, and preprocessing genomic data, so you can focus on analysis rather than data wrangling.\nGAMBLR stands for Genomic Analysis of Mature B-cell Lymphomas in R, and is part of the family of R packages for lymphoma cancer research called “GAMBLR-verse” and developed in the Morin Lab at the Simon Fraser University. For more details, please refer to the GAMBLR family section.",
    "crumbs": [
      "Why GAMBLR.open?"
    ]
  },
  {
    "objectID": "why.html#who-is-it-for",
    "href": "why.html#who-is-it-for",
    "title": "Why GAMBLR.open?",
    "section": "Who Is It For?",
    "text": "Who Is It For?\nThe GAMBLR.open primarily targets:\n\nresearchers who need rapid access to standardized genomic datasets.\ndata scientists and bioinformaticians looking for structured and easily queryable cancer genomics data.\nstudents who want to explore real-world genomic data in a learning environment.",
    "crumbs": [
      "Why GAMBLR.open?"
    ]
  },
  {
    "objectID": "why.html#what-does-gamblr.open-offer",
    "href": "why.html#what-does-gamblr.open-offer",
    "title": "Why GAMBLR.open?",
    "section": "What does GAMBLR.open offer?",
    "text": "What does GAMBLR.open offer?\nSome of the advantages of GAMBLR.open are:\n\nAccess to preprocessed genomic data: retrieve genomic datasets without worrying about complex file handling.\nStandardized data queries: easily search and filter genomic data using a consistent and intuitive API.\nIntegration of GAMBLR ecosystem: work seamlessly with the broader GAMBLR suite of packages to design analytical workflows.\nReproducibility and transparency: leverage a well-documented pipelines to ensure consistent and transparent data retrieval.",
    "crumbs": [
      "Why GAMBLR.open?"
    ]
  },
  {
    "objectID": "why.html#local-experience",
    "href": "why.html#local-experience",
    "title": "Why GAMBLR.open?",
    "section": "Local experience",
    "text": "Local experience\nThe data bundled with the GAMBLR.data is immediately available upon package installation and does not require internet connection or ssh access to GSC resources. It can run anywhere that R is available without restrictions and limitations.",
    "crumbs": [
      "Why GAMBLR.open?"
    ]
  },
  {
    "objectID": "why.html#community",
    "href": "why.html#community",
    "title": "Why GAMBLR.open?",
    "section": "Community",
    "text": "Community\nCommunity discussions primarily happen through issue submission on GitHub.",
    "crumbs": [
      "Why GAMBLR.open?"
    ]
  },
  {
    "objectID": "why.html#getting-started",
    "href": "why.html#getting-started",
    "title": "Why GAMBLR.open?",
    "section": "Getting started",
    "text": "Getting started\nExplore the documentation and start using GAMBLR.open today!",
    "crumbs": [
      "Why GAMBLR.open?"
    ]
  },
  {
    "objectID": "install.html",
    "href": "install.html",
    "title": "Installation",
    "section": "",
    "text": "Installation\nThis package is recommended for the community interested in lymphoma genomics research and are not members of the GAMBL consortium, or if you are waiting for your access approval but want to get started. In addition to being a large resource for lymphoma researchers, this package is also a great educational resource for junior users interested in bioinformatics analyses, genomics, software analysis, data engineering, R package development, GitHub workflows, and other best practices.\nWe recommend installing the package directly from GitHub (requires devtools dependency).\nif (!require(\"devtools\")) install.packages(\"devtools\")\n\ndevtools::install_github(\n    \"morinlab/GAMBLR.open\",\n    repos = BiocManager::repositories()\n)\nThis will install all required dependencies and members of the GAMBLR-verse available to you.\nAfter installation, you can confirm successful setup:\n\n# Confirm successful setup\nlibrary(GAMBLR.open) # load package\n\n\n\n\n\n Back to top",
    "crumbs": [
      "Installation"
    ]
  },
  {
    "objectID": "tutorials/assemble_feature_matrix.html",
    "href": "tutorials/assemble_feature_matrix.html",
    "title": "Tutorial: assemble feature matrix",
    "section": "",
    "text": "In 2023, the Morin Lab developed a classifier of Follicular Lymphoma (FL) predictive of histological transformation to more aggressive DLBCL. This study was published in Blood (2023). How was the binary feature matrix assembled for that machine learning model?\nIn this quick tour we will show how GAMBLR.data resources and functionality of GAMBLR.open can help you to generate such matrix.\n\n# Load packages\nlibrary(GAMBLR.open)\nlibrary(tidyverse)\n\nThis tutorial explores how to obtain metadata for the samples, simple somatic mutations in maf format, and auto-magically transform it into a binary matrix of features.\nTo simplify this tutorial, we will only include a small subset of features (not the whole set as was used in the original paper), but this example will be able to illustrate the functionality and highlight the main steps of the process.\n\n\nIn the previous tutorial, we have already explored the function get_gambl_metadata(). We will use it to retreive the metadata:\n\nmetadata &lt;- get_gambl_metadata() %&gt;%\n    filter(\n        cohort == \"FL_Dreval\"\n    )\n\nWe can now see that the samples from the FL study are in the cohort FL_Dreval. Let’s explore these samples more:\n\ntable(metadata$pathology)\n\n\nCOMFL DLBCL    FL \n   21   209   213 \n\n\nFor illustration purposes, let’s take 10 samples from the FL study: 5 FL and 5 DLBCL:\n\n# Only filter for the samples from FL study\nmetadata &lt;- metadata %&gt;%\n    filter(pathology %in% c(\"FL\", \"DLBCL\")) %&gt;%\n    group_by(pathology) %&gt;%\n    arrange(sample_id) %&gt;%\n    slice_tail(n = 5) %&gt;%\n    ungroup\n\n# How does our metadata looks like now?\nstr(metadata)\n\ntibble [10 × 29] (S3: tbl_df/tbl/data.frame)\n $ age_group           : chr [1:10] \"Other\" \"Other\" \"Other\" \"Other\" ...\n $ bam_available       : logi [1:10] TRUE TRUE TRUE TRUE TRUE TRUE ...\n $ cohort              : chr [1:10] \"FL_Dreval\" \"FL_Dreval\" \"FL_Dreval\" \"FL_Dreval\" ...\n $ compression         : chr [1:10] \"cram\" \"cram\" \"cram\" \"cram\" ...\n $ COO_consensus       : chr [1:10] \"ABC\" \"GCB\" NA \"ABC\" ...\n $ DHITsig_consensus   : chr [1:10] \"DHITsigNeg\" \"DHITsigNeg\" \"NA\" \"DHITsigNeg\" ...\n $ EBV_status_inf      : chr [1:10] NA NA NA NA ...\n $ ffpe_or_frozen      : chr [1:10] \"frozen\" \"frozen\" \"frozen\" \"frozen\" ...\n $ fl_grade            : chr [1:10] NA NA NA NA ...\n $ genetic_subgroup    : chr [1:10] \"dFL\" \"dFL\" \"dFL\" \"dFL\" ...\n $ genome_build        : chr [1:10] \"hs37d5\" \"hs37d5\" \"hs37d5\" \"hs37d5\" ...\n $ hiv_status          : chr [1:10] NA NA NA NA ...\n $ lymphgen            : chr [1:10] \"Other\" \"Other\" \"BN2\" \"MCD-COMP\" ...\n $ lymphgen_cnv_noA53  : chr [1:10] \"Other\" \"Other\" \"BN2\" \"BN2/MCD\" ...\n $ lymphgen_no_cnv     : chr [1:10] \"MCD\" \"Other\" \"BN2\" \"BN2/MCD\" ...\n $ lymphgen_with_cnv   : chr [1:10] \"A53\" \"A53\" \"BN2\" \"BN2/MCD\" ...\n $ lymphgen_wright     : chr [1:10] NA NA NA NA ...\n $ molecular_BL        : chr [1:10] \"non-BL\" \"non-BL\" NA \"non-BL\" ...\n $ normal_sample_id    : chr [1:10] \"SP59410\" \"SP59446\" \"SP59450\" \"SP59454\" ...\n $ pairing_status      : chr [1:10] \"matched\" \"matched\" \"matched\" \"matched\" ...\n $ pathology           : chr [1:10] \"DLBCL\" \"DLBCL\" \"DLBCL\" \"DLBCL\" ...\n $ pathology_rank      : num [1:10] 19 19 19 19 19 15 15 15 15 15\n $ patient_id          : chr [1:10] \"DO27833\" \"DO27851\" \"DO27853\" \"DO27855\" ...\n $ reference_PMID      : num [1:10] 37084389 37084389 37084389 37084389 37084389 ...\n $ sample_id           : chr [1:10] \"SP59412\" \"SP59448\" \"SP59452\" \"SP59456\" ...\n $ seq_type            : chr [1:10] \"genome\" \"genome\" \"genome\" \"genome\" ...\n $ sex                 : chr [1:10] \"M\" \"F\" \"M\" \"F\" ...\n $ time_point          : chr [1:10] \"A\" \"A\" \"A\" \"A\" ...\n $ Tumor_Sample_Barcode: chr [1:10] \"SP59412\" \"SP59448\" \"SP59452\" \"SP59456\" ...\n\n\nOur subsetting worked and we can now proceed with matrix assembly.\n\n\n\nWe will now use the metadata from the previous step to assemble the binary feature matrix.\n\n\nFirst, lets return the data frame with simple somatic mutations in maf format and store it in a variable. Technically this step is not strictly necessary, as each function used below will be able to retreive it for you when the maf data is not provided, but we will advocate for good practice here and have the maf data stored in a designated variable. As we will be utilizing both coding and non-coding mutations, we will take advantage of returning the variants per sample (without necessarily restricting to coding-only variants).\n\n# Obtain simple somatic mutations\nmaf &lt;- get_ssm_by_samples(\n    these_samples_metadata = metadata\n)\n\nWow, that was super easy and blazing fast! Did it even work?? Let’s confirm:\n\n# How many samples are present in maf?\nlength(unique(maf$Tumor_Sample_Barcode))\n\n[1] 10\n\n# Are all these samples the ones we are interested in and requested with metadata?\nsort(unique(maf$Tumor_Sample_Barcode)) == sort(metadata$Tumor_Sample_Barcode)\n\n [1] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n\n# What are the mutations in the maf? Are they just coding?\ntable(maf$Variant_Classification)\n\n\n               3'Flank                  3'UTR                5'Flank \n                    29                     20                    127 \n                 5'UTR        Frame_Shift_Del        Frame_Shift_Ins \n                    61                      7                      1 \n                   IGR           In_Frame_Del                 Intron \n                    46                      2                   1502 \n     Missense_Mutation      Nonsense_Mutation                    RNA \n                    78                      9                     15 \n                Silent          Splice_Region            Splice_Site \n                    29                      6                      8 \nTranslation_Start_Site \n                     1 \n\n\nWe can see from the above outputs that we got somatic mutations for all requested samples and the maf contains both coding and non-coding variants. We can now proceed to the next steps.\n\n\n\nThe feature matrix in the FL study contained coding mutation status at selected genes denoted as 1 when the mutation was present and 0 when there was no mutation. In addition to that, mutation hotspots at some genes were also taken into account. To complicate things more, annotation of hotspots was performed differently depending on the specific gene and mutational effect. Specifically, the CREBBP missemse mutations were considered hotspots when they occured in the KAT domain, but not outside of it. The mutations in FOXO1 were considered hotspots when the AA change was at M1.\nGAMBLR.data provides a one-stop shop to achieve this level of details out-of-the-box in a simple and convenient way, and is directly used by the get_coding_ssm_status function. This function has a logical arguments include_hotspots to separate regular mutations from the ones occurring at hotspots, and review_hotspots, which will handle the specific cases we described above in an automated way. Both of these arguments are TRUE by default, so you do not need to toggle them separately, but in this example we will specify them explicitly just to illustrate that this will happen during the function call. To keep the example clean and concise, we will also annotate the mutation status only for a few of selected genes.\n\n# Specify genes to annotate\nour_genes &lt;- c(\n    \"CREBBP\", \"MYD88\", \"RRAGC\",\n    \"PIM1\", \"BCL2\", \"BCL6\"\n)\n\n# Generate binary matrix\ncoding_matrix &lt;- get_coding_ssm_status(\n    gene_symbols = our_genes,\n    these_samples_metadata = metadata,\n    maf_data = maf,\n    include_hotspots = TRUE,\n    review_hotspots = TRUE\n)\n\ncoding_matrix\n\n   sample_id PIM1 CREBBP RRAGC MYD88 BCL6 BCL2 CREBBPHOTSPOT MYD88HOTSPOT\n1    SP59412    1      1     0     0    0    0             0            0\n2    SP59448    0      0     0     0    0    0             0            0\n3    SP59452    1      0     0     1    1    0             0            0\n4    SP59456    0      0     0     0    0    0             0            0\n5    SP59460    0      0     0     0    1    1             0            1\n6    SP59420    0      1     0     0    0    0             0            0\n7    SP59424    0      0     0     0    0    0             1            0\n8    SP59432    0      0     1     0    0    0             0            0\n9    SP59436    0      1     0     0    0    0             0            0\n10   SP59464    0      0     1     0    0    0             0            0\n\n\nWe can see that in this example there is only one sample with hotspot mutation in CREBBP, SP59424 (annotated as 1 in the column CREBBPHOTSPOT). Let’s sanity check this annotation for illustration purposes:\n\ncrebbp_hotspot_mutation &lt;- maf %&gt;%\n    filter(\n        Tumor_Sample_Barcode == \"SP59424\",\n        Hugo_Symbol == \"CREBBP\"\n    ) %&gt;%\n    select(Chromosome, Start_Position, Variant_Classification)\n\ncrebbp_hotspot_mutation\n\nMAF Data Object\nGenome Build: grch37 \nShowing first 10 rows:\n  Chromosome Start_Position Variant_Classification\n1         16        3788650      Missense_Mutation\n\n\nThis mutation falls within KAT domain and is a missense variant, so it is indeed correct to be annotated as hotspot. How can we check it does fall within KAT domain? This is easy with GAMBLR.data!\n\n# GAMBLR.data has the regions to be considered as hotspots\nhotspot_regions_grch37\n\n               chrom     start       end\nCREBBP            16   3785000   3791000\nEZH2               7 148508764 148506238\nNOTCH1             9 139391455 139391455\nNOTCH2             1 120459150 120459150\nCD79B_trunc       17  62007172  62007172\nCD79B_NONtrunc    17  62006800  62006800\n\n# Now check that CREBBP mutations\nbetween(\n    crebbp_hotspot_mutation$Start_Position,\n    hotspot_regions_grch37[\"CREBBP\", \"start\"],\n    hotspot_regions_grch37[\"CREBBP\", \"end\"]\n)\n\n[1] TRUE\n\n\nWe have now generated matrix of coding mutations and SSM hotspots in a binary format and are ready to proceed to the next step.\n\n\n\nThe FL study also annotated the non-coding mutations at selected aSHM targets as features of binary matrix. Again, all the necessarily means to do it in a simple step are provided by GAMBLR.data. The regions targeted by aSHM are available in the GAMBLR.data. Since they are always complemented with new regions once they are identified, the latest and most comprehensive version is always available by referring to {projection}_ashm_regions. However, this use case is a perfect example to demonstarate how to operate on versioned iterations of the aSHM target list, as the list has been updated since the time the study was published and at the time of publication version 0.2 was used. We can refer to it directly by the version number:\n\nregions_bed &lt;- somatic_hypermutation_locations_GRCh37_v0.2\n\nhead(regions_bed)\n\n  chr_name hg19_start  hg19_end    gene     region regulatory_comment\n1     chr2   96808901  96811913   DUSP2   intron-1           enhancer\n2    chr17   56407732  56410140 TSPOAP1 intergenic           enhancer\n3    chr11  128339774 128345731    ETS1    introns           enhancer\n4    chr11  128388492 128394163    ETS1      TSS-2    active_promoter\n5     chr6   31548325  31550717     LTB   intron-1           enhancer\n6     chr3   32020518  32024930 OSBPL10      TSS-1    active_promoter\n\n\nWe will perform some simple modifications to it to make our experience better and only select few regions for illustrative purposes:\n\nour_regions &lt;- c(\n    \"BCL6-TSS\",\n    \"BCL7A-TSS\",\n    \"RHOH-TSS\",\n    \"ZFP36L1-TSS\"\n)\n\nregions_bed &lt;- create_bed_data(\n    regions_bed,\n    fix_names = \"concat\",\n    concat_cols = c(\"gene\",\"region\"),\n    sep = \"-\",\n    genome_build = \"grch37\"\n)\n\nregions_bed &lt;- regions_bed %&gt;%\n    filter(name %in% our_regions)\n\nregions_bed\n\nBED Data Object\nGenome Build: grch37 \nShowing first 10 rows:\n  chrom     start       end        name region regulatory_comment\n1     3 187458526 187464632    BCL6-TSS    TSS               &lt;NA&gt;\n2    12 122456912 122464036   BCL7A-TSS    TSS    poised_promoter\n3    14  69257848  69259739 ZFP36L1-TSS    TSS    active_promoter\n4     4  40193105  40204231    RHOH-TSS    TSS    active_promoter\n\n\nNow we can see whether or not there are any mutations within these regions:\n\nashm_matrix &lt;- cool_overlaps(\n    maf,\n    regions_bed,\n    columns2 = c(\"chrom\", \"start\", \"end\")\n) %&gt;%\n    group_by(Tumor_Sample_Barcode, name) %&gt;%\n    summarize(n = n()) %&gt;%\n    pivot_wider(\n        id_cols = Tumor_Sample_Barcode,\n        names_from = name,\n        values_from = n,\n        values_fill = 0\n    ) %&gt;%\n    column_to_rownames(\"Tumor_Sample_Barcode\")\nashm_matrix\n\n        BCL6-TSS ZFP36L1-TSS BCL7A-TSS RHOH-TSS\nSP59412        4           1         0        0\nSP59420        1           0         1        0\nSP59424        0           0         0        1\nSP59436        1           0         0        0\nSP59448        6           4        14        3\nSP59452       18           2        12       28\nSP59456        2           6         0        9\nSP59460        1           1         1        2\nSP59464        1           0         0        0\n\n\nWe now calculated the number of mutations in each region for each sample. The original study used pathology-specific values per region to convert these counts to binary, but here we will use an arbitrary cutoff of 5 to binarize these counts. We will also convert rownames to column so it will be easier for us to unite all matrices into single one at the later steps:\n\nashm_matrix[ashm_matrix &lt;= 5] = 0\nashm_matrix[ashm_matrix &gt; 5] = 1\nashm_matrix &lt;- ashm_matrix %&gt;%\n    rownames_to_column(\"sample_id\")\n\nashm_matrix\n\n  sample_id BCL6-TSS ZFP36L1-TSS BCL7A-TSS RHOH-TSS\n1   SP59412        0           0         0        0\n2   SP59420        0           0         0        0\n3   SP59424        0           0         0        0\n4   SP59436        0           0         0        0\n5   SP59448        1           0         1        0\n6   SP59452        1           0         1        1\n7   SP59456        0           1         0        1\n8   SP59460        0           0         0        0\n9   SP59464        0           0         0        0\n\n\nWe have now generated matrix of non-coding mutations in a binary format and are ready to unite all matrices together.\n\n\n\nWe can now combine both coding and non-coding mutations into single matrix:\n\nfeature_matrix &lt;- left_join(\n    coding_matrix,\n    ashm_matrix\n) %&gt;% \n    mutate(\n        across(\n            where(is.numeric), ~ replace_na(.x, 0)\n        )\n    )\n\nfeature_matrix\n\n   sample_id PIM1 CREBBP RRAGC MYD88 BCL6 BCL2 CREBBPHOTSPOT MYD88HOTSPOT\n1    SP59412    1      1     0     0    0    0             0            0\n2    SP59448    0      0     0     0    0    0             0            0\n3    SP59452    1      0     0     1    1    0             0            0\n4    SP59456    0      0     0     0    0    0             0            0\n5    SP59460    0      0     0     0    1    1             0            1\n6    SP59420    0      1     0     0    0    0             0            0\n7    SP59424    0      0     0     0    0    0             1            0\n8    SP59432    0      0     1     0    0    0             0            0\n9    SP59436    0      1     0     0    0    0             0            0\n10   SP59464    0      0     1     0    0    0             0            0\n   BCL6-TSS ZFP36L1-TSS BCL7A-TSS RHOH-TSS\n1         0           0         0        0\n2         1           0         1        0\n3         1           0         1        1\n4         0           1         0        1\n5         0           0         0        0\n6         0           0         0        0\n7         0           0         0        0\n8         0           0         0        0\n9         0           0         0        0\n10        0           0         0        0\n\n\nThat’s it!\nHappy GAMBLing!",
    "crumbs": [
      "Tutorial: assemble feature matrix"
    ]
  },
  {
    "objectID": "tutorials/assemble_feature_matrix.html#obtain-metadata",
    "href": "tutorials/assemble_feature_matrix.html#obtain-metadata",
    "title": "Tutorial: assemble feature matrix",
    "section": "",
    "text": "In the previous tutorial, we have already explored the function get_gambl_metadata(). We will use it to retreive the metadata:\n\nmetadata &lt;- get_gambl_metadata() %&gt;%\n    filter(\n        cohort == \"FL_Dreval\"\n    )\n\nWe can now see that the samples from the FL study are in the cohort FL_Dreval. Let’s explore these samples more:\n\ntable(metadata$pathology)\n\n\nCOMFL DLBCL    FL \n   21   209   213 \n\n\nFor illustration purposes, let’s take 10 samples from the FL study: 5 FL and 5 DLBCL:\n\n# Only filter for the samples from FL study\nmetadata &lt;- metadata %&gt;%\n    filter(pathology %in% c(\"FL\", \"DLBCL\")) %&gt;%\n    group_by(pathology) %&gt;%\n    arrange(sample_id) %&gt;%\n    slice_tail(n = 5) %&gt;%\n    ungroup\n\n# How does our metadata looks like now?\nstr(metadata)\n\ntibble [10 × 29] (S3: tbl_df/tbl/data.frame)\n $ age_group           : chr [1:10] \"Other\" \"Other\" \"Other\" \"Other\" ...\n $ bam_available       : logi [1:10] TRUE TRUE TRUE TRUE TRUE TRUE ...\n $ cohort              : chr [1:10] \"FL_Dreval\" \"FL_Dreval\" \"FL_Dreval\" \"FL_Dreval\" ...\n $ compression         : chr [1:10] \"cram\" \"cram\" \"cram\" \"cram\" ...\n $ COO_consensus       : chr [1:10] \"ABC\" \"GCB\" NA \"ABC\" ...\n $ DHITsig_consensus   : chr [1:10] \"DHITsigNeg\" \"DHITsigNeg\" \"NA\" \"DHITsigNeg\" ...\n $ EBV_status_inf      : chr [1:10] NA NA NA NA ...\n $ ffpe_or_frozen      : chr [1:10] \"frozen\" \"frozen\" \"frozen\" \"frozen\" ...\n $ fl_grade            : chr [1:10] NA NA NA NA ...\n $ genetic_subgroup    : chr [1:10] \"dFL\" \"dFL\" \"dFL\" \"dFL\" ...\n $ genome_build        : chr [1:10] \"hs37d5\" \"hs37d5\" \"hs37d5\" \"hs37d5\" ...\n $ hiv_status          : chr [1:10] NA NA NA NA ...\n $ lymphgen            : chr [1:10] \"Other\" \"Other\" \"BN2\" \"MCD-COMP\" ...\n $ lymphgen_cnv_noA53  : chr [1:10] \"Other\" \"Other\" \"BN2\" \"BN2/MCD\" ...\n $ lymphgen_no_cnv     : chr [1:10] \"MCD\" \"Other\" \"BN2\" \"BN2/MCD\" ...\n $ lymphgen_with_cnv   : chr [1:10] \"A53\" \"A53\" \"BN2\" \"BN2/MCD\" ...\n $ lymphgen_wright     : chr [1:10] NA NA NA NA ...\n $ molecular_BL        : chr [1:10] \"non-BL\" \"non-BL\" NA \"non-BL\" ...\n $ normal_sample_id    : chr [1:10] \"SP59410\" \"SP59446\" \"SP59450\" \"SP59454\" ...\n $ pairing_status      : chr [1:10] \"matched\" \"matched\" \"matched\" \"matched\" ...\n $ pathology           : chr [1:10] \"DLBCL\" \"DLBCL\" \"DLBCL\" \"DLBCL\" ...\n $ pathology_rank      : num [1:10] 19 19 19 19 19 15 15 15 15 15\n $ patient_id          : chr [1:10] \"DO27833\" \"DO27851\" \"DO27853\" \"DO27855\" ...\n $ reference_PMID      : num [1:10] 37084389 37084389 37084389 37084389 37084389 ...\n $ sample_id           : chr [1:10] \"SP59412\" \"SP59448\" \"SP59452\" \"SP59456\" ...\n $ seq_type            : chr [1:10] \"genome\" \"genome\" \"genome\" \"genome\" ...\n $ sex                 : chr [1:10] \"M\" \"F\" \"M\" \"F\" ...\n $ time_point          : chr [1:10] \"A\" \"A\" \"A\" \"A\" ...\n $ Tumor_Sample_Barcode: chr [1:10] \"SP59412\" \"SP59448\" \"SP59452\" \"SP59456\" ...\n\n\nOur subsetting worked and we can now proceed with matrix assembly.",
    "crumbs": [
      "Tutorial: assemble feature matrix"
    ]
  },
  {
    "objectID": "tutorials/assemble_feature_matrix.html#generate-feature-matrix",
    "href": "tutorials/assemble_feature_matrix.html#generate-feature-matrix",
    "title": "Tutorial: assemble feature matrix",
    "section": "",
    "text": "We will now use the metadata from the previous step to assemble the binary feature matrix.\n\n\nFirst, lets return the data frame with simple somatic mutations in maf format and store it in a variable. Technically this step is not strictly necessary, as each function used below will be able to retreive it for you when the maf data is not provided, but we will advocate for good practice here and have the maf data stored in a designated variable. As we will be utilizing both coding and non-coding mutations, we will take advantage of returning the variants per sample (without necessarily restricting to coding-only variants).\n\n# Obtain simple somatic mutations\nmaf &lt;- get_ssm_by_samples(\n    these_samples_metadata = metadata\n)\n\nWow, that was super easy and blazing fast! Did it even work?? Let’s confirm:\n\n# How many samples are present in maf?\nlength(unique(maf$Tumor_Sample_Barcode))\n\n[1] 10\n\n# Are all these samples the ones we are interested in and requested with metadata?\nsort(unique(maf$Tumor_Sample_Barcode)) == sort(metadata$Tumor_Sample_Barcode)\n\n [1] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n\n# What are the mutations in the maf? Are they just coding?\ntable(maf$Variant_Classification)\n\n\n               3'Flank                  3'UTR                5'Flank \n                    29                     20                    127 \n                 5'UTR        Frame_Shift_Del        Frame_Shift_Ins \n                    61                      7                      1 \n                   IGR           In_Frame_Del                 Intron \n                    46                      2                   1502 \n     Missense_Mutation      Nonsense_Mutation                    RNA \n                    78                      9                     15 \n                Silent          Splice_Region            Splice_Site \n                    29                      6                      8 \nTranslation_Start_Site \n                     1 \n\n\nWe can see from the above outputs that we got somatic mutations for all requested samples and the maf contains both coding and non-coding variants. We can now proceed to the next steps.\n\n\n\nThe feature matrix in the FL study contained coding mutation status at selected genes denoted as 1 when the mutation was present and 0 when there was no mutation. In addition to that, mutation hotspots at some genes were also taken into account. To complicate things more, annotation of hotspots was performed differently depending on the specific gene and mutational effect. Specifically, the CREBBP missemse mutations were considered hotspots when they occured in the KAT domain, but not outside of it. The mutations in FOXO1 were considered hotspots when the AA change was at M1.\nGAMBLR.data provides a one-stop shop to achieve this level of details out-of-the-box in a simple and convenient way, and is directly used by the get_coding_ssm_status function. This function has a logical arguments include_hotspots to separate regular mutations from the ones occurring at hotspots, and review_hotspots, which will handle the specific cases we described above in an automated way. Both of these arguments are TRUE by default, so you do not need to toggle them separately, but in this example we will specify them explicitly just to illustrate that this will happen during the function call. To keep the example clean and concise, we will also annotate the mutation status only for a few of selected genes.\n\n# Specify genes to annotate\nour_genes &lt;- c(\n    \"CREBBP\", \"MYD88\", \"RRAGC\",\n    \"PIM1\", \"BCL2\", \"BCL6\"\n)\n\n# Generate binary matrix\ncoding_matrix &lt;- get_coding_ssm_status(\n    gene_symbols = our_genes,\n    these_samples_metadata = metadata,\n    maf_data = maf,\n    include_hotspots = TRUE,\n    review_hotspots = TRUE\n)\n\ncoding_matrix\n\n   sample_id PIM1 CREBBP RRAGC MYD88 BCL6 BCL2 CREBBPHOTSPOT MYD88HOTSPOT\n1    SP59412    1      1     0     0    0    0             0            0\n2    SP59448    0      0     0     0    0    0             0            0\n3    SP59452    1      0     0     1    1    0             0            0\n4    SP59456    0      0     0     0    0    0             0            0\n5    SP59460    0      0     0     0    1    1             0            1\n6    SP59420    0      1     0     0    0    0             0            0\n7    SP59424    0      0     0     0    0    0             1            0\n8    SP59432    0      0     1     0    0    0             0            0\n9    SP59436    0      1     0     0    0    0             0            0\n10   SP59464    0      0     1     0    0    0             0            0\n\n\nWe can see that in this example there is only one sample with hotspot mutation in CREBBP, SP59424 (annotated as 1 in the column CREBBPHOTSPOT). Let’s sanity check this annotation for illustration purposes:\n\ncrebbp_hotspot_mutation &lt;- maf %&gt;%\n    filter(\n        Tumor_Sample_Barcode == \"SP59424\",\n        Hugo_Symbol == \"CREBBP\"\n    ) %&gt;%\n    select(Chromosome, Start_Position, Variant_Classification)\n\ncrebbp_hotspot_mutation\n\nMAF Data Object\nGenome Build: grch37 \nShowing first 10 rows:\n  Chromosome Start_Position Variant_Classification\n1         16        3788650      Missense_Mutation\n\n\nThis mutation falls within KAT domain and is a missense variant, so it is indeed correct to be annotated as hotspot. How can we check it does fall within KAT domain? This is easy with GAMBLR.data!\n\n# GAMBLR.data has the regions to be considered as hotspots\nhotspot_regions_grch37\n\n               chrom     start       end\nCREBBP            16   3785000   3791000\nEZH2               7 148508764 148506238\nNOTCH1             9 139391455 139391455\nNOTCH2             1 120459150 120459150\nCD79B_trunc       17  62007172  62007172\nCD79B_NONtrunc    17  62006800  62006800\n\n# Now check that CREBBP mutations\nbetween(\n    crebbp_hotspot_mutation$Start_Position,\n    hotspot_regions_grch37[\"CREBBP\", \"start\"],\n    hotspot_regions_grch37[\"CREBBP\", \"end\"]\n)\n\n[1] TRUE\n\n\nWe have now generated matrix of coding mutations and SSM hotspots in a binary format and are ready to proceed to the next step.\n\n\n\nThe FL study also annotated the non-coding mutations at selected aSHM targets as features of binary matrix. Again, all the necessarily means to do it in a simple step are provided by GAMBLR.data. The regions targeted by aSHM are available in the GAMBLR.data. Since they are always complemented with new regions once they are identified, the latest and most comprehensive version is always available by referring to {projection}_ashm_regions. However, this use case is a perfect example to demonstarate how to operate on versioned iterations of the aSHM target list, as the list has been updated since the time the study was published and at the time of publication version 0.2 was used. We can refer to it directly by the version number:\n\nregions_bed &lt;- somatic_hypermutation_locations_GRCh37_v0.2\n\nhead(regions_bed)\n\n  chr_name hg19_start  hg19_end    gene     region regulatory_comment\n1     chr2   96808901  96811913   DUSP2   intron-1           enhancer\n2    chr17   56407732  56410140 TSPOAP1 intergenic           enhancer\n3    chr11  128339774 128345731    ETS1    introns           enhancer\n4    chr11  128388492 128394163    ETS1      TSS-2    active_promoter\n5     chr6   31548325  31550717     LTB   intron-1           enhancer\n6     chr3   32020518  32024930 OSBPL10      TSS-1    active_promoter\n\n\nWe will perform some simple modifications to it to make our experience better and only select few regions for illustrative purposes:\n\nour_regions &lt;- c(\n    \"BCL6-TSS\",\n    \"BCL7A-TSS\",\n    \"RHOH-TSS\",\n    \"ZFP36L1-TSS\"\n)\n\nregions_bed &lt;- create_bed_data(\n    regions_bed,\n    fix_names = \"concat\",\n    concat_cols = c(\"gene\",\"region\"),\n    sep = \"-\",\n    genome_build = \"grch37\"\n)\n\nregions_bed &lt;- regions_bed %&gt;%\n    filter(name %in% our_regions)\n\nregions_bed\n\nBED Data Object\nGenome Build: grch37 \nShowing first 10 rows:\n  chrom     start       end        name region regulatory_comment\n1     3 187458526 187464632    BCL6-TSS    TSS               &lt;NA&gt;\n2    12 122456912 122464036   BCL7A-TSS    TSS    poised_promoter\n3    14  69257848  69259739 ZFP36L1-TSS    TSS    active_promoter\n4     4  40193105  40204231    RHOH-TSS    TSS    active_promoter\n\n\nNow we can see whether or not there are any mutations within these regions:\n\nashm_matrix &lt;- cool_overlaps(\n    maf,\n    regions_bed,\n    columns2 = c(\"chrom\", \"start\", \"end\")\n) %&gt;%\n    group_by(Tumor_Sample_Barcode, name) %&gt;%\n    summarize(n = n()) %&gt;%\n    pivot_wider(\n        id_cols = Tumor_Sample_Barcode,\n        names_from = name,\n        values_from = n,\n        values_fill = 0\n    ) %&gt;%\n    column_to_rownames(\"Tumor_Sample_Barcode\")\nashm_matrix\n\n        BCL6-TSS ZFP36L1-TSS BCL7A-TSS RHOH-TSS\nSP59412        4           1         0        0\nSP59420        1           0         1        0\nSP59424        0           0         0        1\nSP59436        1           0         0        0\nSP59448        6           4        14        3\nSP59452       18           2        12       28\nSP59456        2           6         0        9\nSP59460        1           1         1        2\nSP59464        1           0         0        0\n\n\nWe now calculated the number of mutations in each region for each sample. The original study used pathology-specific values per region to convert these counts to binary, but here we will use an arbitrary cutoff of 5 to binarize these counts. We will also convert rownames to column so it will be easier for us to unite all matrices into single one at the later steps:\n\nashm_matrix[ashm_matrix &lt;= 5] = 0\nashm_matrix[ashm_matrix &gt; 5] = 1\nashm_matrix &lt;- ashm_matrix %&gt;%\n    rownames_to_column(\"sample_id\")\n\nashm_matrix\n\n  sample_id BCL6-TSS ZFP36L1-TSS BCL7A-TSS RHOH-TSS\n1   SP59412        0           0         0        0\n2   SP59420        0           0         0        0\n3   SP59424        0           0         0        0\n4   SP59436        0           0         0        0\n5   SP59448        1           0         1        0\n6   SP59452        1           0         1        1\n7   SP59456        0           1         0        1\n8   SP59460        0           0         0        0\n9   SP59464        0           0         0        0\n\n\nWe have now generated matrix of non-coding mutations in a binary format and are ready to unite all matrices together.\n\n\n\nWe can now combine both coding and non-coding mutations into single matrix:\n\nfeature_matrix &lt;- left_join(\n    coding_matrix,\n    ashm_matrix\n) %&gt;% \n    mutate(\n        across(\n            where(is.numeric), ~ replace_na(.x, 0)\n        )\n    )\n\nfeature_matrix\n\n   sample_id PIM1 CREBBP RRAGC MYD88 BCL6 BCL2 CREBBPHOTSPOT MYD88HOTSPOT\n1    SP59412    1      1     0     0    0    0             0            0\n2    SP59448    0      0     0     0    0    0             0            0\n3    SP59452    1      0     0     1    1    0             0            0\n4    SP59456    0      0     0     0    0    0             0            0\n5    SP59460    0      0     0     0    1    1             0            1\n6    SP59420    0      1     0     0    0    0             0            0\n7    SP59424    0      0     0     0    0    0             1            0\n8    SP59432    0      0     1     0    0    0             0            0\n9    SP59436    0      1     0     0    0    0             0            0\n10   SP59464    0      0     1     0    0    0             0            0\n   BCL6-TSS ZFP36L1-TSS BCL7A-TSS RHOH-TSS\n1         0           0         0        0\n2         1           0         1        0\n3         1           0         1        1\n4         0           1         0        1\n5         0           0         0        0\n6         0           0         0        0\n7         0           0         0        0\n8         0           0         0        0\n9         0           0         0        0\n10        0           0         0        0\n\n\nThat’s it!\nHappy GAMBLing!",
    "crumbs": [
      "Tutorial: assemble feature matrix"
    ]
  }
]